\chapter{Entwicklung einer DSL zur Beschreibung der GUI in profil c/s}\label{Entwicklung einer DSL zur Beschreibung der GUI in profil c/s}
\section{1. Iteration}
\subsection*{Analyse der Metadaten}
Die Beschreibung einer \acrshort{GUI} wird in der \g als eigener Komplex
betrachtet (siehe semantisches Modell \emph{UIDescription}). Innerhalb dieses
Komplexes werden die entsprechenden Komponenten definiert. Die Bereiche die innerhalb einer
Beschreibung festgelegt werden sollen, müssen \gks zugeordnet werden
können (siehe semantisches Modell \emph{AreaAssignment}). Diese Bereiche
sollten vor der Entwicklung bereits festgelegt werden. Um abzusichern, dass die
Anzahl der festgelegten Bereiche genau eingehalten wird, muss diese Anzahl in
der GUI-Beschreibung angegeben werden (siehe semantisches Modell \emph{AreaCount}).\\
Für die Beschreibung der Layout-Komponenten werden zwei Typen unterschieden
(siehe semantisches Model \emph{TypeDefinition}), um zwischen obersten
Layout-Komponenten und anderen zu differenzieren.\\
Ein weiterer Aspekt in dem GUI-Skript ist die Verwendung von anderen
GUI-Skripten (siehe semantisches Modell \emph{Use}).\\ 
Zusammenfassend sind für die Beschreibung der GUI folgende Metadaten nötig.
\begin{itemize}
  \item  Anzahl der Bereiche
  \item  Zuweisung der \gks zu den Bereichen
  \item  Angabe des Layout-Typs
  \item  Angabe der Verwendeten GUI-Beschreibungen
  \item  Definition von \gks
\end{itemize}
Die Definitionen der \gks nehmen einen eigenen Komplex innerhalb der
GUI-Beschreibung ein. 
Bezogen auf die \Ks der \acrshort{GUI} ist die
Beschreibung eines Textes wichtig. Im Falle eines Buttons oder eines Labels
(andere \Ks sind in dieser Iteration nicht umgesetzt) beschreibt
dieser die Aufschrift der Komponente.
Weiterhin ist es für die Zuweisung zu einem Bereich wichtig, dass
diese Komponenten innerhalb der Datei referenziert werden können. Daher muss
für jede \gk eine Bezeichnung definiert werden, die innerhalb der
Datei eindeutig ist.\\
An den \Ks können darüber
hinaus Interaktionen beschrieben werden. Hierzu sind Informationen über den
Interaktionstyp nötig.
Der einzige, in dieser Iteration umgesetzte, Interaktionstyp ist ein Klick auf
die Komponente. An dieser Interaktion können ebenso Aktionen definiert werden, die Auswirkungen auf andere Komponenten haben.
Zusammenfassend ergeben sich folgende Metadaten der \Ks.
\begin{itemize}
  \item Typ
  \item Bezeichnung
  \item Text
  \item Interaktion (siehe semantisches Modell \emph{Interaction})
\end{itemize}
Die Interaktion benötigt folgende Attributen, die beschrieben werden müssen.
\begin{itemize}
  \item Bezeichnung
  \item Interaktionstyp
  \item Aktion
\end{itemize}
Aktionen nehmen wiederum einen eigenen Komplex innerhalb der
Komponentendefinition ein. Dabei werden folgende Informationen benötigt.
\begin{itemize}
  \item Aktionstyp\\
  Zur Unterscheidung zwischen Interaktionen mit anderen \gks oder
  fachlichen Modellen
  \item Element\\
  Ein Verweis auf das Element, mit dem interagiert werden soll.
  \item Attribute (siehe semantisches Modell \emph{Property})\\
  Die zu verändernden Attribute des Elements.
\end{itemize}
Die \knks werden in einer eigenen Komponentendefinition beschrieben. Grund dafür
ist, dass neben den vordefinierten Funktionalitäten der \knks auch weitere
optionale Wertzuweisungen möglich sein sollen. Dazu wird nach der Implementierung
der Komponente für jedes Framework ein neues Schlüsselwort für eine
Komponentendefinition in die Grammatik eingebaut. Jede komplexe Komponente
benötigt darüber hinaus eine Bezeichnung um referenziert zu werden. In dieser
Iteration ist eine \gloss{Multiselection-Komponente} umgesetzt. Diese Komponente
ist generisch implementiert. Der generische Typ muss innerhalb der
Komponenten in der GUI-Beschreibung definiert werden. Ebenso müssen die
Werte, die in dieser Komponente selektiert werden können, angegeben werden.
Zusätzlich sollen optional auch die Werte angegeben werden, die bereits
selektiert wurden.


\subsection*{Semantisches Modell}
Das Artefakt, welches beim diesem Modell im Mittelpunkt steht ist die
\emph{UIDescription} (siehe Abbildung \ref{Abb_Teil1-1}). Die Methoden werden
zum Erhalt der Übersichtlichkeit nur in den Interfaces abgebildet. In den Klassen sind
lediglich die globalen Variablen dargestellt. Die aggregierten Artefakte auf
die schon im vorherigen Abschnitt verwiesen wurde, sind aus dem Diagramm gut zu
entnehmen.
\myBigFigure{v1-1.jpg}{1. Iteration: UIDescription}{Teil1-1}
\myBigFigure{v1-1-1.jpg}{Teil 2: GUI-Beschreibungsmodel Version 1}{Teil1-1}
\noindent
Die Klasse \emph{DefinitionImpl} aggregiert weitere Artefakte des Modells. Diese sind um
die Übersicht zu wahren Abbildung \ref{Abb_Teil2-1} zu entnehmen.\\
\myBigFigure{v1-2.jpg}{Teil 3:
GUI-Beschreibungsmodel Version 1}{Teil2-1} 
\myBigFigure{v1-2-1.jpg}{Teil 4:
GUI-Beschreibungsmodel Version 1}{Teil2-1} 
\noindent
Dort sind die drei umgesetzten Ausprägungen einer \emph{Definition} zu erkennen.
Dabei handelt es sich um \emph{Label}, \emph{Button} und \emph{MultiSelection}.
Weiterhin ist zu erkennen, dass nur der Button eine \emph{Interaction}
enthalten kann. Das Interface \emph{Property} wird benötigt um bestimmte Werte an
\gks zu setzen, ohne wissen zu müssen um welchen Komponententyp es
sich handelt.
Dazu wurden die allgemein gültigen Einstellungsmöglichkeiten von \Ks in
\emph{CommonProperty} zusammengefasst.

\subsection*{Konkrete Syntax}
Folgender Auszug aus einem GUI-Skript enthält sämtliche Features, die im
Prototypen der ersten Iteration umgesetzt wurden. 
\begin{lstlisting}[{caption
=1.
Iteration:
Syntax},{label = LST_Syntax1}] Area count: 4
type: WINDOW use: "AnotherDescription"
DEF Label as "HEAD" :
END DEF
DEF Button as "Interactbt": 
	text="Interagiere"
	interaction="btinteraction" type=CLICK with actions:type=UiAction element="HEAD":Text="Du hast interagiert"
END DEF
DEF MultiSelection as "Multiselect" :
	inputType="valuepackage.Values" 
	selectableValues="valuepackage.Values.asList()"
END DEF
Area:1<-"HEAD"
Area:2<-"AnotherDescription"
Area:3<-"Interactbt"
Area:4<-"Multiselect"
\end{lstlisting}
Die Bezeichnung \emph{Area} wurde bewusst so gewählt, da dieser Begriff
abstrakter ist als die in verschiedenen \acrshort{GUI}-Frameworks verwendeteten
Begriffe wie, Panel oder Pane. In der Syntax dieser DSL gilt es sich vor allem
bzgl. des Aufbaus der GUI an keinem \acrshort{GUI}-Framework zu orientieren. Die
einzelnen Komponentendefinitionen werden durch das Schlüsselwort \emph{DEF} eingeleitet
und durch das Schlüsselwort \emph{END DEF} abgeschlossen. Der Definitionskopf
wird durch das Zeichen \emph{:} beendet. Dort sind die Pflichtfelder der
Komponentendefinition zu finden (\emph{Titel} und \emph{Typ}).
Bei der Multiselection-Komponente fällt auf, dass ein Referenz-Wert verwendet
wird, der in dieser Beschreibung nicht deklariert wurde (\emph{valuespackage.Values}).
Dabei handelt es sich um einen qualifizierten Namen einer Klasse.\\
Die dazugehörige Grammatik befindet sich im Anhang
\ref{AppGrammatiken}.





\section{2. Iteration}

\subsection*{Analyse der Metadaten}
In den Metadaten der GUI-Beschreibung muss in dieser Iteration eine
Proper\-ties-Datei angegeben werden, in der bestimmte Werte für die Attribute
der \gks enthält.\\
Da die Möglichkeit bestehen soll die, in den eingebundenen GUI-Skripte
definierten, Komponenten in dieser Iteration zu verändert, wird eine weitere
Ergänzung für die GUI-Beschreibung benötigt. Diese Veränderungen sollen
sich sowohl semantisch als auch syntaktisch von der Komponentendefinition
abgrenzen (siehe semantisches Modell \emph{Refinement}). Um die eindeutige
Referenzierung zu ermöglichen muss bei der Bezeichnung der eingebundenen GUI-Skripte sowie
bei der veränderten Komponente der qualifizierte Name angegeben werden.\\
Bei den Interaktionen der \Ks fällt die Aktion komplett weg. Somit muss nur noch
der Interaktionstyp angegeben werden.\\
In den Definitionen der \Ks muss aufgrund des Properties-Konzeptes die
Möglichkeit bestehen, einen Property-Schlüssel anzugeben. Alle anderen Metadaten
für die \Ks bleiben bestehen.\\
Bezogen auf die \knks ist es lediglich notwendig
den Input-Typ anzugeben. Die Festlegung über selektierbare und
selektierte Elemente in der Multiselection-Komponente wird nicht benötigt. Das
ermöglicht, die \knks mittels \emph{use} (siehe semantisches Modell
\emph{UsedDefinitions}) in die GUI-Beschreibung einzubinden (siehe konkrete
Syntax).


\subsection*{Semantisches Modell}
In dieser Iteration wurden an den Artefakten \emph{AreaCount},
\emph{TypeDefinition} und \emph{AreaAssignment} keine Änderungen vorgenommen.
Artefakte wie \emph{Property} und \emph{Refinement} sind hinzugekommen. Die
weiteren Artefakte, die von \emph{UIDescriptionImpl} aggregiert werden
(siehe Abbildung \ref{Abb_Teil2-1}), wurden verändert.
\myBigFigure{v2-1.jpg}{Teil 1: GUI-Beschreibungsmodell Version 2}{Teil1-2}
\noindent
Das Artefakt \emph{Property} bildet die Property-Datei ab. Sie ist nicht zu
verwechseln mit dem Artefakt \emph{Properties}, welches die Eigenschaften von
Komponenten abbildet. Abbildung \ref{Abb_Teil2-2} zeigt beide Artefakte auf.
\myBigFigure{v2-2}{Teil 2: GUI-Beschreibungsmodell Version 2}{Teil2-2}
\noindent
Die \emph{UsedDescription} enthält in dieser Version einen
\emph{DefinitionType}.
Dieser bestimmt, ob es sich bei der importierten Komponente um ein
eingebundenes GUI-Skript handelt, oder um eine komplexe Komponente, für die ein
Input-Typ (\emph{inputType}) festgelegt werden kann.
\myBigFigure{v2-3}{Teil 3: GUI-Beschreibungsmodell Version 2}{Teil3-2}
\noindent
Weiterhin wird eine Unterscheidung zwischen \emph{Definition} und
\emph{Refinement} vorgenommen.
Die \emph{Definition} bildet neu definierte Komponenten für das GUI ab. Ein
\emph{Refinement} hingegen beschreibt die veränderten Komponenten importierter
GUI-Skripte (siehe Abbildung \ref{Abb_Teil4-2} und Abbildung
\ref{Abb_Teil5-2}).
\myBigFigure{v2-4}{Teil 4: GUI-Beschreibungsmodell Version 2}{Teil4-2}
\myBigFigure{v2-5}{Teil 5: GUI-Beschreibungsmodell Version 2}{Teil5-2}



\subsection*{Konkrete Syntax}
Eine Veränderungen der Syntax in der zweiten Iteration ist ein neues
Schlüsselwort zur Festlegung der Properties-Dateien. Um eine
Properties-Datei einzubinden muss, wie in Listing \ref{LST_Properties2}, eine entsprechende
Datei angegeben werden und in den Komponentendefinitionen entsprechende
Schlüssel deklariert werden. Das Label mit der Bezeichnung \emph{OneLabel}
enthält keinen Property-Key.
In diesem Fall wird der Titel als solcher verwendet.
\begin{lstlisting}[{caption = 2. Iteration: Properties},{label =
LST_Properties2}] 
type: WINDOW 
get properties from: 'sources.ui.properties' 
DEF Label as "OneLabel" END DEF
DEF Label as "AnotherLabel":
	propertyKey='AnotherLabel2'
END DEF
\end{lstlisting}
Aufgrund der Reduzierung der Menge der Metadaten für eine Interaktion stand die
Frage offen, ob die Interaktionstypen einfach hintereinander mit Komma, oder untereinander mit dem
entsprechenden Schlüsselwort aufgezählt werden sollen. Aufgrund der
Anforderung \hyperref[AS4]{AS4}, wird die erste Variante bevorzugt (siehe
Listing \ref{LST_Interaktion2}).
\begin{lstlisting}[{caption=2.
Iteration: Interaktion},{label=LST_Interaktion2}] DEF Button as
"InteractButton":
	interactiontype=Click,ChangeText
END DEF
\end{lstlisting}
Die komplexen Komponenten werden wie in Listing \ref{LST_Komplexe2} mit
der Komponente Multiselection gezeigt ist, über das Schlüsselwort \emph{use}
eingebunden werden.
Der Input-Typ kann dabei optional innerhalb der Zeichen \emph{<} und \emph{>}
angegeben werden.
\begin{lstlisting}[{caption=2. Iteration: Definition komplexer
Komponenten},{label=LST_Komplexe2}] 
type: WINDOW 
use: Multiselection<'valuepackage.Values'> as: 'Multi'
\end{lstlisting}
Für die Zuweisung mehrerer Komponenten zu den Areas kamen zwei Lösungen in
Betracht. Bei der einen finden die Definitionen der Komponenten zusammen mit der
Zuweisung zu dem Area statt. Dies könnte bspw. wie in Listing \ref{LST_Moeglichkeit1_2}
dargestellt werden.
\begin{lstlisting}[{caption=2. Iteration: Button und Label
(1)},{label=LST_Moeglichkeit1_2}] 
Area count: 1 type: WINDOW 
Area:1={
DEF Button as "Button:
	text="Button"
END DEF
DEF Label as "Label":
	text="Label"
END DEF
}
\end{lstlisting}
Eine andere Möglichkeit wäre es, die aktuelle Form der Zuweisung zu verfeinern
und somit die Komponenten bei der Zuweisung mit Komma getrennt von einander
aufzählen. Die erste Möglichkeit würde sich sehr gut eignen, wenn nur die in der
Datei definierten Komponenten dem Area zugewiesen werden müssten. Da die mit
\emph{use} eingebundenen Komponenten auch Areas zugeordnet werden, würde für
dieses Verfahren ein zusätzliches syntaktisches Konzept innerhalb der Area-Zuweisung
benötigt werden. Um dies zu umgehen wurde die Entscheidung getroffen, das alte
Verfahren zu verfeinern. Listing \ref{LST_Moeglichkeit2_2} ist ein Beispiel für die
Area-Zuweisung von drei Komponenten zu entnehmen.
\begin{lstlisting}[{caption=2. Iteration: Area-Zuweisung
(2)},{label=LST_Moeglichkeit2_2}]
Area count: 1
type: WINDOW 
DEF Label as "OneLabel" END DEF
DEF Label as "AnotherLabel" END DEF
DEF Button as "InteractButton": 
	interactiontype=Click,ChangeText
END DEF
Area:1<-"OneLabel","InteractButton","AnotherLabel"

\end{lstlisting}
Das Überschreiben der Werte von Komponenten, die in einem eingebundenen
GUI-Skript definiert wurden, können über das Schlüsselwort \emph{REFINE}
getätigt werden. Der erste Teil von Listing \ref{LST_Override2} zeigt die Originaldatei,
deren Beschreibung eingebunden wird. Diese trägt den Namen \emph{LabelAndButton}
und befindet sich im Package \emph{guidescription}. Der zweite Teil zeigt, wie
die Aufschrift einer Komponente \emph{Button} überschrieben wird.
\begin{lstlisting}[{caption=2. Iteration: Verändern von Komponenten
eingebundener GUI-Beschreibungen},{label=LST_Override2}] 
PART 1 Area count: 2
type: INNERCOMPLEX
DEF Label as "Label" :
	text="Text" 
END DEF
DEF Button as "Button":
	text="AlterText" 
END DEF
Area:1<-'Label'	
Area:2<-"Button"


PART 2
Area count: 1
type: WINDOW 
use: "guidescription.LabelAndButton" as: 'Embedded'
REFINE Button with name: 'Button':
	text='NewText'
END REFINE
Area:1<-'Embedded'
\end{lstlisting}
Sollten mehrere GUI-Skripte eingebunden sein, in denen
Komponenten mit demselben Namen definiert sind, muss die Bezeichnung der eingebundenen Ressource
zur eindeutigen Identifikation in der Referenz stehen (siehe Listing
\ref{LST_Override2_2}).
\begin{lstlisting}[{caption=2. Iteration - Verändern von Komponenten
eingebundener GUI-Beschreibungen mit
Namensüberschneidung},{label=LST_Override2_2}] 
use: "guidescription.LabelAndButton" as: 'Embedded1' 
use: "guidescription.LabelAndTwoButton" as: 'Embedded2' 
REFINE Button with name: 'Embedded2.OverriddenButton':
	text='NewText'
END REFINE
\end{lstlisting}
\noindent
Die dazugehörige Grammatik, welche in der zweiten Iteration entwickelt wurde,
ist im Anhang \ref{AppGrammatiken} zu finden.



\section{3. Iteration}
\subsection*{Analyse der Metadaten}
Um eine Referenzierung von \gks und dem entsprechenden Layout aus der
Layout-Datei zu ermöglichen, ist es wie bei den Properties-Dateien notwendig,
die Layout-Datei innerhalb des GUI-Skripts anzugeben. Weiterhin wird in den
einzelnen Komponentendefinitionen ein Schlüssel benötigt, über den die
Komponente eindeutig referenziert werden kann. Dafür kann die Bezeichnung der
\gk verwendet werden. Um in der Layout-Datei nicht alle einzelnen
\gks unterscheiden zu müssen, wird innerhalb der GUI-Beschreibung
ein optionales Feld benötigt, mittels dessen unterschiedlichen \gks
derselbe Layout-Schlüssel zugeordnet werden kann. \\
Da die Anzahl der Bereiche nicht mehr angegeben werden muss, fällt dies aus den
Metadaten heraus. Die Zuweisung der \gks zu den Bereichen entfällt ebenfalls.
Die Strukturierung wird über eine Aufzählung der \gks vorgenommen.\\
Zusammenfassend werden folgende Metadaten für die
Beschreibung einer GUI mit der GUI-DSL benötigt.
\begin{itemize}
  \item  Typ
  \item  Properties-Dateien
  \item  Layout-Dateien
  \item  Eingebundene \gks
  \item  Veränderte eingebundene Komponentendefinitionen
  \item  Komponentendefinitionen 
  \item  Struktur
\end{itemize}
\noindent
Alle Komponentendefinitionen und die Veränderten eingebundenen
Komponentendefinitionen benötigen durch die genannten Änderung folgende
Metadaten.
\begin{itemize}
  \item  Bezeichnung
  \item  Property-Schlüssel (optional)
  \item  Layout-Schlüssel (optional)
  \item  Interaktionen (optional)
\end{itemize}
\noindent
Über die konkreten Kompnentendefinitionen müssen mehrere \Ks beschrieben
werden können. \Ks die spezielle Metadaten benötigen sind mit diesen in
folgender Tabelle aufgelistet.
\begin{table}[H]
\centering
\small
\begin{tabular}[c]{|l|l|}
			\hline
			\hline
				\textbf{Basiskomponente} & \textbf{Spezifische Metadaten}\\
				\hline\hline
				Label & 
  		  				Aufschrift
				 \\
				\hline
				Button & 
  		  Aufschrift
  		  \\
				\hline
				Textfield &  
  		  Text, Editierbarkeit
  		  \\
				\hline
				Textarea  &  
  		  Text, Editierbarkeit
  		   \\
				\hline
				Tree &  
  		  Input-Modell
  		  \\
				\hline
				Table &  
  		  Input-Modell
  		  \\
				\hline
				TabView &  
  		  GUI-Beschreibungen für die einzelnen Tabe
  		  \\
				\hline
				\hline
			\end{tabular} 
 \caption{Basiskomponenten mit spezifischen Metadaten}
 \label{tab_comp}
\end{table}
\noindent
Mit Ausnahme der Metadaten des TabViews sind alle Angaben zu anderen
Basiskomponenten optional.

\subsection*{Semantisches Modell} 
Das semantische Modell hat sich durch die vielen Änderungen in dieser Iteration
ebenso stark verändert. Bei der Betrachtung der \emph{UIDescription} (siehe
Abbildung \ref{Abb_I3_1}) fällt auf, dass \emph{Area} und \emph{AreaCount} nicht mehr
vorhanden sind. Hinzugekommen sind \emph{Structure} (worin die Anordnung der
\gks (\emph{Element}) in einer Liste abgelegt wird) und Layout
(worin die zu verwendeten Layout-Dateien in einer Liste abgelegt werden).\\
Eine weitere Änderungen ist bei \emph{Property} zu finden. Dort ist ebenfalls
eine Liste vorhanden und kein allein stehender Wert.
\myBigFigure{v3-1.jpg}{3. Iteration: UIDescription}{I3_1}
\noindent
An \emph{TypeDefinition} und \emph{UsedDescription} wurden keine signifikanten
Änderungen vorgenommen. Die meisten Änderungen wurden bei den Artefakten
\emph{Refinement} und \emph{Definition} vorgenommen. Der Aufbau der dieser
Artefakte ist ähnlich. Das Interface (\emph{Refinement} und \emph{Definition})
wird von einer Klasse implementiert (\emph{RefinementImpl} und
\emph{DefinitionImpl}), die mehrere Objekte bestimmter Klassen,
die das Interface \emph{ComponentRefinement} oder \emph{ComponentDefinition}
implementieren, enthält. In Abbildung \ref{Abb_I3_2} ist diese Struktur für die
\emph{Definition} abgebildet.
\myBigFigure{v3-2}{3. Iteration: Definition}{I3_2}
\noindent
Die benannten Klassen bilden die unterschiedlichen \Ks ab, die
definiert oder verändert werden können. Jede dieser Klassen aggregiert ein
Objekt des Typen \emph{CommonProperties} ein. Dieses Interface bildet die
allgemeinen Properties ab. Bei den \Ks Label, Button, Textfield und Textarea ist
diese Aggregation transitiv, da die speziellen Properties dieser \Ks als eigenes
Artefakt implementiert sind. Abbildung \ref{Abb_I3_3} zeigt dies für einen
Button auf.
\myBigFigure{v3-3.jpg}{3. Iteration: Button}{I3_3}
\noindent
Eine direkte Aggregation der \emph{CommonProperties} findet bei den \Ks TabView,
Table und Tree statt. Für die speziellen Properties dieser \Ks existieren keine
einzelnen Klassen. Die folgenden Abbildungen (\ref{Abb_I3_4}, \ref{Abb_I3_5} und
\ref{Abb_I3_6}) zeigen diese drei \Ks (\emph{Refinement} und \emph{Definition})
mit der Aggregation der \emph{CommonProperties}.
\myBigFigure{v3-4.jpg}{3. Iteration: TabView}{I3_4}
\noindent
Die \K TabView benötigt eine Menge von \emph{TabDefinition}s. Diese Klasse
bildet die Referenz zu den in die TabView einzubindenden \gks.
Die \Ks Tree und Table benötigen lediglich eine Referenz auf den Input-Typen,
den sie abbilden sollen, in Form einer Zeichenkette (siehe Abbildung
\ref{Abb_I3_5} und \ref{Abb_I3_6}).
\myBigFigure{v3-5.jpg}{3. Iteration: TabView}{I3_5}
\myBigFigure{v3-6.jpg}{3. Iteration: TabView}{I3_6}
\subsection*{Konkrete Syntax} Die syntaktischen
Konstrukte wurden in dieser Iteration stark vermehrt. Das liegt vor allem daran, dass viele neue \Ks hinzugekommen sind. Der
grundsätzliche syntaktische Aufbau eines GUI-Skripts hat sich jedoch nicht
verändert. Eingeleitet wird die Beschreibung weiterhin mit der Typ-Definition,
gefolgt von der Angabe der Properties-Dateien. Sofern mehrere Properties-Dateien
vorhanden sind, werden diese mit Komma getrennt voneinander aufgezählt.\\
Dasselbe Prinzip wird bei der sich anschließenden Angabe der Layout-Datei\-en
verwendet.
Das Semikolon gilt ab sofort als Trennzeichen für einen abgeschlossen
definierten Komplex (siehe Listing \ref{LST_PropertiesLayout3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Properties- und Layout-Dateien},{label = LST_PropertiesLayout3}] 
type: INNERCOMPLEX;
get properties from:'properties1', 'properties2';
get layout from:'layout1','layout2';
\end{lstlisting}
Für die eingebundenen \gks wurden keine
großen syntaktischen Veränderungen vorgenommen. Lediglich das Semikolon wird für
den Abschluss des Komplexes benötigt (siehe Listing \ref{LST_Use3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Eingebundene \gks},{label = LST_Use3}] 
use: Multiselection<Input> as: "multi";
\end{lstlisting}
Die Definitionen der einzelnen \Ks hat sich syntaktisch stark verändert. Grund
dafür ist vor allem, dass die Anforderungen \hyperref[AA5]{AA5} und
\hyperref[AS4]{AS4} mehr Beachtung
finden sollen. Somit werden die bekannten \Ks wie folgt definiert (siehe Listing
\ref{LST_Bt+Lb3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Button und Label},{label = LST_Bt+Lb3}] 
Button as: "Button" -> propertyKey='buttonproperty' layoutKey='buttonlayout'
interactiontype=IfViewImage text='buttontext';

Label as: 'Label' -> propertyKey='labelproperty' layoutKey='labellayout'
interactiontype=IfActivator text='labeltext';
\end{lstlisting}
Bei den Definitionen der anderen \Ks werden die allgemeinen Properties wie im
vorherigen Beispiel zugewiesen. In den Fällen der \Ks Textflied und Textarea
werden die speziellen Properties nach demselben Prinzip definiert (siehe Listing
\ref{LST_Tf+Ta3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Textfield und Textarea},{label = LST_Tf+Ta3}] 
Textfield as: 'Textfield' -> propertyKey='textfieldproperty'
layoutKey='textfieldlayout' interactiontype=IfActivator 
text='textfieldtext' editable=TRUE;

Textarea as: 'Textarea' -> propertyKey='textareaproperty'
layoutKey='textarealayout' interactiontype=IfActivator 
text='textareatext' editable=TRUE;
\end{lstlisting}
Die Syntax für die Definition der \Ks Table und Tree sind ähnlich. Der
benötigte Input-Typ wird nach dem Schlüsselwort angegeben, welches die
\gk bestimmt (siehe Listing \ref{LST_T+T3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Table und Tree},{label = LST_T+T3}] 
Table<tablemodel> as: 'Table' -> propertyKey='tableproperty'
layoutKey='tablelayout' interactiontype=IfActivator;

Tree<treemodel> as: 'Tree' -> propertyKey='treeproperty'
layoutKey='treelayout' interactiontype=IfActivator;
\end{lstlisting}
Die \Ks TabView werden die verwendeten GUI-Komponen\-ten der einzelnen Tabs
ebenfalls nach dem Schlüsselwort angegeben, welches die \gk
festlegt.
Hierbei können anderes als bei den \Ks Table und Tree mehrere Angaben getätigt
werden (siehe Listing \ref{LST_Tab3}).\\
In den folgenden Beispielen wird davon
ausgegangen, dass die vorher genannten Beispiele für die \Ks Tree, Table und
Textarea in demselben GUI-Skript definiert wurden. Durch das syntaktische
Konstrukt in Listing \ref{LST_Tab3} wird eine Tab-Ansicht mit drei Taben beschrieben. Das
erste Tab enthält den Tree, das zweite die Table und das dritte die Textarea.
\begin{lstlisting}[{caption = 3.
Iteration:
TabView},{label = LST_Tab3}] 
TabView[Tree][Table][Textarea] as: 'tabview' -> propertyKey='tabviewproperty'
layoutKey='tabviewlayout' interactiontype=IfViewImage;
\end{lstlisting}
Dabei ist zu erwähnen, dass die Angabe der Properties in den meisten
Fällen optional ist. Lediglich die speziellen Properties der \Ks Table, Tree und
TabView müssen zwingend angegeben werden.\\
Die Syntax zur Veränderung einer \K eines eingebundenen GUI-Skripts ähnelt
der Definition einer \K des gleichen Typs. Es muss lediglich angegeben werden,
welche \gks in welcher GUI-Beschreibung verändert werden soll.\\
Folgendes Beispiel zeigt, wie die Aufschrift eines Buttons eines eingebundenen
GUI-Skripts verändert wird (siehe Listing \ref{LST_Refine3}). Der Button
trägt die Bezeichnung \emph{EmbeddedButton}. Das
GUI-Skript liegt im Package
\emph{guidescription} und trägt die Bezeichnung
\emph{Embedded}.
\begin{lstlisting}[{caption = 3.
Iteration:
TabView},{label = LST_Refine3}] 
use: "guidescription.Embedded" as: "embedded";
Button change:'embedded.EmbeddedButton' -> text='Neuer Text';
\end{lstlisting}
\noindent
Der letzte Teil einer GUI-Beschreibung beinhaltet die Angabe der Struktur. Diese
Angabe ähnelt der Zuweisung von \gks zu Bereichen, wie es auch der
ersten und zweiten Iteration bekannt ist. Da dieses Konstrukt vereinfacht werden
sollte, werden die \gks in der richtigen Reihenfolgen nach dem
Schlüsselwort \emph{Structur} aufgezählt (siehe Listing \ref{LST_Structure3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Struktur},{label = LST_Structure3}] 
Structure:'Button','Label','Textfield','tabview';
\end{lstlisting}
\noindent
Die damit für diese Arbeit endgültige Grammatik ist, wie die Grammatiken der
anderen Iterationen, im Anhang \ref{AppGrammatiken} zu finden.
