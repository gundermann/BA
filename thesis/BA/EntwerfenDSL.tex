\chapter{Entwicklung einer DSL zur Beschreibung der GUI in profil c/s}\label{Entwicklung einer DSL zur Beschreibung der GUI in profil c/s}
\section{1. Iteration}
\subsection*{Analyse der Metadaten der GUI}
\subsection*{Semantisches Modell}
\myBigFigure{v1-1.jpg}{Teil 1: GUI-Beschreibungs-Model Version 1}{Teil1-1}
Das Artefakt, welches beim dieserm Model im Mittelpunkt steht ist die
\emph{UIDescription} (siehe \ref{Abb_Teil1-1}). Die aggregierten Artefakte sind
aus dem Diagrammm gut zu entnehmen. Die Klasse
\emph{DefinitionImpl} aggregiert weitere Artefakte des Modells. Diese sind um
die Übersicht zu wahren Abbildung \ref{Abb_Teil2-1} zu entnehmen.\\
\myBigFigure{v1-2.jpg}{Teil 2:
GUI-Beschreibungs-Model Version 1}{Teil2-1} 
Dort sind die drei umgesetzten Ausprägungen einer \emph{Definition} zu erkennen.
Dabei handelt es sich um \emph{Label}, \emph{Button} und \emph{MultiSelection}.
Weiterhin ist zu erkennen, dass nur der Button eine \emph{Interaction}
aggregieren kann. Das bedeutet, dass nur an dieser Komponente eine Interaktion
beschrieben werden kann. Der letzte interessante Teil wäre wohl die
\emph{Property}. Dieses Interface wird benötigt um bestimmte Werte an
Komponenten zu setze, ohne das Wissen zu müssen um welchen Komponententyp es
sich handelt.
Dazu wurden die allgemein gültigen Einstellungsmöglichkeiten von trivialen
Komponenten in \emph{CommonProperty} zusammengefasst. Die Klasse
\emph{PropertyImpl} ist ein Artefakt, welches zur Vollständigkeit des
Modells erzeugt wurde. Es erfüllt für diese Version jedoch keinen weiteren
Zweck.
\subsection*{Grammatik}


\section{Analyse der Metadaten der GUI}
\subsection*{Version 1}
Überlegungen bzgl. des Aufbaus der UIs gingen dahin, dass sich die DSL an dem
Komponentenmodel von RCP4 orientieren soll. Das bedeutet, dass es Meta-Ebene
gibt, die den groben Aufbau der GUI beschreibt und eine Implementierungs-Ebene,
welche spezifische Komponenten innerhalb der GUI umsetzen soll. 

Beim Aufbau
der GUI wurde zwischen zwei Typen unterschieden (siehe semantisches
Model \emph{TypeDefinition}). Für die Beschreibung des Aufbaus enthält jede
beschriebene GUI eine bestimmte Anzahl von Bereichen (\emph{Area}), denen genau
eine andere UI-Komponent zugeordnet werden kann (siehe semantisches Model
\emph{AreaCount} und \emph{AreaAssingment}).
Weiterhin können von einer GUI-Beschreibung andere GUI-Beschreibungen verwendet
werden (siehe semantisches Model Use). Die verwendeten GUI-Beschreibungen können
jedoch nicht erweitert werden. Den Kern der GUI-Beschreibung jedoch die
Kompnentendefinition (siehe semantisches Model \emph{Definition}). Dort werden
einzelne Komponeten der GUI durch die Meta-Daten beschrieben.\\
Bezogen auf die tivialen Komponenten des UIs die
Beschreibung eines Textes wichtig. Im Falle eines Buttons oder eines Labels
(andere triviale Komponenten sind in dieser Version nicht umgesetzt) beschreibt
dieser die Aufschrift der Komponente.
Weiterhin war es für die Zuweisung zu den entsprechenden Bereich wichtig, dass diese Komponenten
innerhalb der Datei referenziert werden können. Das wurde durch den Titel
umgesetzt, der für jede Komponente definiert werden muss. An den trivialen
Komponenten können daruber hinaus Interaktionen beschrieben werden. Hierzu
ist ein Interaktionstyp nötig. Eine einfacher Klick auf die Komponente ist
der einzige Interaktionstyp in dieser Version. An dieser Interaktion können
ebenso Aktionen definiert werden, die Auswirkungen auf andere Komponenten haben.
Zusammenfassend ergeben sich folgende Meta-Daten der trivialen
Komponenten.
\begin{itemize}
  \item Typ
  \item Titel
  \item Text
  \item Interaktion
\end{itemize}
Die Interaktion benötigt folgende Attributen, die beschrieben werden müssen.
\begin{itemize}
  \item Titel
  \item Interaktionstyp
  \item Aktion
\end{itemize}
Die Aktion benötigt einen \emph{ActionType}, das \emph{Element} auf das sich
die Interaktion auswirken soll und die Veränderung der Attribute des
entsprechenden Elements (\emph{Properties}.\\
Die komplexen Komponenten müssen für jedes verwendete UI-Framework
implementiert werden. Das hat zur Folge, dass die Implementierung dieser
Komponenten nicht so stark abstrahiert wird, dass sie nur einmal
entwickelt werden müssen. Damit wird jedoch auch verhindert, dass die
Entwickler, die bzgl. der GUI nur mit der DSL arbeiten, eigene komplexe
Komponenten entwerfen, deren Wiederverwendungsgrad nierdirger ist, als wenn
diese Komponenten nach ausreichender Evaluation an einer zentralen Stelle
implementiert und bereitgestellt werden. Ein Nachteil dieses konzeptes ist es,
dass gewährleistet sein muss, das die Quellen für diese komplexen Komponenten
sowohl zur Entwicklungszeit, als auch zur Laufzeit vorhanden sind.\\
Da für die komplexe Komponenten eine Klasse im Classpath vorliegen muss, könnten
diese Komponenten in eine GUI-Beschreibung wie andere verwendete
GUI-Beschreibungen über \emph{use} eingebundern werden. An komplexen
Komponenten sollen jedoch weitere optionale Wertzuweisungen möglich
sein. Deshalb werden komplexe Komponenten wie die trivialen Komponenten
in einer Komponentendefinition beschrieben. Dazu wird nach der Implementierung
der Komponente für jedes Framework ein neues Schlüsselwort für eine
Komponentendefinition eingebaut. Jede komplexe Komponente benötigt wiederum
einen Titel um referenziert zu werden. In dieser Version ist eine
\gloss{Multiselection-Komponente} umgesetzt. Diese Komponente ist generisch
implementiert. Der generische Typ kann in der DSL an dem Schlüsselwort
\emph{InputType} beschrieben werden. Die Werte, die in dieser Komponente
selektiert werden können, werden über das Schlüsselwort \emph{selectableValues}
gesetzt und die Werte, die selektiert sind am Schlüsselwort \emph{selectedValues}.

\subsection*{Version 2}
Beschreibung von Aktionen bei Interaktionen weg.\\
Bezogen auf die komplexen Komponenten hat sich ergeben, dass lediglich nur
den Input-Typ angegeben werden muss. Die Festlegung über selektierbare und
selektierte Elemente ist ebenso wie die Aktion einer Interaktion teilweise zu
komplex und schwer abstrahierbar. Das ermöglicht, die komplexen Elemente mittels
\emph{use} (siehe semantisches Model \emph{UsedDefinitions}) in die
GUI-Beschreibung einzubinden (siehe konkrete Syntax). Da für komplexe
Komponenten immer noch der Input-Typ angegeben werden kann, werden komplexen
internen Komponenten und anderen komplexen externen Komponenten zwischen zwei
Artefakten unterschieden (siehe semantisches Model \emph{UsedDescription})\\
Bezüglich der Komponenten, die mittels \emph{use} eingebunden werden, ist es
für die Lokalisierung der entsprechenden Quellen besser, wenn in der
GUI-Beschreibung der qualifizierte Name angegeben wird. Dadruch wird die
Besschreibung zwar länger, im Gegenzug dazu jedoch auch eindeutig.\\
Die in diesen eingebundenen GUI-Beschreibungen definierten Komponenten können in
dieser Version weiter verfeinert werden. Dabei überschreiben die Werte, die in
der bearbeiteten Beschreibung definiert wurden, die Werte die in der
Originaldatei definiert sind. Werte die nicht überschrieben werden, werden aus
der Originaldatei übernommen.\\
Eine weitere Diskussion regte die Art und Weise
der Zuweisungen von Komponenten zu einem Area an. Bei der Lösung aus Version 1
ist es nicht möglich mehrere Komponenten einem Area zuzuweisen. Für die
Meta-Daten einer Areazuweisung (siehe semantisches Model \emph{AreaAssignment})
bedeutet dies, dass diese nicht nur mit einer Komponenten umgehen können muss,
sondern mit einer Vielzahl von Komponenten.\\
Ein weiterer wichtiger Punkt, welcher in der ersten Version keine Beachtung
fand, ist die Art und Weise, wie an den Komponenten bestimmte Werte wie bspw.
die Aufschrift gesetzt werden. In der deg werden dazu so genannte
\emph{Properties}-Dateien verwendet, die mittels eines Frameworks ausgelesen
werden und über einen Schlüssel den Komponenten zugewiesen werden. Damit wird
die eigentliche Klasse zur Beschreibung der GUI in der deg entlastet. Auch die
GUI-Beschreibung mittels DSL kann damit entlastet werden.
Dazu wird jedoch ein Konzept benötigt, wie diese Properties-Dateien in
die GUI-Beschreibung eingebunden und verwendet werden. Hierzu müssen die
Meta-Daten für die GUI angepasst werden. Neben der Anzahl an Areas sowie der
Zuweisung von Komponenten zu diesen und den Einbindung anderer Komponenten, wird
die benutzte Properties-Datei mit angegeben. Der benötigte Schlüssel für die
Wertzuweisung wird innerhalb der Komponenten angegeben. Sind in einer
Properties-Datei mehrere Werte für unterschiedliche Attribute einer Komponente
angegeben, werden sie entsprechend zugeordnet, sodass in der GUI-Beschreibung
nur der Schlüssel angegeben werden muss. Das hat den Vorteil, dass die
GUI-Beschreibung dadurch weitaus verkürzt wird, und dass bei Fehlern bzgl. der
Werten, die den Attributen der Komponenten zugewiesen wurden, nur die
Properties-Datei verändert werden muss und nicht die GUI-Beschreibung. Das
Verändern der GUI-Beschreibung würde dazu führen, dass die Klassen neu generiert
werden müssten. Abgesehen von den Properties-Dateien besteht in der
eigentlichen GUI-Beschreibung weiterhin die Möglichkeit, Werte festzulegen. Bei
der Generation müssen die in der GUI-Beschreibung festgelegten Werte vorrangig
behandelt werden. Grund dafür ist, dass im Vorfeld geprüft werden kann, ob die
Werte in der GUI-Beschreibung definiert sind. Somit muss die Properties-Datei
nicht zwingend nach dem richtigen Schlüssel durchsucht werden.

\subsection*{Version 3}


\section{Semantisches Modell}

\subsection*{Version 1}



\subsection*{Version 2}
In dieser Version wurden an den Artefakten \emph{AreaCount},
\emph{TypeDefinition} und \emph{AreaAssignment} keine Änderungen vorgenommen.
Artefakte wie \emph{Property} und \emph{Refinement} sind hinzugekommen. Die
weiteren Artefakte, die von \emph{UIDescriptionImpl} aggregiert werden
(siehe Abbildung \ref{Abb_Teil2-1}), wurden verändert.
\myBigFigure{v2-1.jpg}{Teil 1: GUI-Beschreibungs-Model Version 2}{Teil1-2}
Das Artefakt \emph{Property} bildet die Property-Datei ab. Sie ist nicht zu
verwechseln mit dem Artefakt \emph{Properties}, welches die Eigenschaften von
Komponenten abbildet. Abbildung \ref{Abb_Teil2-2} zeigt beide Artefakte auf.
\myBigFigure{v2-2}{Teil 2: GUI-Beschreibungs-Model Version 2}{Teil2-2}
Die \emph{UsedDescription} enthält in dieser Version ein \emph{DefinitionType}.
Dieser bestimmt, ob es sich bei der importierten Komponente um ein beschriebenes
GUI handelt, oder um eine komplexe Komponente, für die ein Input-Typ
(\emph{inputType}) festgelegt werden kann.
\myBigFigure{v2-3}{Teil 3: GUI-Beschreibungs-Model Version 2}{Teil3-2}
Zwischen \emph{Definition} und \emph{Refinement} wird unterschieden. Die
\emph{Definition} bildet neu definierte Komponenten für das GUI ab. Ein
\emph{Refinement} hingegen bildet die Veränderten Komponenten importierter
Komponenten ab (siehe Abbildung \ref{Abb_Teil4-2} und Abbildung \ref{Abb_Teil5-2}).
\myBigFigure{v2-4}{Teil 4: GUI-Beschreibungs-Model Version 2}{Teil4-2}
\myBigFigure{v2-5}{Teil 5: GUI-Beschreibungs-Model Version 2}{Teil5-2}

\subsubsection*{Version 3}

\section{Konkrete Syntax}
Die Syntax wird durch Beispiele beschreiben. Zu jeder Version ist ein minimaler
DSL-Code zu finden. Besondere Änderungen bzgl. der konkreten Syntax sind jeweils
nachfolgend genannt. Die Grammatiken befinden sich im Anhang
\ref{AppGrammatiken}. Sie sind dort ebenfalls in Versionen aufgeteilt.
 \subsection*{Version 1}
\begin{lstlisting}[caption = Syntax Version 1][label = LST_Syntax1]
Area count: 4
type: WINDOW use: "AnotherDescription"
DEF Label as "HEAD" :
END DEF
DEF Button as "Interactbt": 
	text="Interagiere"
	interaction="btinteraction" type=CLICK with actions:type=UiAction element="HEAD":Text="Du hast interagiert"
END DEF
DEF MultiSelection as "Multiselect" :
	inputType="valuepackage.Values" 
	selectableValues="valuepackage.Values.asList()"
END DEF
Area:1<-"HEAD"
Area:2<-"AnotherDescription"
Area:3<-"Interactbt"
Area:4<-"Multiselect"
\end{lstlisting}
Die Bezeichnung \emph{Area} wurde bewusst so gewählt, da dieser Begriff
abstrakter ist als die in verschiedenen UI-Frameworks verwendeteten Begrifft
wie, Panel oder Pane. In der Syntax dieser DSL gilt es sich vor allem bzgl. des
Aufbaus der GUI an keinem UI-Framework zu orientieren. Die einzelnen
Komponentendefinitionen werden durch das Schlüsselwort \emph{DEF} eingeleitet und durch das Schlüsselwort \emph{END DEF} abgeschlossen. Der Definitionskoft wird durch das Zeichen \emph{:} beendet. Dort sind die Pflichtfelder der Komponentendefinition zu finden (\emph{Titel} und
\emph{Typ}).
Bei der Multiselection-Komponente fällt auf, dass ein Referenzwert verwendet
wird, der in dieser Beschreibung nicht deklariert wurde (\emph{valuespackage.Values}).
Dabei handelt es sich um einen qualifizierten Namen einer Klasse.

\subsection*{Version 2}
Die einfachste der Veränderungen bzgl. der Syntax in Version 2 ist die
festlegung der Properties-Dateien. In Listing \ref{LST_Properties2} ist zu erkennen, dass eine
entsprechende Datei festgelegt wurde und in den Komponenten entsprechende
Schlüssel vergeben wurden. Das Label mit der Bezeichnung \emph{OneLabel} enthält
keinen Property-Key. In diesem Fall wird der Titel als
solcher verwendet.
\begin{lstlisting}[{caption = Properties in Version 2},{label =
LST_Properties2}] 
type: WINDOW 
get properties from: 'sources.ui.properties' 
DEF Label as "OneLabel" END DEF
DEF Label as "AnotherLabel":
	propertyKey='AnotherLabel2'
END DEF
\end{lstlisting}
Aufgrund der Reduzierung der Meta-Daten für eine Interaktion stand die Frage
offen, ob die Interaktionstypen einfach hintereinander mit Komma aufgeählt
werden sollen, oder ob sie untereinander und jedes Mal wieder mit dem
entsprechenden Schlüsselwort aufgezählt werden sollen. Aufgrund der Tatsache,
dass in der deg höchstens 4 Interaktionstypen in einer Komponente verwendet
werden, werden diese in der GUI-Beschreibung per DSL hintereinander mit Komma
aufgezählt, wie in Listing \ref{LST_Interaktion2} zu erkennen ist.
\begin{lstlisting}[{caption=Interaktion in Version 2},{label=LST_Interaktion2}]
DEF Button as "InteractButton": 
	interactiontype=Click,ChangeText
END DEF
\end{lstlisting}
Die komplexen Komponenten werden wie in Listing \ref{LST_Komplexe2} mit
der Komponente Multiselection gezeigt ist, über das Schlüsselwort \emph{use}
eingebunden werden.
Der Input-Typ kann dabei optional innerhalb der Zeichen \emph{<} und \emph{>} angegeben. 
\begin{lstlisting}[{caption=Komplexe Komponenten in Version
2},{label=LST_Komplexe2}]
type: WINDOW 
use: Multiselection<'valuepackage.Values'> as: 'Multi'
\end{lstlisting}
Für die Zuweisung mehrer Komponenten zu den Areas kamen zwei Lösungen in
Betracht. Bei der einen finden die Definitionen der Komponenten zusammen mit der
Zuweisung zu dem Area statt. Dies könnte bspw. wie in Listing \ref{} dargestellt
werden.
\begin{lstlisting}[{caption=Area-Zuweisung Möglichkeit 1 Version
2},{label=LST_Moeglichkeit1_2}]
Area count: 1
type: WINDOW 
Area:1={
DEF Button as "Button:
	text="Button"
END DEF
DEF Label as "Label":
	text="Label"
END DEF
}
\end{lstlisting}
Eine andere Möglichkeit wäre es, die aktuelle Form der Zuweisung zu verfeinern
und somit die Komponenten bei der Zuweisung mit komma getrennt von einander
aufzählen. Die erste Möglichkeit würde sich sehr gut eignen, wenn nur die in der
Datei definierten Komponenten dem Area zugewiesen werden müssten. Da die
eingebundenen Komponenten auch Areas zugewordnet werden, würde für dieses
Verfahren ein zusätzliches syntaktisches Konzept innerhalb der Area-Zuweisung
benötigt werden. Um dies zu umgehen wurde die Entscheidung getroffen, das alte
Verfahren zu verfeinern. Listing \ref{LST_Moeglichkeit2_2} ist ein Beispiel für die
Area-Zuweisung von drei Komponenten zu entnehmen.
\begin{lstlisting}[{caption=Area-Zuweisung Möglichkeit 2 Version
2},{label=LST_Moeglichkeit2_2}]
Area count: 1
type: WINDOW 
DEF Label as "OneLabel" END DEF
DEF Label as "AnotherLabel" END DEF
DEF Button as "InteractButton": 
	interactiontype=Click,ChangeText
END DEF
Area:1<-"OneLabel","InteractButton","AnotherLabel"

\end{lstlisting}
Das Überschreiben Werte der Komponenten, die in einer eingebundenen
GUI-Beschreibung definiert wurden, können über das Schlüsselwort \emph{REFINE}
getätigt werden. Der erste Teil von Listing \ref{} zeigt die Originaldatei,
deren Beschreibung eingebunden wird. Der zweite Teil zeigt, wie die
Aufschrift einer Komponente \emph{OverriddenButton} überschrieben
wird.
\begin{lstlisting}[{caption=Überschreiben einer eingebundenen Komponente Version
2},{label=LST_Override2}]
PART 1
Area count: 2
type: INNERCOMPLEX
DEF Label as "Label" :
	text="Text" 
END DEF
DEF Button as "Button":
	text="AlterText" 
END DEF
Area:1<-'Label'	
Area:2<-"Button"


PART 2
Area count: 1
type: WINDOW 
use: "guidescription.LabelAndButton" as: 'Embedded'
REFINE Button with name: 'OverriddenButton':
	text='NewText'
END REFINE
Area:1<-'Embedded'
\end{lstlisting}
Sollten mehrere Komponenten eingebunden sein, in denen Komponenten mit den
selben Namen definiert sind, muss der Titel der eingebundenen Ressource zur
eideutigen Identifikation stehen (siehe Listing \ref{LST_Override2_2})
\begin{lstlisting}[{caption=Überschreiben einer eingebundenen Komponente mit
Titel der Komponente Version 2},{label=LST_Override2_2}]
use: "guidescription.LabelAndButton" as: 'Embedded1'
use: "guidescription.LabelAndTwoButton" as: 'Embedded2'
REFINE Button with name: 'Embedded2.OverriddenButton':
	text='NewText'
END REFINE
\end{lstlisting}
