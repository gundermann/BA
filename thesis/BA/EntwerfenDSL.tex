\chapter{Entwicklung einer DSL zur Beschreibung der GUI in profil c/s}\label{Entwicklung einer DSL zur Beschreibung der GUI in profil c/s}
\section{1. Iteration}
\subsection*{Analyse der Metadaten}
Die Beschreibung einer \acrshort{GUI} wird in der \g als eigener Komplex
betrachtet (siehe semantisches Modell \emph{UIDescription}). Innerhalb dieses
Komplexes werden die entsprechenden Komponenten definiert. Die Bereiche, die
innerhalb einer Beschreibung festgelegt werden sollen, müssen \gks zugeordnet werden
können (siehe semantisches Modell \emph{AreaAssignment}). Diese Bereiche
sollten vor der Entwicklung bereits festgelegt werden. Um abzusichern, dass die
Anzahl der festgelegten Bereiche genau eingehalten wird, muss diese Anzahl in
der GUI-Beschreibung angegeben werden (siehe semantisches Modell \emph{AreaCount}).\\
Für die Beschreibung der Layout-Komponenten wird zwischen zwei Typen
unterschieden (siehe semantisches Model \emph{TypeDefinition}), um zwischen obersten
Layout-Komponenten und Anderen zu differenzieren.\\
Ein weiterer Aspekt in einem \emph{GUI-Skript}, ist die Verwendung anderer
\emph{GUI-Skripte} (siehe semantisches Modell \emph{Use}).\\ 
Zusammenfassend sind für die Beschreibung der \gui folgende Metadaten nötig:
\begin{itemize}
  \item  \textbf{Anzahl der Bereiche}
  \item  \textbf{Zuweisung der \gks zu den Bereichen}
  \item  \textbf{Angabe des Layouttyps}
  \item  \textbf{Angabe der verwendeten GUI-Beschreibungen}
  \item  \textbf{Definition von \gks}
\end{itemize}
Die Definitionen der \gks nehmen einen eigenen Komplex innerhalb der
GUI-Beschreibung ein. 
Bezogen auf die \Ks der \acrshort{GUI}, ist die
Beschreibung eines Textes wichtig. Im Falle eines \emph{Buttons} oder eines
\emph{Labels} beschreibt der Text die Aufschrift der Komponente.
Weiterhin ist es für die Zuweisung zu einem Bereich wichtig, dass
diese Komponenten innerhalb der Datei referenziert werden können. Daher muss
für jede \gk eine Bezeichnung definiert werden, die innerhalb der
Datei eindeutig ist.\\
An den \Ks können darüber hinaus Interaktionen beschrieben werden, wofür
Informationen über den Interaktionstyp von Nöten sind.
Der einzige Interaktionstyp, der in dieser Iteration umgesetzt wurde, ist ein
manuelles Betätigen der Komponente durch den Nutzer. Zudem können an dieser
Interaktion Aktionen definiert werden, wodurch andere Komponenten verändert
werden können.
Zusammenfassend ergeben sich folgende Metadaten der \Ks:
\begin{itemize}
  \item \textbf{Typ}
  \item \textbf{Bezeichnung}
  \item \textbf{Text}
  \item \textbf{Interaktion (siehe semantisches Modell \emph{Interaction})}
\end{itemize}
\noindent \\
Die Interaktion benötigt folgende Attribute, die beschrieben werden müssen:
\begin{itemize}
  \item \textbf{Bezeichnung}
  \item \textbf{Interaktionstyp}
  \item \textbf{Aktion}
\end{itemize}
\noindent \\
Aktionen nehmen wiederum einen eigenen Komplex innerhalb der
Komponentendefinition ein. Dabei werden folgende Informationen benötigt:
\begin{itemize}
  \item \textbf{Aktionstyp}\\
  Dient der Unterscheidung von Interaktionen mit anderen \gks und
  fachlichen Modellen.
  \item \textbf{Element}\\
  Ist ein Verweis auf das Objekt, mit dem interagiert werden soll.
  \item \textbf{Attribute} (siehe semantisches Modell \emph{Property})\\
  Sind zu verändernde Eigenschaften des Elements.
\end{itemize}
\noindent \\
Die \knks werden in einer eigenen Komponentendefinition beschrieben, da neben
den vordefinierten Funktionalitäten der \knks auch weitere optionale
Wertzuweisungen möglich sein sollen. Dazu wird nach der Implementierung einer
Komponente, ein neues Schlüsselwort für eine
Komponentendefinition in die Grammatik eingebaut. Jede komplexe Komponente
benötigt darüber hinaus eine Bezeichnung, um referenziert zu werden. In dieser
Iteration ist die \gloss{Multiselection-Komponente} umgesetzt, welche generisch
implementiert ist. Der generische Typ wird innerhalb der Komponente in der
GUI-Beschreibung definiert. Ebenso muss der Entwickler die Werte angeben, welche
in dieser Komponente selektiert werden können.
Zusätzlich soll die Möglichkeit bestehen, Werte zu beschreiben, die bereits
ausgewählt wurden.


\subsection*{Semantisches Modell}
Das Artefakt, welches bei diesem Modell im Mittelpunkt steht, ist die
\emph{UIDescription} (siehe Abbildung \ref{Abb_Teil1-1}). Die Methoden werden
zum Erhalt der Übersichtlichkeit nur in den Interfaces abgebildet. In den Klassen sind
lediglich die globalen Variablen dargestellt. Die aggregierten Artefakte, auf
die schon im vorherigen Abschnitt hingewiesen wurde, sind dem Diagramm gut
zu entnehmen.
\myBigFigure{v1-1.jpg}{1. Iteration: UIDescription}{Teil1-1}
\myBigFigure{v1-1-1.jpg}{1. Iteration UsedUIDescription}{Teil1-1}
\noindent
Die Klasse \emph{DefinitionImpl} aggregiert weitere Artefakte des Modells. Diese
sind, um die Übersicht zu wahren, Abbildung \ref{Abb_Teil2-1} zu entnehmen.\\
\myBigFigure{v1-2.jpg}{Teil 3:
GUI-Beschreibungsmodell Version 1}{Teil2-1} 
\myBigFigure{v1-2-1.jpg}{Teil 4:
GUI-Beschreibungsmodell Version 1}{Teil2-1} 
\noindent
Dort sind die drei umgesetzten Ausprägungen einer \emph{Definition} zu erkennen.
Dabei handelt es sich um \emph{Label}, \emph{Button} und \emph{MultiSelection}.
Weiterhin ist zu erkennen, dass nur der \emph{Button} eine
Interaktion (\emph{Interaction}) enthalten kann. Das Interface \emph{Property}
wird benötigt, um bestimmte Eigenschaften der \gks festzulegen, ohne wissen zu
müssen, um welchen Komponententyp es sich handelt.
Dazu wurden die allgemein gültigen Einstellungsmöglichkeiten von \Ks in
\emph{CommonProperty} zusammengefasst.

\subsection*{Konkrete Syntax}
Folgender Auszug aus einem \emph{GUI-Skript} enthält sämtliche Features, die im
Prototypen der ersten Iteration umgesetzt wurden.
\begin{lstlisting}[{caption
=1.
Iteration:
Syntax},{label = LST_Syntax1}] Area count: 4
type: WINDOW use: "AnotherDescription"
DEF Label as "HEAD" :
END DEF
DEF Button as "Interactbt": 
	text="Interagiere"
	interaction="btinteraction" type=CLICK with actions:type=UiAction element="HEAD":Text="Du hast interagiert"
END DEF
DEF MultiSelection as "Multiselect" :
	inputType="valuepackage.Values" 
	selectableValues="valuepackage.Values.asList()"
END DEF
Area:1<-"HEAD"
Area:2<-"AnotherDescription"
Area:3<-"Interactbt"
Area:4<-"Multiselect"
\end{lstlisting}
Die Bezeichnung \emph{Area} wurde bewusst gewählt, da dieser Begriff
abstrakter ist als die in verschiedenen \acrshort{GUI}-Frameworks verwendeteten
Begriffe, wie \emph{Panel} oder \emph{Pane}. Die Syntax dieser DSL soll sich
bzgl. des Aufbaus der GUI an keinem \acrshort{GUI}-Framework orientieren. Die
einzelnen Komponentendefinitionen werden durch das Schlüsselwort \emph{DEF}
eingeleitet und durch das Schlüsselwort \emph{END DEF} abgeschlossen. Der
Definitionskopf wird durch das Zeichen \emph{\glqq :\grqq} beendet. Dort sind
die Pflichtfelder \emph{Titel} und \emph{Typ} der Komponentendefinition zu
finden.
Bei der \emph{Multiselection-Komponente} fällt auf, dass ein Referenzwert
verwendet wird, der in dieser Beschreibung nicht deklariert wurde (\emph{valuespackage.Values}).
Dabei handelt es sich um einen qualifizierten Namen einer Klasse.\\
Die dazugehörige Grammatik befindet sich im Anhang \hyperref[cd]{Anlage}.

\section{2. Iteration}

\subsection*{Analyse der Metadaten}
In den Metadaten der GUI-Beschreibung muss in dieser Iteration eine
\emph{Proper\-ties-Datei angegeben} werden, in der bestimmte Werte für die
Attribute der \gks enthalten sind.\\
Da die Möglichkeit bestehen soll, die in den eingebundenen \emph{GUI-Skripten}
definierten Komponenten zu verändern, wird eine weitere
Ergänzung für die GUI-Beschreibung benötigt. Diese Veränderungen sollen
sich sowohl semantisch als auch syntaktisch von der Komponentendefinition
abgrenzen (siehe semantisches Modell \emph{Refinement}). Um das eindeutige
Referenzieren zu ermöglichen, muss bei der Bezeichnung der eingebundenen
\emph{GUI-Skripte} sowie bei der veränderten Komponente der qualifizierte Name
angegeben werden.\\
Bei den Interaktionen der \Ks fällt die Aktion komplett weg. Somit muss nur noch
der Interaktionstyp zu benennen.\\
In den Definitionen der \Ks muss aufgrund des Properties-Konzeptes die
Möglichkeit bestehen, einen Property-Schlüssel anzugeben. Alle anderen Metadaten
für die \Ks bleiben bestehen.\\
Bezogen auf die \knks ist es lediglich notwendig,
den Typ des Inputs anzugeben. Die Festlegung über Elemente, die in der
\emph{Multiselection-Komponente} selektiert
werden können oder bereits ausgewählt sind, wird nicht benötigt.
Das ermöglicht die \knks mittels \emph{use} (siehe semantisches Modell
\emph{UsedDefinitions}) in die GUI-Beschreibung einzubinden (siehe konkrete
Syntax).


\subsection*{Semantisches Modell}
In dieser Iteration wurden an den Artefakten \emph{AreaCount},
\emph{TypeDefinition} und \emph{AreaAssignment} keine Änderungen vorgenommen.
Die Artefakte \emph{Property} und \emph{Refinement} sind hinzugekommen. Weitere
Artefakte, die von \emph{UIDescriptionImpl} aggregiert werden (siehe Abbildung \ref{Abb_Teil2-1}), wurden verändert.
\myBigFigure{v2-1.jpg}{Teil 1: GUI-Beschreibungsmodell Version 2}{Teil1-2}
\noindent
Das Artefakt \emph{Property} bildet die Property-Datei ab. Sie ist nicht zu
verwechseln mit dem Artefakt \emph{Properties}, welches die Eigenschaften von
Komponenten abbildet. Abbildung \ref{Abb_Teil2-2} zeigt beide Artefakte auf.
\myBigFigure{v2-2}{Teil 2: GUI-Beschreibungsmodell Version 2}{Teil2-2}
\noindent
Die \emph{UsedDescription} enthält in dieser Iteration einen
\emph{DefinitionType}.
Dieser bestimmt, ob es sich bei der importierten Komponente um ein
eingebundenes \emph{GUI-Skript handelt} oder um eine komplexe Komponente, für
die der Input (\emph{inputType}) festgelegt werden kann.
\myBigFigure{v2-3}{Teil 3: GUI-Beschreibungsmodell Version 2}{Teil3-2}
\noindent
Weiterhin wird zwischen \emph{Definition} und
\emph{Refinement} unterschieden.
Die \emph{Definition} bildet neu definierte Komponenten für die \gui ab. Ein
\emph{Refinement} hingegen beschreibt die veränderten Komponenten importierter
\emph{GUI-Skripte} (siehe Abbildung \ref{Abb_Teil4-2} und Abbildung
\ref{Abb_Teil5-2}).
\myBigFigure{v2-4}{Teil 4: GUI-Beschreibungsmodell Version 2}{Teil4-2}
\myBigFigure{v2-5}{Teil 5: GUI-Beschreibungsmodell Version 2}{Teil5-2}


\subsection*{Konkrete Syntax}
Zur Umsetzung des Properties-Konzepts ist in der zweiten Iteration ein neues
Schlüsselwort hinzugekommen. Um eine
\emph{Properties-Datei} einzubinden, muss, wie in Listing \ref{LST_Properties2},
eine entsprechende Datei angegeben und in den Komponentendefinitionen entsprechende
Schlüssel deklariert werden. Das \emph{Label} mit der Bezeichnung
\emph{OneLabel} enthält keinen Property-Schlüssel (\emph{PropertyKey}).
In diesem Fall wird der Titel als solcher verwendet.
\begin{lstlisting}[{caption = 2. Iteration: Properties},{label =
LST_Properties2}] 
type: WINDOW 
get properties from: 'sources.ui.properties' 
DEF Label as "OneLabel" END DEF
DEF Label as "AnotherLabel":
	propertyKey='AnotherLabel2'
END DEF
\end{lstlisting}
Aufgrund der Reduktion der Metadaten für eine Interaktion, musste
festgelegt werden, ob die Interaktionstypen 
hintereinander durch Kommasetzung oder untereinander durch entsprechende
Schlüsselwörter deklariert werden sollen. Unter Beachtung der Anforderung
\hyperref[AS4]{AS4} wird die erste Variante bevorzugt (siehe Listing \ref{LST_Interaktion2}).
\begin{lstlisting}[{caption=2.
Iteration: Interaktion},{label=LST_Interaktion2}] DEF Button as
"InteractButton":
	interactiontype=Click,ChangeText
END DEF
\end{lstlisting}
Die \knks werden, wie in Listing \ref{LST_Komplexe2} mit
der Komponente \emph{Multiselection} gezeigt, über das Schlüsselwort
\emph{use} eingebunden.
Der Typ des Inputs kann dabei optional innerhalb der Zeichen \emph{\glqq <\grqq}
und \emph{\glqq >\grqq} angegeben werden.
\begin{lstlisting}[{caption=2. Iteration: Definition komplexer
Komponenten},{label=LST_Komplexe2}] 
type: WINDOW 
use: Multiselection<'valuepackage.Values'> as: 'Multi'
\end{lstlisting}
Für die Zuweisung mehrerer Komponenten zu den Bereichen (\emph{Area}) kamen
zwei Lösungen in Betracht. Bei der ersten Lösung finden die Definitionen der
Komponenten zusammen mit der Zuweisung zu einem Bereich statt. Dies könnte bspw.
wie in Listing \ref{LST_Moeglichkeit1_2} dargestellt werden.
\begin{lstlisting}[{caption=2. Iteration: Button und Label
(1)},{label=LST_Moeglichkeit1_2}] 
Area count: 1 type: WINDOW 
Area:1={
DEF Button as "Button:
	text="Button"
END DEF
DEF Label as "Label":
	text="Label"
END DEF
}
\end{lstlisting}
Eine andere Möglichkeit wäre es, die aktuelle Form der Zuweisung zu verfeinern
und somit die Komponenten bei der Zuweisung durch Kommas von einander getrennt
aufzuzählen. Wenn nur die in der Datei definierten Komponenten einem Bereich
zugewiesen werden müssten, würde sich die erstgenannte Lösungsmöglichkeit
anbieten. Jedoch können die mit \emph{use} eingebundenen Komponenten auch
Bereichen zugeordnet werden, weshalb für dieses Verfahren ein zusätzliches
syntaktisches Konzept innerhalb der Zuweisung benötigt werden würde. Um dies zu
umgehen, wurde die Entscheidung getroffen, das alte Verfahren zu verfeinern.
Listing \ref{LST_Moeglichkeit2_2} zeigt ein Beispiel für die Zuweisung von drei Komponenten zu einem Bereich.
\begin{lstlisting}[{caption=2. Iteration: Area-Zuweisung
(2)},{label=LST_Moeglichkeit2_2}]
Area count: 1
type: WINDOW 
DEF Label as "OneLabel" END DEF
DEF Label as "AnotherLabel" END DEF
DEF Button as "InteractButton": 
	interactiontype=Click,ChangeText
END DEF
Area:1<-"OneLabel","InteractButton","AnotherLabel"

\end{lstlisting}
Die Eigenschaften von Komponenten, welche in einem eingebundenen
\emph{GUI-Skript} definiert wurden, können durch die Verwendung des
Schlüsselworts \emph{REFINE} überschrieben werden. Der erste Teil von Listing
\ref{LST_Override2} zeigt die Originaldatei, welche eingebunden
wird. Diese trägt den Namen \emph{LabelAndButton} und befindet sich im Package
\emph{guidescription}. Der zweite Teil von Listing
\ref{LST_Override2} zeigt, wie die Aufschrift der
Komponente \emph{ButtonToOverride} überschrieben wird.
\begin{lstlisting}[{caption=2. Iteration: Verändern von Komponenten
eingebundener GUI-Beschreibungen},{label=LST_Override2}] 
PART 1 Area count: 2
type: INNERCOMPLEX
DEF Label as "Label" :
	text="Text" 
END DEF
DEF Button as "Button":
	text="AlterText" 
END DEF
Area:1<-'Label'	
Area:2<-"Button"


PART 2
Area count: 1
type: WINDOW 
use: "guidescription.LabelAndButton" as: 'Embedded'
REFINE Button with name: 'ButtonToOverride':
	text='NewText'
END REFINE
Area:1<-'Embedded'
\end{lstlisting}
Sollten die Bezeichnungen von eingebundenen Komponenten nicht eindeutig
sein, muss der Name des dazugehörigen \emph{GUI-Skriptes} in der Referenz
mit angegeben werden (siehe Listing \ref{LST_Override2_2}).
\begin{lstlisting}[{caption=2. Iteration: Verändern von Komponenten
eingebundener GUI-Beschreibungen mit
Namensüberschneidung},{label=LST_Override2_2}] 
use: "guidescription.LabelAndButton" as: 'Embedded1' 
use: "guidescription.LabelAndTwoButton" as: 'Embedded2' 
REFINE Button with name: 'Embedded2.OverriddenButton':
	text='NewText'
END REFINE
\end{lstlisting}
\noindent
Die dazugehörige Grammatik, welche in der zweiten Iteration entwickelt wurde,
ist im Anhang \hyperref[cd]{Anlage} zu finden.



\section{3. Iteration}
\subsection*{Analyse der Metadaten}
Um das Referenzieren von \gks und dem entsprechenden Layout aus der
Layoutdatei zu ermöglichen, ist es wie bei den Properties-Dateien notwendig,
die Layoutdatei innerhalb des \emph{GUI-Skripts} anzugeben. Weiterhin wird in
den einzelnen Komponentendefinitionen ein Schlüssel benötigt, über den die
Komponente eindeutig referenziert werden kann. Dafür ist es möglich die
Bezeichnung der \gk zu verwenden. Um in der Layoutdatei nicht jede
\gks einzeln aufführen zu müssen, wird innerhalb der GUI-Beschreibung
ein optionales Feld benötigt, wodurch unterschiedlichen \gks
derselbe Layout-Schlüssel zugeordnet werden kann.\\
Da die Anzahl der Bereiche nicht mehr angegeben werden muss, fällt dies aus den
Metadaten heraus. Die Zuweisung der \gks zu den Bereichen entfällt ebenfalls.
Die Strukturierung wird über eine Aufzählung der \gks vorgenommen.\\
Zusammenfassend werden folgende Metadaten für die
Beschreibung einer \gui mit der \emph{GUI-DSL} benötigt:
\textbf{
\begin{itemize}
  \item  Typ
  \item  Properties-Dateien
  \item  Layout-Dateien
  \item  Eingebundene \gks
  \item  Veränderte eingebundene Komponentendefinitionen
  \item  Komponentendefinitionen 
  \item  Struktur
\end{itemize}}
\noindent\\
Alle Komponentendefinitionen und die veränderten eingebundenen
Komponentendefinitionen benötigen durch die genannten Änderungen folgende
Metadaten:
\textbf{
\begin{itemize}
  \item  Bezeichnung
  \item  Property-Schlüssel (optional)
  \item  Layout-Schlüssel (optional)
  \item  Interaktionen (optional)
\end{itemize}}
\noindent\\
Über die konkreten Komponentendefinitionen müssen mehrere \Ks beschrieben
werden können. \Ks die spezielle Metadaten benötigen, sind mit eben diesen in
folgender Tabelle aufgelistet.
\begin{table}[H]
\centering
\small
\begin{tabular}[c]{|l|l|}
			\hline
			\hline
				\textbf{Basiskomponente} & \textbf{Spezifische Metadaten}\\
				\hline\hline
				Label & 
  		  				Aufschrift
				 \\
				\hline
				Button & 
  		  Aufschrift
  		  \\
				\hline
				Textfield &  
  		  Text, Veränderungsmöglichkeit des Textes
  		  \\
				\hline
				Textarea  &  
  		  Text, Veränderungsmöglichkeit des Textes
  		   \\
				\hline
				Tree &  
  		  Input-Modell
  		  \\
				\hline
				Table &  
  		  Input-Modell
  		  \\
				\hline
				TabView &  
  		  GUI-Beschreibungen der einzelnen Tabe
  		  \\
				\hline
				\hline
			\end{tabular} 
 \caption{Basiskomponenten mit spezifischen Metadaten}
 \label{tab_comp}
\end{table}
\noindent
Mit Ausnahme der Metadaten des \emph{TabViews} sind alle Angaben zu anderen
Basiskomponenten optional.

\subsection*{Semantisches Modell} 
Das semantische Modell hat sich durch die vielen Änderungen in dieser Iteration
stark verändert. Bei der Betrachtung der \emph{UIDescription} (siehe Abbildung
\ref{Abb_I3_1}) fällt auf, dass \emph{Area} und \emph{AreaCount} nicht mehr
vorhanden sind. Hinzugekommen sind die Artefakte \emph{Structure}, in dem die
Anordnung der \gks (\emph{Element}) in einer Liste beschrieben wird und
\emph{Layout}, in dem die verwendeten Layoutdateien in einer Liste abgelegt
werden.\\
Eine weitere Änderung ist bei \emph{Property} zu finden. Dort ist jetzt
ebenfalls eine Liste vorhanden und kein alleinstehender Wert mehr.
\myBigFigure{v3-1.jpg}{3. Iteration: UIDescription}{I3_1}
\noindent
An \emph{TypeDefinition} und \emph{UsedDescription} wurden keine signifikanten
Änderungen vorgenommen. Die meisten Änderungen wurden bei den Artefakten
\emph{Refinement} und \emph{Definition} vorgenommen. Der Aufbau dieser
Artefakte ist ähnlich. Das Interface (\emph{Refinement} und \emph{Definition})
wird von einer Klasse implementiert (\emph{RefinementImpl} und
\emph{DefinitionImpl}), die mehrere Objekte enthält. Die Klassen dieser Objekte
implementieren das Interface \emph{ComponentRefinement} oder
\emph{ComponentDefinition}. Abbildung \ref{Abb_I3_2} ist diese Struktur für die
\emph{Definition} zu entnehmen.
\myBigFigure{v3-2}{3. Iteration: Definition}{I3_2}
\noindent
Die benannten Klassen bilden die unterschiedlichen \Ks ab, die
definiert oder verändert werden können. Jede dieser Klassen aggregiert ein
Objekt des Typen \emph{CommonProperties} ein. Dieses Interface bildet die
allgemeinen Properties ab. Bei den \Ks \emph{Label}, \emph{Button},
\emph{Textfield} und \emph{Textarea} ist diese Aggregation transitiv, da die
speziellen Properties dieser \Ks als eigenes Artefakt implementiert sind. Abbildung \ref{Abb_I3_3} zeigt dies für einen
\emph{Button} auf.
\myBigFigure{v3-3.jpg}{3. Iteration: Button}{I3_3}
\noindent
Eine direkte Aggregation der \emph{CommonProperties} findet bei den \Ks TabView,
Table und Tree statt. Für die speziellen Properties dieser \Ks existieren keine
einzelnen Klassen. Die folgenden Abbildungen (\ref{Abb_I3_4}, \ref{Abb_I3_5} und
\ref{Abb_I3_6}) zeigen diese drei \Ks (\emph{Refinement} und \emph{Definition})
mit der Aggregation der \emph{CommonProperties}.
\myBigFigure{v3-4.jpg}{3. Iteration: TabView}{I3_4}
\noindent
Die \K TabView benötigt eine Menge von \emph{TabDefinition}s. Diese Klasse
bildet die Referenz zu den in die TabView einzubindenden \gks.
Die \Ks Tree und Table benötigen lediglich eine Referenz auf den Input-Typen,
den sie abbilden sollen, in Form einer Zeichenkette (siehe Abbildung
\ref{Abb_I3_5} und \ref{Abb_I3_6}).
\myBigFigure{v3-5.jpg}{3. Iteration: TabView}{I3_5}
\myBigFigure{v3-6.jpg}{3. Iteration: TabView}{I3_6}
\subsection*{Konkrete Syntax} Die syntaktischen
Konstrukte wurden in dieser Iteration stark vermehrt. Das liegt vor allem daran, dass viele neue \Ks hinzugekommen sind. Der
grundsätzliche syntaktische Aufbau eines GUI-Skripts hat sich jedoch nicht
verändert. Eingeleitet wird die Beschreibung weiterhin mit der Typ-Definition,
gefolgt von der Angabe der Properties-Dateien. Sofern mehrere Properties-Dateien
vorhanden sind, werden diese mit Komma getrennt voneinander aufgezählt.\\
Dasselbe Prinzip wird bei der sich anschließenden Angabe der Layout-Datei\-en
verwendet.
Das Semikolon gilt ab sofort als Trennzeichen für einen abgeschlossen
definierten Komplex (siehe Listing \ref{LST_PropertiesLayout3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Properties- und Layout-Dateien},{label = LST_PropertiesLayout3}] 
type: INNERCOMPLEX;
get properties from:'properties1', 'properties2';
get layout from:'layout1','layout2';
\end{lstlisting}
Für die eingebundenen \gks wurden keine
großen syntaktischen Veränderungen vorgenommen. Lediglich das Semikolon wird für
den Abschluss des Komplexes benötigt (siehe Listing \ref{LST_Use3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Eingebundene \gks},{label = LST_Use3}] 
use: Multiselection<Input> as: "multi";
\end{lstlisting}
Die Definitionen der einzelnen \Ks hat sich syntaktisch stark verändert. Grund
dafür ist vor allem, dass die Anforderungen \hyperref[AA5]{AA5} und
\hyperref[AS4]{AS4} mehr Beachtung
finden sollen. Somit werden die bekannten \Ks wie folgt definiert (siehe Listing
\ref{LST_Bt+Lb3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Button und Label},{label = LST_Bt+Lb3}] 
Button as: "Button" -> propertyKey='buttonproperty' layoutKey='buttonlayout'
interactiontype=IfViewImage text='buttontext';

Label as: 'Label' -> propertyKey='labelproperty' layoutKey='labellayout'
interactiontype=IfActivator text='labeltext';
\end{lstlisting}
Bei den Definitionen der anderen \Ks werden die allgemeinen Properties wie im
vorherigen Beispiel zugewiesen. In den Fällen der \Ks Textflied und Textarea
werden die speziellen Properties nach demselben Prinzip definiert (siehe Listing
\ref{LST_Tf+Ta3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Textfield und Textarea},{label = LST_Tf+Ta3}] 
Textfield as: 'Textfield' -> propertyKey='textfieldproperty'
layoutKey='textfieldlayout' interactiontype=IfActivator 
text='textfieldtext' editable=TRUE;

Textarea as: 'Textarea' -> propertyKey='textareaproperty'
layoutKey='textarealayout' interactiontype=IfActivator 
text='textareatext' editable=TRUE;
\end{lstlisting}
Die Syntax für die Definition der \Ks Table und Tree sind ähnlich. Der
benötigte Input-Typ wird nach dem Schlüsselwort angegeben, welches die
\gk bestimmt (siehe Listing \ref{LST_T+T3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Table und Tree},{label = LST_T+T3}] 
Table<tablemodel> as: 'Table' -> propertyKey='tableproperty'
layoutKey='tablelayout' interactiontype=IfActivator;

Tree<treemodel> as: 'Tree' -> propertyKey='treeproperty'
layoutKey='treelayout' interactiontype=IfActivator;
\end{lstlisting}
Die \Ks TabView werden die verwendeten GUI-Komponen\-ten der einzelnen Tabe
ebenfalls nach dem Schlüsselwort angegeben, welches die \gk
festlegt.
Hierbei können anderes als bei den \Ks Table und Tree mehrere Angaben getätigt
werden (siehe Listing \ref{LST_Tab3}).\\
In den folgenden Beispielen wird davon
ausgegangen, dass die vorher genannten Beispiele für die \Ks Tree, Table und
Textarea in demselben GUI-Skript definiert wurden. Durch das syntaktische
Konstrukt in Listing \ref{LST_Tab3} wird eine Tab-Ansicht mit drei Taben
beschrieben. Das erste Tab enthält den Tree, das zweite die Table und das dritte
die Textarea.
\begin{lstlisting}[{caption = 3.
Iteration:
TabView},{label = LST_Tab3}] 
TabView[Tree][Table][Textarea] as: 'tabview' -> propertyKey='tabviewproperty'
layoutKey='tabviewlayout' interactiontype=IfViewImage;
\end{lstlisting}
Dabei ist zu erwähnen, dass die Angabe der Properties in den meisten
Fällen optional ist. Lediglich die speziellen Properties der \Ks Table, Tree und
TabView müssen zwingend angegeben werden.\\
Die Syntax zur Veränderung einer \K eines eingebundenen GUI-Skripts ähnelt
der Definition einer \K des gleichen Typs. Es muss lediglich angegeben werden,
welche \gks in welcher GUI-Beschreibung verändert werden soll.\\
Folgendes Beispiel zeigt, wie die Aufschrift eines Buttons eines eingebundenen
GUI-Skripts verändert wird (siehe Listing \ref{LST_Refine3}). Der Button
trägt die Bezeichnung \emph{EmbeddedButton}. Das
GUI-Skript liegt im Package
\emph{guidescription} und trägt die Bezeichnung
\emph{Embedded}.
\begin{lstlisting}[{caption = 3.
Iteration:
TabView},{label = LST_Refine3}] 
use: "guidescription.Embedded" as: "embedded";
Button change:'embedded.EmbeddedButton' -> text='Neuer Text';
\end{lstlisting}
\noindent
Der letzte Teil einer GUI-Beschreibung beinhaltet die Angabe der Struktur. Diese
Angabe ähnelt der Zuweisung von \gks zu Bereichen, wie es auch der
ersten und zweiten Iteration bekannt ist. Da dieses Konstrukt vereinfacht werden
sollte, werden die \gks in der richtigen Reihenfolgen nach dem
Schlüsselwort \emph{Structur} aufgezählt (siehe Listing \ref{LST_Structure3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Struktur},{label = LST_Structure3}] 
Structure:'Button','Label','Textfield','tabview';
\end{lstlisting}
\noindent
Die damit für diese Arbeit endgültige Grammatik ist, wie die Grammatiken der
anderen Iterationen, im Anhang \hyperref[cd]{Anlage} zu finden.
