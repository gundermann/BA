\chapter{Entwicklung einer DSL zur Beschreibung der GUI in profil c/s}\label{Entwicklung einer DSL zur Beschreibung der GUI in profil c/s}
\section{1. Iteration}
\subsection*{Analyse der Metadaten der GUI}
Die Beschreibung einer \acrshort{GUI} wird in der Sprache als eigener Komplex betrachtet
(siehe semantisches Modell \emph{Definition}). Innerhalb dieses Komplexes werden
die entsprechenden Komponenten definiert. Die Bereiche die innerhalb einer
Beschreibung festgelegt werden sollen, müssen \gks zugeordnet werden
können (siehe semantisches Modell \emph{AreaAssignment}). Diese Bereiche
sollten vor der Entwicklung bereits festgelegt werden. Um abzusichern, dass die 
die Anzahl der festgelegten Bereiche genau eingehalten wird, muss diese
Anzahl in der GUI-Beschreibung angegeben werden (siehe semantisches Modell
\emph{AreaCount}).\\
Für die Beschreibung der Layout-Komponenten werden zwei Typen unterschieden
(siehe semantisches Model \emph{TypeDefinition}).\\
Ein weiterer Aspekt in der GUI-Beschreibung ist die Verwendung von anderen
GUI-Beschreibungen (siehe semantisches Modell \emph{Use}).\\ 
Zusammenfassend sind für die Beschreibung der GUI folgende Metadaten nötig.
\begin{itemize}
  \item [] Anzahl der Bereiche
  \item [] Zuweisung der \gks zu den Bereichen
  \item [] Angabe des Layout-Typs
  \item [] Angabe der Verwendeten GUI-Beschreibungen
  \item [] Definition von \gks
\end{itemize}
Die Definition der \gks nehmen einen eigenen Komplex innerhalb der
GUI-Beschreibung ein. 
Bezogen auf die \Ks des UIs ist die
Beschreibung eines Textes wichtig. Im Falle eines Buttons oder eines Labels
(andere \Ks sind in dieser Iteration nicht umgesetzt) beschreibt
dieser die Aufschrift der Komponente.
Weiterhin ist es für die Zuweisung zu einem Bereich wichtig, dass
diese Komponenten innerhalb der Datei referenziert werden können. Daher muss
für jede UI-Komponente eine Bezeichnung definiert werden, die innerhalb der
Datei eindeutig ist.\\
An den \Ks können darüber
hinaus Interaktionen beschrieben werden. Hierzu sind Informationen über den
Interaktionstyp nötig.
Der einzige, in dieser Iteration umgesetzte, Interaktionstyp ist ein Klick auf
die Komponente. An dieser Interaktion können ebenso Aktionen definiert werden, die Auswirkungen auf andere Komponenten haben.
Zusammenfassend ergeben sich folgende Meta-Daten der \Ks.
\begin{itemize}
  \item[] Typ
  \item[] Bezeichnung
  \item[] Text
  \item[] Interaktion (siehe semantisches Modell \emph{Interaction})
\end{itemize}
Die Interaktion benötigt folgende Attributen, die beschrieben werden müssen.
\begin{itemize}
  \item[] Bezeichnung
  \item[] Interaktionstyp
  \item[] Aktion
\end{itemize}
Aktionen nehmen wiederum einen eigenen Komplex innerhalb der
Komponentendefinition ein. Dabei werden folgende Informationen benötigt.
\begin{itemize}
  \item[] Aktionstyp\\
  Zur Unterscheidung zwischen Interaktionen mit anderen \gks oder
  fachlichen Modellen
  \item[] Element\\
  Ein Verweis auf das Element, mit dem interagiert werden soll.
  \item[] Attribute (siehe semantisches Modell \emph{Property})\\
  Die zu verändernden Attribute des Elements.
\end{itemize}
Die \knks werden in einer eigenen Komponentendefinition beschrieben. Grund dafür
ist, dass neben den vordefinierten Funktionalitäten der \knks auch weitere
optionale Wertzuweisungen möglich sein sollen. Dazu wird nach der Implementierung
der Komponente für jedes Framework ein neues Schlüsselwort für eine
Komponentendefinition in die Grammatik eingebaut. Jede komplexe Komponente
darüber hinaus eine Bezeichnung um referenziert zu werden. In dieser
Iteration ist eine \gloss{Multiselection-Komponente} umgesetzt. Diese Komponente
ist generisch implementiert. Der generische Typ muss innerhalb der
Komponenten in der GUI-Beschreibung definiert werden. Ebenso müssen die
Werte, die in dieser Komponente selektiert werden können, angegeben werden.
Zusätzlich sollen optional auch die Werte angegeben werden, die bereits
selektiert wurden.


\subsection*{Semantisches Modell}
\myBigFigure{v1-1.jpg}{Teil 1: GUI-Beschreibungsmodel Version 1}{Teil1-1}
Das Artefakt, welches beim diesem Modell im Mittelpunkt steht ist die
\emph{UIDescription} (siehe \ref{Abb_Teil1-1}). Bezüglich der Methoden sind
im Allgemeinen nur Getter- und Setter-Methoden des semantischen Modells für
diese Arbeit von Belang. Die aggregierten Artefakte sind aus dem Diagramm gut zu
entnehmen.
Die Klasse \emph{DefinitionImpl} aggregiert weitere Artefakte des Modells. Diese sind um
die Übersicht zu wahren Abbildung \ref{Abb_Teil2-1} zu entnehmen.\\
\myBigFigure{v1-2.jpg}{Teil 2:
GUI-Beschreibungsmodel Version 1}{Teil2-1} 
Dort sind die drei umgesetzten Ausprägungen einer \emph{Definition} zu erkennen.
Dabei handelt es sich um \emph{Label}, \emph{Button} und \emph{MultiSelection}.
Weiterhin ist zu erkennen, dass nur der Button eine \emph{Interaction}
enthalten kann. Das bedeutet, dass nur an dieser Komponente eine Interaktion
beschrieben werden kann. Das Artefakt \emph{Property} ist der letzte
interessante Teil. Dieses Interface wird benötigt um bestimmte Werte an
Komponenten zu setze, ohne das Wissen zu müssen um welchen Komponententyp es
sich handelt.
Dazu wurden die allgemein gültigen Einstellungsmöglichkeiten von \Ks in
\emph{CommonProperty} zusammengefasst. Die Klasse \emph{PropertyImpl} ist ein Artefakt, welches zur Vollständigkeit des
Modells erzeugt wurde. Es erfüllt für diese Version jedoch keinen weiteren
Zweck.

\subsection*{Konkrete Syntax}
\begin{lstlisting}[{caption =1. Iteration: Syntax},{label = LST_Syntax1}]
Area count: 4
type: WINDOW use: "AnotherDescription"
DEF Label as "HEAD" :
END DEF
DEF Button as "Interactbt": 
	text="Interagiere"
	interaction="btinteraction" type=CLICK with actions:type=UiAction element="HEAD":Text="Du hast interagiert"
END DEF
DEF MultiSelection as "Multiselect" :
	inputType="valuepackage.Values" 
	selectableValues="valuepackage.Values.asList()"
END DEF
Area:1<-"HEAD"
Area:2<-"AnotherDescription"
Area:3<-"Interactbt"
Area:4<-"Multiselect"
\end{lstlisting}
Die Bezeichnung \emph{Area} wurde bewusst so gewählt, da dieser Begriff
abstrakter ist als die in verschiedenen UI-Frameworks verwendeteten Begrifft
wie, Panel oder Pane. In der Syntax dieser DSL gilt es sich vor allem bzgl. des
Aufbaus der GUI an keinem UI-Framework zu orientieren. Die einzelnen
Komponentendefinitionen werden durch das Schlüsselwort \emph{DEF} eingeleitet
und durch das Schlüsselwort \emph{END DEF} abgeschlossen. Der Definitionskopf
wird durch das Zeichen \emph{:} beendet. Dort sind die Pflichtfelder der
Komponentendefinition zu finden (\emph{Titel} und \emph{Typ}).
Bei der Multiselection-Komponente fällt auf, dass ein Referenz-Wert verwendet
wird, der in dieser Beschreibung nicht deklariert wurde (\emph{valuespackage.Values}).
Dabei handelt es sich um einen qualifizierten Namen einer Klasse.\\
Die dazugehörige Grammatik befindet sich im Anhang
\ref{AppGrammatiken}.





\section{2. Iteration}

\subsection*{Analyse der Metadaten des GUIs}
Für die Metadaten der GUI-Beschreibung werden muss in dieser Iteration eine Properties-Datei angegeben werden, in der bestimmte Werte
für die Attribute der \gks enthält.\\
Da die Möglichkeit bestehen soll die, in den eingebundenen GUI-Beschreibungen
definierten, Komponenten in dieser Iteration zu verändert, wird eine weitere
Ergänzung für die GUI-Beschreibung benötigt. Diese Veränderungen sollen sich von
der Komponentendefinition abgrenzen, damit für nicht überschriebene Werte auf
die eingebundene GUI-Beschreibung zurückgegriffen werden kann (siehe
semantisches Modell \emph{Refinement}). Um die eindeutige Referenzierung zu
ermöglichen muss bei der Bezeichnung der eingebundenen GUI-Beschreibung sowie
bei der veränderten Komponente der qualifizierte Name angegeben werden.\\
Bei den Interaktionen der \Ks fällt die Aktion komplett weg. Somit muss nur noch
der Interaktionstyp angegeben werden.\\
In den Definitionen der \Ks muss aufgrund des Properties-Konzeptes die
Möglichkeit bestehen, einen Property-Schlüssel anzugeben. Alle anderen Metadaten
für die \Ks bleiben bestehen.\\
Bezogen auf die \knks ist es lediglich notwendig
den Input-Typ anzugeben. Die Festlegung über selektierbare und
selektierte Elemente in der Multiselection-Komponente wird nicht benötigt. Das
ermöglicht, die \knks mittels \emph{use} (siehe semantisches Modell
\emph{UsedDefinitions}) in die GUI-Beschreibung einzubinden (siehe konkrete
Syntax).


\subsection*{Semantisches Modell}
In dieser Version wurden an den Artefakten \emph{AreaCount},
\emph{TypeDefinition} und \emph{AreaAssignment} keine Änderungen vorgenommen.
Artefakte wie \emph{Property} und \emph{Refinement} sind hinzugekommen. Die
weiteren Artefakte, die von \emph{UIDescriptionImpl} aggregiert werden
(siehe Abbildung \ref{Abb_Teil2-1}), wurden verändert.
\myBigFigure{v2-1.jpg}{Teil 1: GUI-Beschreibungsmodell Version 2}{Teil1-2}
Das Artefakt \emph{Property} bildet die Property-Datei ab. Sie ist nicht zu
verwechseln mit dem Artefakt \emph{Properties}, welches die Eigenschaften von
Komponenten abbildet. Abbildung \ref{Abb_Teil2-2} zeigt beide Artefakte auf.
\myBigFigure{v2-2}{Teil 2: GUI-Beschreibungsmodell Version 2}{Teil2-2}
Die \emph{UsedDescription} enthält in dieser Version einen
\emph{DefinitionType}.
Dieser bestimmt, ob es sich bei der importierten Komponente um ein
beschriebenes GUI handelt, oder um eine komplexe Komponente, für die ein
Input-Typ (\emph{inputType}) festgelegt werden kann.
\myBigFigure{v2-3}{Teil 3: GUI-Beschreibungsmodell Version 2}{Teil3-2}
Zwischen \emph{Definition} und \emph{Refinement} wird unterschieden. Die
\emph{Definition} bildet neu definierte Komponenten für das GUI ab. Ein
\emph{Refinement} hingegen bildet die veränderten Komponenten importierter
GUIs ab (siehe Abbildung \ref{Abb_Teil4-2} und Abbildung \ref{Abb_Teil5-2}).
\myBigFigure{v2-4}{Teil 4: GUI-Beschreibungsmodell Version 2}{Teil4-2}
\myBigFigure{v2-5}{Teil 5: GUI-Beschreibungsmodell Version 2}{Teil5-2}



\subsection*{Konkrete Syntax}
Die einfachste der Veränderungen bzgl. der Syntax in Version 2 ist die
Festlegung der Properties-Dateien. Um eine Properties-Datei einzubinden muss,
wie in Listing \ref{LST_Properties2}, eine entsprechende
Datei festgelegt und in den Komponenten entsprechende Schlüssel vergeben
werden. Das Label mit der Bezeichnung \emph{OneLabel} enthält keinen
Property-Key.
In diesem Fall wird der Titel als solcher verwendet.
\begin{lstlisting}[{caption = 2. Iteration: Properties},{label =
LST_Properties2}] 
type: WINDOW 
get properties from: 'sources.ui.properties' 
DEF Label as "OneLabel" END DEF
DEF Label as "AnotherLabel":
	propertyKey='AnotherLabel2'
END DEF
\end{lstlisting}
Aufgrund der Reduzierung der Meta-Daten für eine Interaktion stand die Frage
offen, ob die Interaktionstypen einfach hintereinander mit Komma, oder untereinander mit dem
entsprechenden Schlüsselwort aufgezählt werden sollen. Aufgrund der Tatsache,
dass in der deg höchstens 4 Interaktionstypen in einer Komponente verwendet
werden, werden diese in der GUI-Beschreibung per DSL hintereinander mit Komma
aufgezählt, wie in Listing \ref{LST_Interaktion2} zu erkennen ist.
\begin{lstlisting}[{caption=2.
Iteration: Interaktion},{label=LST_Interaktion2}] DEF Button as
"InteractButton":
	interactiontype=Click,ChangeText
END DEF
\end{lstlisting}
Die komplexen Komponenten werden wie in Listing \ref{LST_Komplexe2} mit
der Komponente Multiselection gezeigt ist, über das Schlüsselwort \emph{use}
eingebunden werden.
Der Input-Typ kann dabei optional innerhalb der Zeichen \emph{<} und \emph{>}
angegeben werden.
\begin{lstlisting}[{caption=2. Iteration: Definition komplexer
Komponenten},{label=LST_Komplexe2}] type: WINDOW 
use: Multiselection<'valuepackage.Values'> as: 'Multi'
\end{lstlisting}
Für die Zuweisung mehrerer Komponenten zu den Areas kamen zwei Lösungen in
Betracht. Bei der einen finden die Definitionen der Komponenten zusammen mit der
Zuweisung zu dem Area statt. Dies könnte bspw. wie in Listing \ref{LST_Moeglichkeit1_2}
dargestellt werden.
\begin{lstlisting}[{caption=2. Iteration: Area-Zuweisung
(1)},{label=LST_Moeglichkeit1_2}] 
Area count: 1 type: WINDOW 
Area:1={
DEF Button as "Button:
	text="Button"
END DEF
DEF Label as "Label":
	text="Label"
END DEF
}
\end{lstlisting}
Eine andere Möglichkeit wäre es, die aktuelle Form der Zuweisung zu verfeinern
und somit die Komponenten bei der Zuweisung mit Komma getrennt von einander
aufzählen. Die erste Möglichkeit würde sich sehr gut eignen, wenn nur die in der
Datei definierten Komponenten dem Area zugewiesen werden müssten. Da die mit
\emph{use} eingebundenen Komponenten auch Areas zugeordnet werden, würde für
dieses Verfahren ein zusätzliches syntaktisches Konzept innerhalb der Area-Zuweisung
benötigt werden. Um dies zu umgehen wurde die Entscheidung getroffen, das alte
Verfahren zu verfeinern. Listing \ref{LST_Moeglichkeit2_2} ist ein Beispiel für die
Area-Zuweisung von drei Komponenten zu entnehmen.
\begin{lstlisting}[{caption=2. Iteration: Area-Zuweisung
(2)},{label=LST_Moeglichkeit2_2}]
Area count: 1
type: WINDOW 
DEF Label as "OneLabel" END DEF
DEF Label as "AnotherLabel" END DEF
DEF Button as "InteractButton": 
	interactiontype=Click,ChangeText
END DEF
Area:1<-"OneLabel","InteractButton","AnotherLabel"

\end{lstlisting}
Das Überschreiben der Werte von Komponenten, die in einer eingebundenen
GUI-Beschreibung definiert wurden, können über das Schlüsselwort \emph{REFINE}
getätigt werden. Der erste Teil von Listing \ref{LST_Override2} zeigt die Originaldatei,
deren Beschreibung eingebunden wird. Diese trägt den Namen \emph{LabelAndButton}
und befindet sich im Package \emph{guidescription}. Der zweite Teil zeigt, wie
die Aufschrift einer Komponente \emph{Button} überschrieben wird.
\begin{lstlisting}[{caption=2. Iteration: Verändern von Komponenten
eingebundener GUI-Beschreibungen},{label=LST_Override2}] 
PART 1 Area count: 2
type: INNERCOMPLEX
DEF Label as "Label" :
	text="Text" 
END DEF
DEF Button as "Button":
	text="AlterText" 
END DEF
Area:1<-'Label'	
Area:2<-"Button"


PART 2
Area count: 1
type: WINDOW 
use: "guidescription.LabelAndButton" as: 'Embedded'
REFINE Button with name: 'Button':
	text='NewText'
END REFINE
Area:1<-'Embedded'
\end{lstlisting}
Sollten mehrere GUI-Beschreibungen eingebunden sein, in denen
Komponenten mit demselben Namen definiert sind, muss die Bezeichnung der eingebundenen Ressource
zur eindeutigen Identifikation in der Referenz stehen (siehe Listing
\ref{LST_Override2_2}) 
\begin{lstlisting}[{caption=2. Iteration - Verändern von Komponenten
eingebundener GUI-Beschreibungen mit
Namensüberschneidung},{label=LST_Override2_2}] 
use: "guidescription.LabelAndButton" as: 'Embedded1' 
use: "guidescription.LabelAndTwoButton" as: 'Embedded2' 
REFINE Button with name: 'Embedded2.OverriddenButton':
	text='NewText'
END REFINE
\end{lstlisting}

Die dazugehörige Grammatik ist im Anhang \ref{AppGrammatiken} zu finden.



\section{3. Iteration}
\subsection*{Analyse der Metadaten des GUIs}
Um eine Referenzierung von \gks und dem entsprechenden Layout aus der
Layout-Datei zu ermöglichen, ist es wie bei den Properties notwendig, die
Layout-Datei innerhalb der GUI-Beschreibung anzugeben. Weiterhin wird in den
einzelnen Komponentendefinitionen ein Schlüssel benötigt, über den die
Komponente eindeutig referenziert werden kann. Dafür kann die Bezeichnung der
UI-Komponete verwendet werden. Um in der Layout-Datei nicht alle einzelnen
\gks unterscheiden zu müssen, wird innerhalb der GUI-Beschreibung
ein optionales Feld benötigt, mittels dessen unterschiedlichen \gks
dasselbe Layout zugeordnet werden kann. Dieser Schlüssel wird Layout-Schlüssel
genannt.\\
Da die Anzahl der Bereiche nicht mehr angegeben werden muss, fällt dies
auch aus den Metadaten den GUI-Beschreibung heraus. Die Zuweisung der
\gks zu den Bereichen entfällt ebenfalls. Die Strukturierung wird über
eine Aufzählung der \gks vorgenommen.\\
Zusammenfassend die benötigten Metadaten für die GUI-Beschreibung die folgenden.
\begin{itemize}
  \item  Typ
  \item  Properties-Dateien
  \item  Layout-Dateien
  \item  Eingebundene GUI-Beschreibungen
  \item  Veränderte eingebundene Komponentendefinitionen
  \item  Komponentendefinitionen 
  \item  Struktur
\end{itemize}
\noindent
Alle Komponentendefinitionen und die Veränderten eingebundenen
Komponentendefinitionen benötigen durch die o.g. Änderung folgende Metadaten.
\begin{itemize}
  \item  Bezeichnung
  \item  Property-Schlüssel (optional)
  \item  Layout-Schlüssel (optional)
  \item  Interaktionen (optional)
\end{itemize}
\noindent
Mit den konkreten Kompnentendefinitionen müssen mehrere \Ks beschrieben
werden können. \Ks die spezielle Metadaten benötigen sind mit diesen in
folgender Tabelle aufgelistet.
\begin{table}[H]
\centering
\small
\begin{tabular}[c]{|l|l|}
			\hline
			\hline
				\textbf{\K} & \textbf{Spezielle Metadaten}\\
				\hline\hline
				Label & 
  		  				Aufschrift
				 \\
				\hline
				Button & 
  		  Aufschrift
  		  \\
				\hline
				Textfield &  
  		  Text, Editierbarkeit
  		  \\
				\hline
				Textarea  &  
  		  Text, Editierbarkeit
  		   \\
				\hline
				Tree &  
  		  Input-Modell
  		  \\
				\hline
				Table &  
  		  Input-Modell
  		  \\
				\hline
				TabPane &  
  		  GUI-Beschreibungen für die einzelnen Tabs
  		  \\
				\hline
				\hline
			\end{tabular} 
 \caption{Bewertung der Frameworks für die Entwicklung von DSLs}
 \label{tab_bewertung}
\end{table}
Von diesen Metadaten sind alle bis auf die des TabPanes optional.

\subsection*{Semantisches Modell} 
Das semantische Modell hat sich durch die vielen Änderungen in dieser Iteration
ebenso stark verändert. Bei der Betrachtung der \emph{UIDescription} (siehe
Abbildung \ref{Abb_I3_1}) fällt auf, dass \emph{Area} und \emph{AreaCount} nicht mehr
vorhanden sind. Hinzugekommen sind \emph{Structure} (worin die Anordnung der
\gks (\emph{Element}) in einer Liste abgelegt wird) und Layout
(worin die zu verwendenen Layout-Dateien in einer Liste abgelegt werden).
Eine weitere Änderungen ist bei \emph{Property} zu finden. Dort ist ebenfalls
eine Liste vorhanden und kein allein stehender Wert.
\myBigFigure{v3-1.jpg}{3. Iteration: UIDescription}{I3_1}
\noindent
An \emph{TypeDefinition} und \emph{UsedDescription} wurden keine signifikanten
Änderungen vorgenommen. Die meisten Änderungen wurden bei den Artefakten
\emph{Refinement} und \emph{Definition} vorgenommen. Der Aufbau der dieser
Artefakte ist ähnlich. Das Interface (\emph{Refinement} und \emph{Definition})
wird von einer Klasse implementiert (\emph{RefinementImpl} und
\emph{DefinitionImpl}), die mehrere Objekte eines bestimmter Klassen,
die das Interface \emph{ComponentRefinement} oder \emph{ComponentDefinition}
implementieren, enthält. In Abbildung \ref{Abb_I3_2} ist diese Struktur für die
\emph{Definition} abgebildet.
\myBigFigure{v3-2}{3. Iteration: Definition}{I3_2}
\noindent
Die benannten Klassen bilden die unterschiedlichen \Ks ab, die
definiert oder verändert werden können. Jede dieser Klassen aggregiert ein
Objekt des Typen \emph{CommonProperties} ein. Dieses Interface bilder die
allgemeinen Properties ab. Bei den \Ks Label, Button, Textfield und Textarea ist
diese Aggregation transitiv, da die speziellen Properties dieser \Ks als eigenes
Artefakt implementiert sind. Abbildung \ref{Abb_I3_3} zeigt dies für einen
Button auf.
\myBigFigure{v3-3.jpg}{3. Iteration: Button}{I3_3}
\noindent
Eine direkte Aggergation der \emph{CommonProperties} findet bei den \Ks TabView,
Table und Tree statt. Für die speziellen Properties dieser \Ks existieren keine
einelnen Klassen. Die folgenden Abbildungen zeigen diese drei \Ks
(\emph{Refinement} und \emph{Definition}) mit der Aggregation der
\emph{CommonProperties}. Um die Übersicht zu bewahren werden die Methoden der
Klassen nicht mit aufgeführt.
\myBigFigure{v3-4.jpg}{3. Iteration: TabView}{I3_4}
\noindent
Die \K TabView benötigt eine Menge von \emph{TabDefinition}s. Diese Klasse
bildet die Referenz zu den in die TabView einzubindenen \gks.
Die \Ks Tree und Table benötigen lediglich eine Referenz auf den Input-Typen,
den sie abbilden sollen, in Form einer Zeichenkette (siehe Abbildung
\ref{Abb_I3_5} und \ref{Abb_I3_6}).
\myBigFigure{v3-5.jpg}{3. Iteration: TabView}{I3_5}
\myBigFigure{v3-6.jpg}{3. Iteration: TabView}{I3_6}
\subsection*{Konkrete Syntax} Die syntaktischen
Konstrukte wurden in dieser Iteration stark vermehrt. Das liegt vor allem daran, dass viele neue \Ks hinzugekommen sind. Der
Grundsätzliche syntaktische Aufbau einer GUI-Beschreibung hat sich jedoch nicht
verändert. Eingeleitet wird die Beschreibung weiterhin mit der Typ-Definition,
gefolgt von der Angabe der Properties-Dateien. Sofern mehrere Properties-Dateien
vorhanden sind, werden diese mit Komma getrennt voneinander aufgezählt. Dasselbe
Prinzip wird bei der sich anschließenden Angabe der Layout-Dateien verwendet.
Das Semikolon gilt ab sofort als Trennzeichen für einen abgeschlossen
definierten Komplex (sieh Listing \ref{LST_PropertiesLayout3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Properties- und Layout-Dateien},{label = LST_PropertiesLayout3}] 
type: INNERCOMPLEX;
get properties from:'properties1', 'properties2';
get layout from:'layout1','layout2';
\end{lstlisting}
Für die eingebundenen GUI-Beschreibungen bzw. \kks wurden keine
großen syntaktischen Veränderungen vorgenommen. Lediglich das Semikolon wird für
den Abschluss des Komplexes benötigt (siehe Listing \ref{LST_Use3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Eingebundene \gks},{label = LST_Use3}] 
use: Multiselection<Input> as: "multi";
\end{lstlisting}
Die Definitionen der einzelnen \Ks hat sich syntaktisch stark verändert. Grund
dafür ist vor allem, dass die Anforderung Nr. 5 (siehe Kapitel
\ref{AllgAnforderungen}) mehr Beachtung finden soll. Somit werden die bekannten
\Ks wie folgt definiert (siehe Listing \ref{LST_Bt+Lb3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Button und Label},{label = LST_Bt+Lb3}] 
Button as: "Button" -> propertyKey='buttonproperty' layoutKey='buttonlayout'
interactiontype=IfViewImage text='buttontext';

Label as: 'Label' -> propertyKey='labelproperty' layoutKey='labellayout'
interactiontype=IfActivator text='labeltext';
\end{lstlisting}
Bei den Definitionen der anderen \Ks werden die allgemienen Properties wie im
vorherigen Beispiel zugewiesen. In den Fällen der \Ks Textflied und Textarea
werden die speziellen Properties nach demselben Prinzip definiert (siehe Listing \ref{})
\begin{lstlisting}[{caption = 3.
Iteration:
Textfield und Textarea},{label = LST_Tf+Ta3}] 
Textfield as: 'Textfield' -> propertyKey='textfieldproperty'
layoutKey='textfieldlayout' interactiontype=IfActivator 
text='textfieldtext' editable=TRUE;

Textarea as: 'Textarea' -> propertyKey='textareaproperty'
layoutKey='textarealayout' interactiontype=IfActivator 
text='textareatext' editable=TRUE;
\end{lstlisting}
Die Syntax für die Definition der \Ks Table und Tree sind ebenfalls ähnlich. Der
benötigte Input-Typ wird nach dem Schlüsselwort angegeben, welches die
UI-Komponente bestimmt (siehe Listing \ref{LST_T+T3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Table und Tree},{label = LST_T+T3}] 
Table<tablemodel> as: 'Table' -> propertyKey='tableproperty'
layoutKey='tablelayout' interactiontype=IfActivator;

Tree<treemodel> as: 'Tree' -> propertyKey='treeproperty'
layoutKey='treelayout' interactiontype=IfActivator;
\end{lstlisting}
Die \Ks TabView werden die verwendeten \gks der einzelnen Tabs
ebenfalls nach dem Schlüsselwort angegeben, welches die UI-Komponente festlegt.
Hierbei können anderes als bei den \Ks Table und Tree mehrere Angaben getätigt
werden (siehe Listing \ref{LST_Tab3}). In den folgenden Beispiele wird davon
ausgegange, dass die vorher genannten Beispiele für die \Ks Tree, Table und Textarea in
derselben GUI-Beschreibung definiert wurde. Durch das syntaktische Konstrukt in
Listing \ref{LST_Tab3} wird eine Tab-Ansicht mit drei Tabe beschrieben. Das
erste Tab enthält den Tree, das zweite die Table und das dritte die Textarea.
\begin{lstlisting}[{caption = 3.
Iteration:
TabView},{label = LST_Tab3}] 
TabView[Tree][Table][Textarea] as: 'tabview' -> propertyKey='tabviewproperty'
layoutKey='tabviewlayout' interactiontype=IfViewImage;
\end{lstlisting}
Dabei ist zu erwähnen, dass die Angabe der Properties in den meisten
Fällen optional ist. Lediglich die speziellen Properties der \Ks Table, Tree und
TabView müssen zwingend angegeben werden.\\
Die Syntax zur Veränderung einer \K einer eingebundenen GUI-Beschreibung ähnelt
der Definition einer \K des gleichen Typs. Es muss lediglich angegenben werden,
welche \gks in welcher GUI-Beschreibung verändert werden soll.
Folgendes Beispiel zeigt, wie die Aufschrift eines Buttons einer eingebundenen
GUI-Beschreibung verändert wird (siehe Listing \ref{LST_Refine3}). Der Button
trägt die Bezeichnung \emph{EmbeddedButton} und die
GUI-Beschreibung liegt im Package
\emph{guidescription} und trägt die Bezeichnung
\emph{Embedded}.
\begin{lstlisting}[{caption = 3.
Iteration:
TabView},{label = LST_Refine3}] 
use: "guidescription.Embedded" as: "embedded";
Button change:'embedded.EmbeddedButton' -> text='Neuer Text';
\end{lstlisting}

Der letzte Teil einer GUI-Beschreibung beinhaltet die Angabe der Struktur. Diese
Angabe ähnelt der Zuweisung von \gks zu Bereichen, wie es auch der
ersten und zweiten Iteration bekannt ist. Da dieses Konstrukt vereinfacht werden
sollte, werden die \gks in der richtigen Reihenfolgen nach dem
Schlüsselwort \emph{Structur} aufgezählt (siehe Listing \ref{LST_Structure3}).
\begin{lstlisting}[{caption = 3.
Iteration:
Struktur},{label = LST_Structure3}] 
Structure:'Button','Label','Textfield','tabview';
\end{lstlisting}