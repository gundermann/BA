\chapter{Entwicklung einer DSL zur Beschreibung der GUI in profil c/s}\label{Entwicklung einer DSL zur Beschreibung der GUI in profil c/s}
\section{1. Iteration}
\subsection*{Analyse der Metadaten der GUI}
Die Beschreibung einer GUI wird in der Sprache als eigener Komplex betrachtet
(siehe semantisches Modell \emph{Definition}). Innerhalb dieses Komplexes werden
die entsprechenden Komponenten definiert. Die Bereiche die innerhalb einer
Beschreibung festgelegt werden sollen, müssen UI-Komponenten zugeordnet werden
können (siehe semantisches Modell \emph{AreaAssignment}). Diese Bereiche
sollten vor der Entwicklung bereits festgelegt werden. Um abzusichern, dass die 
die Anzahl der festgelegten Bereiche genau eingehalten wird, muss diese
Anzahl in der GUI-Beschreibung angegeben werden (siehe semantisches Modell
\emph{AreaCount}).\\
Für die Beschreibung der Layout-Komponenten werden zwei Typen unterschieden
(siehe semantisches Model \emph{TypeDefinition}).\\
Ein weiterer Aspekt in GUI-Beschreibung ist die Verwendung von anderen
GUI-Beschreibungen (siehe semantisches Modell \emph{Use}).\\ 
Zusammenfassend sind für die Beschreibung der GUI folgende Metadaten nötig.
\begin{itemize}
  \item [] Anzahl der Bereiche
  \item [] Zuweisung der UI-Komponenten zu den Bereichen
  \item [] Angabe des Layout-Typs
  \item [] Angabe der Verwendeten GUI-Beschreibungen
  \item [] Definition von UI-Komponenten
\end{itemize}
Die Definition der UI-Komponenten nehmen einen eigenen Komplex innerhalb der
GUI-Beschreibung ein. 
Bezogen auf die \Ks des UIs ist die
Beschreibung eines Textes wichtig. Im Falle eines Buttons oder eines Labels
(andere \Ks sind in dieser Iteration nicht umgesetzt) beschreibt
dieser die Aufschrift der Komponente.
Weiterhin ist es für die Zuweisung zu einem Bereich wichtig, dass
diese Komponenten innerhalb der Datei referenziert werden können. Daher muss
für jede UI-Komponente eine Bezeichnung definiert werden, die innerhalb der
Datei eindeutig ist.\\
An den \Ks können darüber
hinaus Interaktionen beschrieben werden. Hierzu sind Informationen über den
Interaktionstyp nötig.
Der einzige, in dieser Iteration umgesetzte, Interaktionstyp ist ein Klick auf
die Komponente. An dieser Interaktion können ebenso Aktionen definiert werden, die Auswirkungen auf andere Komponenten haben.
Zusammenfassend ergeben sich folgende Meta-Daten der \Ks.
\begin{itemize}
  \item[] Typ
  \item[] Bezeichnung
  \item[] Text
  \item[] Interaktion (siehe semantisches Modell \emph{Interaction})
\end{itemize}
Die Interaktion benötigt folgende Attributen, die beschrieben werden müssen.
\begin{itemize}
  \item[] Bezeichnung
  \item[] Interaktionstyp
  \item[] Aktion
\end{itemize}
Aktionen nehmen wiederum einen eigenen Komplex innerhalb der
Komponentendefinition ein. Dabei werden folgende Informationen benötigt.
\begin{itemize}
  \item[] Aktions-Typ\\
  Zur Unterscheidung zwischen Interaktionen mit anderen UI-Komponenten oder
  fachlichen Modellen
  \item[] Element\\
  Ein Verweis auf das Element, mit dem interagiert werden soll.
  \item[] Attribute (siehe semantisches Modell \emph{Property})\\
  Die zu veränderden Attribute des Elements.
\end{itemize}
Die \knks werden in einer eigenen Komponentendefinition beschrieben. Grund dafür
ist, dass neben den vordefinierten Funktionalitäten der \knks auch weitere
optionale Wertzuweisungen möglich sein sollen. Dazu wird nach der Implementierung
der Komponente für jedes Framework ein neues Schlüsselwort für eine
Komponentendefinition in die Grammatik eingebaut. Jede komplexe Komponente
darüber hinaus eine Bezeichnung um referenziert zu werden. In dieser
Iteration ist eine \gloss{Multiselection-Komponente} umgesetzt. Diese Komponente
ist generisch implementiert. Der generische Typ muss innerhalb der
Komponenten in der GUI-Beschreibung definiert werden. Ebenso müssen die
Werte, die in dieser Komponente selektiert werden können, angegeben werden.
Zusätzlich sollen optional auch die Werte angegeben werden, die bereits
selektiert wurden.


\subsection*{Semantisches Modell}
\myBigFigure{v1-1.jpg}{Teil 1: GUI-Beschreibungs-Model Version 1}{Teil1-1}
Das Artefakt, welches beim dieserm Model im Mittelpunkt steht ist die
\emph{UIDescription} (siehe \ref{Abb_Teil1-1}). Bezüglich der Methoden sind
im Allgemeinen nur Getter- und Setter-Methoden des semantischen Modells für
diese Arbeit von Belang. Die aggregierten Artefakte sind aus dem Diagramm gut zu
entnehmen.
Die Klasse \emph{DefinitionImpl} aggregiert weitere Artefakte des Modells. Diese sind um
die Übersicht zu wahren Abbildung \ref{Abb_Teil2-1} zu entnehmen.\\
\myBigFigure{v1-2.jpg}{Teil 2:
GUI-Beschreibungs-Model Version 1}{Teil2-1} 
Dort sind die drei umgesetzten Ausprägungen einer \emph{Definition} zu erkennen.
Dabei handelt es sich um \emph{Label}, \emph{Button} und \emph{MultiSelection}.
Weiterhin ist zu erkennen, dass nur der Button eine \emph{Interaction}
aggregieren kann. Das bedeutet, dass nur an dieser Komponente eine Interaktion
beschrieben werden kann. Das Artefakt \emph{Property} ist der letzte
interessante Teil. Dieses Interface wird benötigt um bestimmte Werte an
Komponenten zu setze, ohne das Wissen zu müssen um welchen Komponententyp es
sich handelt.
Dazu wurden die allgemein gültigen Einstellungsmöglichkeiten von \Ks in
\emph{CommonProperty} zusammengefasst. Die Klasse \emph{PropertyImpl} ist ein Artefakt, welches zur Vollständigkeit des
Modells erzeugt wurde. Es erfüllt für diese Version jedoch keinen weiteren
Zweck.

\subsection*{Konkrete Syntax}
\begin{lstlisting}[caption =1. Iteration: Syntax][label = LST_Syntax1]
Area count: 4
type: WINDOW use: "AnotherDescription"
DEF Label as "HEAD" :
END DEF
DEF Button as "Interactbt": 
	text="Interagiere"
	interaction="btinteraction" type=CLICK with actions:type=UiAction element="HEAD":Text="Du hast interagiert"
END DEF
DEF MultiSelection as "Multiselect" :
	inputType="valuepackage.Values" 
	selectableValues="valuepackage.Values.asList()"
END DEF
Area:1<-"HEAD"
Area:2<-"AnotherDescription"
Area:3<-"Interactbt"
Area:4<-"Multiselect"
\end{lstlisting}
Die Bezeichnung \emph{Area} wurde bewusst so gewählt, da dieser Begriff
abstrakter ist als die in verschiedenen UI-Frameworks verwendeteten Begrifft
wie, Panel oder Pane. In der Syntax dieser DSL gilt es sich vor allem bzgl. des
Aufbaus der GUI an keinem UI-Framework zu orientieren. Die einzelnen
Komponentendefinitionen werden durch das Schlüsselwort \emph{DEF} eingeleitet
und durch das Schlüsselwort \emph{END DEF} abgeschlossen. Der Definitionskopf
wird durch das Zeichen \emph{:} beendet. Dort sind die Pflichtfelder der
Komponentendefinition zu finden (\emph{Titel} und \emph{Typ}).
Bei der Multiselection-Komponente fällt auf, dass ein Referenzwert verwendet
wird, der in dieser Beschreibung nicht deklariert wurde (\emph{valuespackage.Values}).
Dabei handelt es sich um einen qualifizierten Namen einer Klasse.\\
Die dazugehörige Grammatik befindet sich im Anhang
\ref{AppGrammatiken}.





\section{2. Iteration}

\subsection*{Analyse der Metadaten der GUI}
Für die Metadaten der GUI-Beschreibung werden muss in dieser Iteration eine Properties-Datei angegeben werden, in der bestimmte Werte
für die Attribute der UI-Komponenten enthält.\\
Da die Möglichkeit bestehen soll die, in den eingebundenen GUI-Beschreibungen
definierten, Komponenten in dieser Iteration zu verändert, wird eine weitere
Ergänzung für die GUI-Beschreibung benötigt. Diese Veränderungen sollen sich von
der Komponentendefinition abgrenzen, damit für nicht überschriebene Werte auf
die eingebundene GUI-Beschreibung zurückgegriffen werden kann (siehe
semantisches Modell \emph{Refinement}). Um die eindeutige Referenzierung zu
ermöglichen muss bei der Bezeichnung der eingebundenen GUI-Beschreibung sowie
bei der veränderten Komponente der qulifizierte Name angegeben werden.\\
Bei den Interaktionen der \Ks fällt die Aktion komplett weg. Somit muss nur noch
der Interaktionstyp angegeben werden.\\
In den Definitionen der \Ks muss aufgrund des Properties-Konzeptes die
Möglichkeit bestehen, einen Property-Schlüssel anzugeben. Alle anderen Metadaten
für die \Ks bleiben bestehen.\\
Bezogen auf die \knks ist es lediglich notwendig
den Input-Typ anzugeben. Die Festlegung über selektierbare und
selektierte Elemente in der Multiselection-Komponente wird nicht benötigt. Das
ermöglicht, die \knks mittels \emph{use} (siehe semantisches Model
\emph{UsedDefinitions}) in die GUI-Beschreibung einzubinden (siehe konkrete
Syntax).


\subsection*{Semantisches Modell}
In dieser Version wurden an den Artefakten \emph{AreaCount},
\emph{TypeDefinition} und \emph{AreaAssignment} keine Änderungen vorgenommen.
Artefakte wie \emph{Property} und \emph{Refinement} sind hinzugekommen. Die
weiteren Artefakte, die von \emph{UIDescriptionImpl} aggregiert werden
(siehe Abbildung \ref{Abb_Teil2-1}), wurden verändert.
\myBigFigure{v2-1.jpg}{Teil 1: GUI-Beschreibungs-Model Version 2}{Teil1-2}
Das Artefakt \emph{Property} bildet die Property-Datei ab. Sie ist nicht zu
verwechseln mit dem Artefakt \emph{Properties}, welches die Eigenschaften von
Komponenten abbildet. Abbildung \ref{Abb_Teil2-2} zeigt beide Artefakte auf.
\myBigFigure{v2-2}{Teil 2: GUI-Beschreibungs-Model Version 2}{Teil2-2}
Die \emph{UsedDescription} enthält in dieser Version einen
\emph{DefinitionType}.
Dieser bestimmt, ob es sich bei der importierten Komponente um ein
beschriebenes GUI handelt, oder um eine komplexe Komponente, für die ein
Input-Typ (\emph{inputType}) festgelegt werden kann.
\myBigFigure{v2-3}{Teil 3: GUI-Beschreibungs-Model Version 2}{Teil3-2}
Zwischen \emph{Definition} und \emph{Refinement} wird unterschieden. Die
\emph{Definition} bildet neu definierte Komponenten für das GUI ab. Ein
\emph{Refinement} hingegen bildet die veränderten Komponenten importierter
GUIs ab (siehe Abbildung \ref{Abb_Teil4-2} und Abbildung \ref{Abb_Teil5-2}).
\myBigFigure{v2-4}{Teil 4: GUI-Beschreibungs-Model Version 2}{Teil4-2}
\myBigFigure{v2-5}{Teil 5: GUI-Beschreibungs-Model Version 2}{Teil5-2}



\subsection*{Konkrete Syntax}
Die einfachste der Veränderungen bzgl. der Syntax in Version 2 ist die
festlegung der Properties-Dateien. Um eine Properties-Datei einzubinden muss,
wie in Listing \ref{LST_Properties2}, eine entsprechende
Datei festgelegt und in den Komponenten entsprechende Schlüssel vergeben
werden. Das Label mit der Bezeichnung \emph{OneLabel} enthält keinen
Property-Key.
In diesem Fall wird der Titel als solcher verwendet.
\begin{lstlisting}[{caption = 2. Iteration: Properties},{label =
LST_Properties2}] 
type: WINDOW 
get properties from: 'sources.ui.properties' 
DEF Label as "OneLabel" END DEF
DEF Label as "AnotherLabel":
	propertyKey='AnotherLabel2'
END DEF
\end{lstlisting}
Aufgrund der Reduzierung der Meta-Daten für eine Interaktion stand die Frage
offen, ob die Interaktionstypen einfach hintereinander mit Komma, oder untereinander mit dem
entsprechenden Schlüsselwort aufgezählt werden sollen. Aufgrund der Tatsache,
dass in der deg höchstens 4 Interaktionstypen in einer Komponente verwendet
werden, werden diese in der GUI-Beschreibung per DSL hintereinander mit Komma
aufgezählt, wie in Listing \ref{LST_Interaktion2} zu erkennen ist.
\begin{lstlisting}[{caption=2.
Iteration: Interaktion},{label=LST_Interaktion2}] DEF Button as
"InteractButton":
	interactiontype=Click,ChangeText
END DEF
\end{lstlisting}
Die komplexen Komponenten werden wie in Listing \ref{LST_Komplexe2} mit
der Komponente Multiselection gezeigt ist, über das Schlüsselwort \emph{use}
eingebunden werden.
Der Input-Typ kann dabei optional innerhalb der Zeichen \emph{<} und \emph{>}
angegeben werden.
\begin{lstlisting}[{caption=2. Iteration: Definition komplexer
Komponenten},{label=LST_Komplexe2}] type: WINDOW 
use: Multiselection<'valuepackage.Values'> as: 'Multi'
\end{lstlisting}
Für die Zuweisung mehrer Komponenten zu den Areas kamen zwei Lösungen in
Betracht. Bei der einen finden die Definitionen der Komponenten zusammen mit der
Zuweisung zu dem Area statt. Dies könnte bspw. wie in Listing \ref{LST_Moeglichkeit1_2}
dargestellt werden.
\begin{lstlisting}[{caption=2. Iteration: Area-Zuweisung
(1)},{label=LST_Moeglichkeit1_2}] 
Area count: 1 type: WINDOW 
Area:1={
DEF Button as "Button:
	text="Button"
END DEF
DEF Label as "Label":
	text="Label"
END DEF
}
\end{lstlisting}
Eine andere Möglichkeit wäre es, die aktuelle Form der Zuweisung zu verfeinern
und somit die Komponenten bei der Zuweisung mit Komma getrennt von einander
aufzählen. Die erste Möglichkeit würde sich sehr gut eignen, wenn nur die in der
Datei definierten Komponenten dem Area zugewiesen werden müssten. Da die mit
\emph{use} eingebundenen Komponenten auch Areas zugeordnet werden, würde für
dieses Verfahren ein zusätzliches syntaktisches Konzept innerhalb der Area-Zuweisung
benötigt werden. Um dies zu umgehen wurde die Entscheidung getroffen, das alte
Verfahren zu verfeinern. Listing \ref{LST_Moeglichkeit2_2} ist ein Beispiel für die
Area-Zuweisung von drei Komponenten zu entnehmen.
\begin{lstlisting}[{caption=2. Iteration: Area-Zuweisung
(2)},{label=LST_Moeglichkeit2_2}]
Area count: 1
type: WINDOW 
DEF Label as "OneLabel" END DEF
DEF Label as "AnotherLabel" END DEF
DEF Button as "InteractButton": 
	interactiontype=Click,ChangeText
END DEF
Area:1<-"OneLabel","InteractButton","AnotherLabel"

\end{lstlisting}
Das Überschreiben der Werte von Komponenten, die in einer eingebundenen
GUI-Beschreibung definiert wurden, können über das Schlüsselwort \emph{REFINE}
getätigt werden. Der erste Teil von Listing \ref{LST_Override2} zeigt die Originaldatei,
deren Beschreibung eingebunden wird. Diese trägt den Namen \emph{LabelAndButton}
und befindet sich im Package \emph{guidescription}. Der zweite Teil zeigt, wie
die Aufschrift einer Komponente \emph{Button} überschrieben wird.
\begin{lstlisting}[{caption=2. Iteration: Verändern von Komponenten
eingebundener GUI-Beschreibungen},{label=LST_Override2}] 
PART 1 Area count: 2
type: INNERCOMPLEX
DEF Label as "Label" :
	text="Text" 
END DEF
DEF Button as "Button":
	text="AlterText" 
END DEF
Area:1<-'Label'	
Area:2<-"Button"


PART 2
Area count: 1
type: WINDOW 
use: "guidescription.LabelAndButton" as: 'Embedded'
REFINE Button with name: 'Button':
	text='NewText'
END REFINE
Area:1<-'Embedded'
\end{lstlisting}
Sollten mehrere GUI-Beschreibungen eingebunden sein, in denen
Komponenten mit demselben Namen definiert sind, muss die Bezeichnung der eingebundenen Ressource
zur eindeutigen Identifikation in der Referenz stehen (siehe Listing
\ref{LST_Override2_2}) 
\begin{lstlisting}[{caption=2. Iteration - Verändern von Komponenten
eingebundener GUI-Beschreibungen mit
Namensüberschneidung},{label=LST_Override2_2}] 
use: "guidescription.LabelAndButton" as: 'Embedded1' 
use: "guidescription.LabelAndTwoButton" as: 'Embedded2' 
REFINE Button with name: 'Embedded2.OverriddenButton':
	text='NewText'
END REFINE
\end{lstlisting}

Die dazugehörige Grammatik ist im Anhang \ref{AppGrammatiken} zu finden.







