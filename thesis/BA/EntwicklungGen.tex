\chapter{Entwicklung des Generators für das Generieren von Klassen für
das Multichannel-Framework}\label{Entwicklung des Generators für das Generieren von Klassen für
das Multichannel-Framework}
Alle Umsetzungen die in diesem beschrieben werden, fanden in der 3. Iteration
statt. Von daher wird in den folgenden Kapitel nicht mehr zwischen
Iterationen unterschieden.\\
Ziel ist es mit dem Generator und einem entsprechenden DSL-Skript eine
Exploreransicht zu erststellen, wie sie in profil c/s geläufig ist. Abbildung
\ref{Abb_ee} zeigt ein solches GUI. Darin enthalten sind zwei Bäume (auf der
linken Seite) und ein CardPanel (auf der rechten Seite), worin der Inhalt der
Ausgewählten Elemente der Bäume angezeigt werden soll. Das Anzeigen des Inhalts
wird jedoch nicht umgesetzt.
\myBigFigure{explorerbaum.jpg}{Einfacher Explorer}{ee}
Die notwendigen DSL-Skripte werden bei der Umsetzung vorgestellt.
\section{Beschreibung der GUI- und IP-Klassen}
Durch die Beschreibung der GUIs mit der entwickelten DSL, ist es möglich die
GUI- und die IP-Klassen (siehe Kapitel \ref{Analyse}) zu generieren. Die
GUI-Klasse soll dabei vollständig generiert werden. Zur Umsetzung dessen, werden
Informationen über das Layout aus der Layout-Datei benötigt. Die Umsetzung
und Einbindung dieser Datei nicht in dieser Arbeit nicht behandelt. Aus
diesem Grund wird in dem Generator ein Layout festgelegt. Die IP-Klasse soll nur
teilweise generiert werden. Somit unterteilt sich das folgende
Kapitel in zwei Abschnitte (GUI-Klasse und IP-Klasse).\\
In den GUI-Klassen der deg sind die UI-Komponenten durch
\emph{Präsentationsformen} beschrieben (siehe Kapitel \ref{Analyse}). Alle
UI-Komponenten sind in diesen Klassen global zugreifbar, da sie in
Instanzvariabeln abgelegt werden. Die Instanzvariablen stehen bei der deg am
Ende der Klasse. Die bestehende Struktur der GUI-Klassen nicht verändert
werden soll. Beim Implementieren des Generators muss darauf geachtet werden.
Da die Interaktion von der Präsentation getrennt ist, müssen zur
Referenzierung von Interaktionen zu UI-Komponenten entsprechende Schlüssel
vergeben werden.\\
Die IP-Klassen ordnen den UI-Komponenten mit Hilfe dieses Schlüssels
entsprechende Interaktionen zu. Was genau bei der Interaktion gesehen soll, kann
vom Generator nicht erzeugt werden. Dies muss vom Entwickler nachgepflegt
werden.\\ 
In beiden Fällen handelt es sich in dieser Arbeit um Transformer Generation
(siehe Kapitel \ref{Domänenspezifische Sprachen}). In Bezug auf die IP-Klassen
ist auch die Templated Generation (siehe Kapitel \ref{Domänenspezifische
Sprachen}) in Erwägung zu ziehen. Um bei der Art der Generation einheitlich zu
sein, wird auf diese Möglichkeit nicht weiter eingegangen.
\section{Umsetzung des frameworkspezifischen Generators}
\subsection*{GUI-Klasse}
Bei Betrachtung der Präsentation aus Abbildung \ref{Abb_ee} können die
Baumstrukturen auf der linken Seite als eine GUI-Beschreibungen betrachtet
werden, die mit zwei fachlichen Konzepten Assoziiert werden können. Der obere
Baum kann mit dem fachlichen Konzept des Inhaltsbaumes in Verbindung gebracht
werden und der untere mit dem des Verweisebaums. Da sich die fachlichen Konzepte
erkennen lassen, sollten separate GUI-Beschreibungen erstellt werden (siehe
Listing \ref{LST_Inhaltsbaum} und \ref{LST_Verweisebaum}.
\begin{lstlisting}[{caption = GUI-Beschreibung Inhaltsbaum},{label =
LST_Inhaltsbaum}]
type: INNERCOMPLEX;
Label as: 'kopfzeile'->text='Inhaltsbaum';
Tree[testwerkzeuge.modelle.InhaltsModell] as: 'inhaltsbaum';
Structure:'kopfzeile','inhaltsbaum';
\end{lstlisting}
\begin{lstlisting}[{caption = GUI-Beschreibung Verweisebaum},{label =
LST_Verweisebaum}]
type: INNERCOMPLEX;
Label as: 'kopfzeile'->text='Verweisebaum';
Tree[testwerkzeuge.modelle.VerweiseModell] as: 'verweisebaum';
Structure:'kopfzeile','verweisebaum';
\end{lstlisting}
Bei der Generierung betrachtet Xtext eine GUI-Beschreibung immer im Ganzen. Für
jede GUI-Beschreibung soll eine eigene Klasse angelegt werden. Die Klassen
enthalten in diesen beiden Fällen zwei globale Variablen. Darüber hinaus
enthalten sie Importe, die am Anfang der beiden Klassen stehen. Um die Importe
an diese Stelle zu schreiben, ist es notwendig die GUI-Beschreibung auf benötigte Importe zu
untersuchen und zu diese zu speichern (siehe Listing \ref{LST_Importe}).
\begin{lstlisting}[{caption = Speichern der Importe},{label =
LST_Importe}]
def addImport(String newImport) {
		if (!imports.contains(newImport)) {
			imports.add(newImport)
		}
	}
\end{lstlisting}
 Von daher wird der
generierte Quell-Code nicht sofort in die Datei geschrieben, sondern
zwischengespeichert. So ist es möglich die Importe an den Anfang der Datei zu
schreiben.\\
Die globalen Variablen werden zusammen mit den Importen generiert und in eine
separate Varialbe angespeichert (siehe Listing \ref{LST_GlobalVars}).
\begin{lstlisting}[{caption = Speichern der globalen Varialben},{label =
LST_GlobalVars}]
def addGlobalVar(String globalVar) {
		if(!globalVars.contains(globalVar))
			globalVars.add(globalVar)
	}
\end{lstlisting}
Dadruch
ist es möglich diese hinter die generierten Methoden zu schreiben.\\
Zu Beginn einer Generierung muss zwischen den Typen der GUI-Beschreibung
unterschieden werden. Je nachdem wird die Beschreibung als \emph{Window} oder
\emph{Innercomplex} compiliert und benötigt entsprechende Importe. In den Fällen
der o.g. Bäume wird eine Innercomplex compiliert. Der Klassenkopf und der
Konstruktor werden wie folgt erzeugt (siehe Listing \ref{LST_HeadComplex}).
\begin{lstlisting}[{caption = Klassenkopfgenerierung für einen
Innercomplex},{label = LST_HeadComplex}]
	def compileComplex(UIDescription description) '''
		«addImport("import DE.data_experts.jwammc.core.pf.PfPanel;")»
		public class «guiFilename» extends PfPanel{

		«description.genRest»
		}	
	'''
	
	def genRest(UIDescription description)'''
		«addImport("import java.awt.BorderLayout;")»
		public «guiFilename»(){
				super( new BorderLayout() );
				try {
     				init();
     			}
    			catch ( Exception e ) {
     				 e.printStackTrace();
   				 }
			}
	
		«description.init»
		/**
		* Generated global variables.
		*/
		«genGlobalVars»
	'''
\end{lstlisting}
In dieser Methode wird festgelegt, dass sich die UI-Komponenten auf einem
Border-Layout anordnen. Wenn die Layout-Datei verwendet wird, muss der Generator
aus dem Inhalt dieser Datei auf einen entsprechenden Layout-Container
schließen können. Zum Abschluss dieser Methode werden zwei weitere Methoden
aufgerufen.
Die erste (\emph{descrition.init}) generiert die im Konstruktor aufgerufene init-Methode.
Die andere ist für die Generierung der globalen Variablen zuständig.\\
In der Init-Methode werden alle UI-Komponenten und das Layout definiert. Da für
das Layout in dieser Arbeit keine Beschreibung existiert,
müssen diese Angaben nachgepflegt werden. Die Definition
der UI-Komponenten mit ihren Properties können jedoch
erzeugt werden. Listing \ref{LST_Init} zeigt die Init-Methode zum
ohne Rücksicht auf das Layout.
\begin{lstlisting}[{caption = Init-Methode},{label =
LST_Init}]
	def getInit(UIDescription description) '''
		public void init(){
						«FOR def : description.definitions»
								«def.compileComponent»
						«ENDFOR»
				}
	'''
\end{lstlisting}
In der Methode \emph{compileComponent} wird geprüft um welche UI-Komponente es
sich handelt. Diese wird anschließend compiliert, wobei der entsprechende
Quell-Code zur frameworkspezifischen Definition der Komponente generiert wird.
Im Fall des Labels werden der entsprechende Import, die globale Variable
hinzugefügt. Weiterhin muss die Referenz für die IP-Klasse definiert werden, da
Labels Standardinteraktionen besitzen. Letzlich müssen wenn vorhanden, die
Properties am Label gesetzt (siehe Listing \ref{LST_LabelGen}).
\begin{lstlisting}[{caption = Label-Generierung},{label =
LST_LabelGen}]
def compileLabel(LabelDefinition definition) '''
		«addImport("import DE.data_experts.jwammc.core.pf.PfLabel;")»
		«addGlobalVar("PfLabel " + definition.id + ";")»
		«definition.id» = new PfLabel();
		«definition.id».setIfName("«definition.id»");
		«IF definition.properties != null»
			«genProperty(definition.id, 'setText',definition.properties.text, true)»
		«ENDIF»
'''

def genProperty(String id, String method, String value, Boolean isString) '''
	«IF value != null»
		«IF isString»
			«id».«method»("«value»");
		«ELSE»
			«id».«method»(«value»);
		«ENDIF»
	«ENDIF»
	'''
'''
\end{lstlisting}
Die Eigenschafte aus den Properties-Dateien müssten an dieser Stelle noch
berücksichtigt werden.
Dies wurde aus Zeitgründen bei allen UI-Komponenten weggelassen.\\
Der Quell-Code für den Baum wird ähnlich generiert. Wenn der Input-Typ des
Baumes nicht gesetzt ist, muss ein Standard dafür eingesetzt werden. Desweiteren
muss für den Baum ein CellRenderer definiert werden (siehe Listing
\ref{LST_Tree}.
\begin{lstlisting}[{caption = Label-Generierung},{label =
LST_Tree}]
def compileTree(TreeDefinition definition)'''
		«addImport("import DE.data_experts.jwammc.core.pf.PfTree;")»
		«addImport("import DE.data_experts.jwammc.core.pf.TreeCellRenderer;")»
		«addImport("import DE.data_experts.jwammc.core.pf.PfTree;")»
			«addImport("import javax.swing.tree.DefaultTreeModel;")»
		«addGlobalVar("PfTree " + definition.id + ";")»
		«definition.id» = new PfTree();
		«definition.id».setIfName("«definition.id»");
		«IF definition.inputType == null»
			«addImport("import DE.data_experts.util.ObjectNode;")»
			«definition.id».setTreeModel( new DefaultTreeModel( new ObjectNode() ) );
		«ELSE»
			«definition.id».setTreeModel( new DefaultTreeModel( 
			new «definition.inputType.substring(1,definition.inputType.length-1)»() ) );
		«ENDIF»
			«definition.id».setCellRenderer( new TreeCellRenderer() );
'''
\end{lstlisting}
Allein durch die genannten Methoden kann der Generator die beiden DSL-Skripte
zur Beschreibung des Inhalts- und des Verweisebaums in GUI-Klassen
transformieren, die innerhalb der MCF ausgeführt werden können.\\
Die generierten Dateien (\emph{GuiInhaltsbaum.java} und
\emph{GuiVerweisebaum.java}) befinden sich im Anhang im Projekt \emph{Explorer}.
Abbildung \ref{Abb_Trees} zeigt die beiden GUIs, welche bei der Ausführung
der Generierten Dateien im Kontext von profil c/s erzeugt werden.
\myBigFigure{Trees.jpg}{Generierte GUI des Inhalts- und Verweisebaums}{Trees}
Um das Explorer-GUI zu generieren, müssen diese beiden Bäume zusammen mit einem
austauschbaren Bereich in einer GUI-Beschreibung definiert werden. Ein
DSL-Skript, welches dies umsetzt, sieht wie folgt aus (siehe Listing
\ref{LST_Skript_Explorer}.
\begin{lstlisting}[{caption=DSL-Skript für das
Exlporer-GUI},{label=LST_Skript_Explorer}] type: WINDOW;
use: "Inhaltsbaum" as: 'inhaltsbaum';
use: "Verweisebaum" as: 'verweisebaum';
Interchangeable Area as: "austauschbarerBereich";
Structure:'inhaltsbaum', 'verweisebaum', 'austauschbarerBereich';
\end{lstlisting}
Bei dem Typ handelt es sich dieses Mal um eine \emph{Window}. Der Generator muss
demnach eine andere Oberklasse bei der Generierung verwenden. Weiterhin muss auf
die beiden bereits generierten Klassen zugegriffen werden.\\
Da es sich um ein \emph{Window} handelt, wird in diesem Fall die Methode
\emph{compileWindow} aufgerufen. Der einzige Unterschied ist in diesem Fall die
Oberklasse (siehe Listing \ref{LST_complieWindow}).
\begin{lstlisting}[{caption=Klassenkopfgenerierung für ein Window
},{label=LST_complieWindow}]
def compileWindow(UIDescription description) '''
		«addImport("import DE.data_experts.jwammc.core.pf.PfRootPane;")»
		/**
		* Generated by Xtext.
		*/
		public class «guiFilename» extends PfRootPane{
		«description.genRest»
		}
	''' 
\end{lstlisting}
Ebenso wie bei der Generierung der ersten beiden Skripte, wird hier als
Layout-Container ein Borderlayout verwendet. Um die Anordnung der Bäume wie
gewünscht zu erhalten, wird ein weiterer Layout-Container benötigt. Da sich
diese Information auf das Layout bezieht, muss sie von der Layout-Datei
geliefert werden. Da diese in dieser Arbeit nicht umgesetzt wird, muss der Generator
selbst das Layout festlegen.\\
Die GUI-Klassen der eingebundenen Gui-Beschreibungen der Bäume werden in der zu
generierenden GUI-Klasse deklariert. Dabei muss der Typ der
\emph{UsedDescription} im Vorfeld überprüft werden. Handelt es sich um
den Typ \emph{UIDescriptionImport}, ist nur die Deklarierung der
UI-Komponente und die Einbindung in einen Layout-Container nötig (siehe Listing
\ref{LST_Used}. Anderenfalls müssen die spezifischen Eigenschaften komplexer
Komponenten untersucht werden. Darauf wird in dieser Arbeit nicht weiter
eingegangen. 
\begin{lstlisting}[{caption= Generierung von eingebundenen GUI-Beschreibungen
},{label=LST_Used}] 
	«IF description.descriptionType instanceof UIDescriptionImport»
			«var castedDescriptionType = description.descriptionType as UIDescriptionImport»
			«var usedQualifiedClassName = castedDescriptionType.descriptionName.genGuiFileName»
			«addGlobalVar(usedQualifiedClassName + ' ' + description.id + ';')»
				«description.id» = new « usedQualifiedClassName»();
		«ELSE»
			«genComplexComponent(description)»
		«ENDIF»
\end{lstlisting}
Die letzte Komponente, die damit noch nicht in der GUI-Klasse deklariert wurde
ist die Interchangeable-Komponente. Da diese UI-Komponenten keine
speziellen Properties besitzt, ist die Methode zur Generierung des Quell-Code
für diese UI-Komponente recht einfach gehalten (siehe Listing
\ref{LST_Interchangeable}).
\begin{lstlisting}[{caption= Generierung der Interchangeable-Komponente
},{label=LST_Interchangeable}] 
def compileInterchangeable(InterchangeableDefinition definition)'''
	«addImport("import DE.data_experts.jwammc.core.pf.PfCardPanel;")»
	«addGlobalVar("PfCardPanel " + definition.id + ";")»
	«definition.id» = new PfCardPanel();
		«definition.id».setIfName("«definition.id»");
	'''
\end{lstlisting}
Die generierten Dateien sind im Anhang \ref{AppGeneriert} zu finden. Es handelt
sich um die Dateien \emph{GuiInhaltsbaum.java}, \emph{GuiVerweisebaum.java} und
\emph{GuiExplorer.java}. Abbildung \ref{Abb_explorerGen} zeigt das GUI, welches
durch die Klasse \emph{GuiExplorer} erzeugt wird.
\myBigFigure{explorer.jpg}{Generierte Explorer-GUI}{explorerGen} 

\subsection*{IP-Klasse}
Um ein Objekt der IP-Klasse zu instanziieren wird ein Objekt der dazugehörigen
FP-Klasse benötigt. Die genauen Funktionen der FP-Klasse sollen nicht vom
Generator generiert werden. Es ist jedoch möglich den Klassenrumpf
vorzubereiten. Die Generierung der Klassenrumpfes der FP-Klasse
ist im Verlgeich zu der Generierung der GUI- und der IP-Klasse recht einfach
(siehe Listing \ref{LST_FPGen}.
\begin{lstlisting}[{caption= Generierung der FP-Klasse
},{label=LST_FPGen}] 
def genFpSource() '''
		«addImport("import DE.data_experts.jwam.tools.FpObject;")»
		«addImport("import de.jwam.handling.toolconstruction.request.RequestHandler;")»
		public class «specificFilename» extends FpObject{
			 public «specificFilename»( RequestHandler parent ) {
   		 		super( parent, "«descriptionname»" );
  			}
		}
	'''	
\end{lstlisting}
Die Generierung der IP-Klasse beginnt wiederum mit der Generierung des
Klassenkopfes mit entsprechend benötigten Imports (siehe Listing
\ref{LST_IpKopf}.
\begin{lstlisting}[{caption= Generierung des Klassenkopfs der
IP-Klasse},{label=LST_IpKopf}] 
def genIpSource(UIDescription description)'''
		«addImport("import DE.data_experts.jwam.tools.IpObject;")»
		«addImport("import de.jwamx.technology.iafpf.guimanagement.IAFContext;")»
		«addImport("import DE.data_experts.util.degexception.ExceptionManager;")»
		public class «specificFilename» extends IpObject{
			public «specificFilename»( IAFContext iafContext, final Fp«descriptionname» fp) {
    			super( iafContext, fp );
    			«addGlobalVar("Fp" + descriptionname + ' fp;')»
   				this.fp = fp;
   				try {
      				initCommands();
				    initIAFs( iafContext );
			    }
    			catch ( Exception ex ) {
      				ExceptionManager.getManager().addAndShow( ex );
    			}
   			}
   				«description.genIAF»
   				«description.genCommands»
   				«description.genCommandMethods»
   				«genGlobalVars»
		}
	'''
\end{lstlisting}
Wie bei der GUI-Klassen müssen hier ebenfalls die globalen Variablen am Ende der
Klasse stehen. Zwischen dem Konstruktor und den globalen variablen werden die
Interaktionsformen mit den Kommandos bestimmt (\emph{genIAF} - siehe Listing
\ref{LST_GenIaf}), den Kommandos bestimmte Methoden zugeordnet
(\emph{genCommands} - siehe Listing \ref{LST_GenCommands}) und die Rümpfe für
diese Methoden (\emph{genCommandMethods} - siehe Listing
\ref{LST_GenCommandMethods}) generiert.\\
Bei der Bestimmung der Interaktionsformen werden die in der GUI-Beschreibung
definierten UI-Komponenten durchlaufen und deren Standard-Interaktionsformen und
spezielle Interaktionsformen übersetzt (siehe Listing \ref{LST_genIAF1}).
\begin{lstlisting}[{caption= Übersetzung der
Interaktionsformen},{label=LST_GenIAF1}] def genIAF(UIDescription
description)''' protected void initIAFs( IAFContext iafContext ) {
	 	«FOR definition : description.definitions»
	 		«definition.compileIAF»
	 	«ENDFOR»
	 }
	'''
	
def compileIAF(Definition definition)'''
	«IF definition.concreteDefition.name == 'Label'»
		«(definition.concreteDefition as LabelDefinition).compileLabelStandardIAF»
	«ELSEIF definition.concreteDefition.name == 'Tree'»
		«(definition.concreteDefition as TreeDefinition).compileTreeStandardIAF»
	«ENDIF»
	«««		Spezielle Interaktionsformen
		«definition.compileSpecificInteractionTypes»
	'''

\end{lstlisting}
Dabei muss für die Standard-Interaktionsformen unterschieden werden um welche
UI-Komponente es sich handelt.\\
Zu jeder Interaktionsform gibt es ein entsprechendes Kommando, welches zur
Generierung des Codes relevant ist. Die Zuordung von Kommando zu
Interaktionsform wird vom Generator vorgenommen (Beipsiel Tree - siehe Listing
\ref{LST_compileTree}). Die dafür verwendeten Methoden (z.B.
\emph{genIAFActivator} oder \emph{genIAFTree}) können wiederverwendet werden.
\begin{lstlisting}[{caption= Übersetzung der Standard-Interaktionsform von
Trees},{label=LST_compileTree}] 
def compileTreeStandardIAF(TreeDefinition definition)'''
		«definition.id.genIAFActivator»
		«definition.id.genIAFTree»
	'''
	
def genIAFTree(String id) '''
		«genIAFSource("DE.data_experts.jwam.gui.interaction.IfTree","de.jwamx.technology.iafpf.command.cmdSelect",id)»
	'''
	
def genIAFActivator(String id) '''
		«genIAFSource("de.jwamx.technology.iafpf.interaction.ifActivator", "de.jwamx.technology.iafpf.command.cmdActivate", id)»
	'''
\end{lstlisting}
Die Methode \emph{genIAFSource} hat einen sehr hohen Wiederverwendungsgrad. Sie
wird von allen Methoden, die für die Zuordnung von Interaktionsform zu Kommando
zuständig sind verwendet. In dieser Methode wird der Quellcode letztendlich
generiert (siehe Listing \ref{LST_genIAFSource}).
\begin{lstlisting}[{caption= Generierung einer
Interaktionsform},{label=LST_genIAFSource}] 
def genIAFSource(String iafSource, String commandSource, String id) '''
		«addImport("import "+ iafSource +  ";")»
		«var iafNameWithPrefix = iafSource.split("\\.").last»
		«var iafName = iafNameWithPrefix.substring(2)»
		«addGlobalVar(iafNameWithPrefix + " "+id+iafName+';')»
		«id+iafName» = («iafNameWithPrefix») iafContext.interactionForm( «iafNameWithPrefix».class, "«id»" );
		«IF !commandSource.equals("")»
		«addImport("import "+ commandSource +  ";")»
		«var commandNameWithPrefix = commandSource.getClassOfSource»
		«var commandName = commandNameWithPrefix.substring(3)» 
		«id + iafName».attach«commandName»Command( «id + commandName»Command );
		«addCommand(id, commandName)»
		«ENDIF»
	'''
	
	
	def addCommand(String id, String commandName) {
		addGlobalVar("cmd"+commandName + ' ' + id + commandName + "Command;")
		commands.put(id+commandName, commandName);
		return ""
	}
\end{lstlisting}
Die Einzelheiten dieser Methode sind abhängig von den Konventionen die bzgl.
Namensbegund in der deg getroffen wurden. Der Aufruf der Methode
\emph{addCommand} ist jedoch für weitere Generierungen von Belang.\\
Nach Abschluss der Generierung des Quellcodes zur Bestimmung der
Interaktionsformen und Kommandos, müssen den Kommandos entsprechende Methoden
zugeordnet werden. Die Referenz auf die Kommandos wird über die Liste
\emph{commands} ermöglicht, die durch den Aufruf der Methode \emph{addCommand}
(siehe Listing \ref{LST_genIAFSource}) gefüllt wird. Die Methode
\emph{genCommands} ist für die beschriebene Zuordnung zuständig (siehe Listing
\ref{LST_GenCommands}).
\begin{lstlisting}[{caption= Generierung der
Kommandoinitialisierung},{label=LST_genIAFSource}] 
def genCommands(UIDescription description)'''
	 protected void initCommands() {
	 	«FOR id : commands.keySet»
	 		«var commandName = commands.get(id)»
	 		«addImport("import DE.data_experts.jwam.util.CmdAusfuehrer" + commandName + ";")»
	 		«id»Command = new CmdAusfuehrer«commandName»( getAusfuehrer() ) {
      @Override
      public void ausfuehren() {
        «id»();
      }
    };
	 	«ENDFOR»
	 }
	'''
\end{lstlisting}
Die genauen Bezeichnungen ergeben sich wiederum aus den Konventionen für die
Bezeichnungen innerhalb der MCF der deg.\\
Um Compilierungsfehler zu vermeiden, müssen die Methoden, die vom generierten
 Quellcode verwendet werden, ebenfalls generiert werden. Dazu ist die Methode
 \emph{genCommandMethods} zuständig. In dieser Methode wird die Liste
 \emph{commands} ebenfalls benutzt, um die Methodenrümpfe zu erzeugen (siehe
 Listing \ref{LST_GenCommandMethods}).
 Die Implementierung der generierten Methoden muss der Entwickler übernehmen.
 \begin{lstlisting}[{caption= Generierung der
Methoden zur Bestimmung der auszuführenden Aktionen
bei einer Interaktion},{label=LST_GenCommandMethods}] 
def genCommandMethods(UIDescription description)'''
		«FOR commandId : commands.keySet»
		public void «commandId»(){
			
		}
		«ENDFOR»
	'''
\end{lstlisting}
\parskip 20pt
Die Generator-Klasse ist im Anhang \ref{AppXtext} zu finden.
In den Methoden zur Generierung von UI-Komponenten für die GUI-Klassen sind die Codezeilen, die
das Layout bestimmen, entsprechend gekennzeichnet.

