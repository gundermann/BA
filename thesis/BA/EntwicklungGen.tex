\chapter{Entwicklung des Generators zur Generierung von Klassen für
das Multichannel-Framework}\label{Entwicklung des Generators für das Generieren von Klassen für
das Multichannel-Framework}
Alle Umsetzungen die in diesem Kapitel beschrieben werden, fanden in der 3.
Iteration statt. Von daher wird  nicht mehr zwischen
Iterationen unterschieden.\\
Ziel ist es mit dem Generator und einem entsprechenden GUI-Skript eine
Exploreransicht zu erstellen, wie sie in profil c/s geläufig ist. Abbildung
\ref{Abb_ee} zeigt den Aufbau einer solchen GUI. Darin enthalten sind zwei Bäume
(auf der linken Seite) und ein Interchangeable (auf der rechten Seite), worin der Inhalt
der ausgewählten Elemente des Inhaltsbaums angezeigt werden soll. Das Anzeigen
des Inhalts wird jedoch nicht umgesetzt.
\myBigFigure{explorerbaum.jpg}{Aufbau eines Explorers}{ee}
\noindent
Die notwendigen GUI-Skripte werden bei der Umsetzung vorgestellt.
\section{Beschreibung der GUI-, FP- und IP-Klassen}
Durch die Beschreibung der GUIs mit der entwickelten \g, ist es möglich die
GUI-, FP- und die IP-Klassen (siehe Kapitel \ref{Analyse}) zu generieren. Die
GUI-Klasse soll dabei vollständig generiert werden. Dafür werden
Informationen über das Layout aus der Layout-Datei benötigt. Die Umsetzung
und Einbindung der Layout-Datei wird nicht in dieser Arbeit behandelt. Aus
diesem Grund wird im Generator ein Layout festgelegt. Die IP- und FP-Klassen
sollen nur teilweise generiert werden. Somit unterteilt sich das folgende
Kapitel in drei Abschnitte (GUI-Klassen, FP-Klassen und IP-Klassen).\\
In den GUI-Klassen der deg werden die \gks durch
\emph{Präsentationsformen} beschrieben (siehe Kapitel \ref{Analyse}). Alle
\gks sind in diesen Klassen global verfügbar. Die globalen Variablen
stehen bei der deg am Ende der Klasse. Die bestehende Struktur der Klassen
soll nicht verändert werden.
Da die Interaktion von der Präsentation getrennt ist, müssen zur
Referenzierung von Interaktionen zu \gks entsprechende Schlüssel
vergeben werden (siehe Routinearbeit \hyperref[R1]{R1}).\\
Die IP-Klassen ordnen den \gks mit Hilfe dieses Schlüssels
entsprechende Interaktionen und darauf folgende Kommandos zu. Was genau bei der
Interaktion gesehen soll, kann vom Generator nicht erzeugt werden. Dies muss vom Entwickler nachgepflegt
werden.\\ 
In den FP-Klassen ist die Funktionalität des Werkzeugt beschrieben. Eine
komplette Generierung der FP-Klassen kann mit der DSL nicht angestrebt werden,
weil dafür entsprechende Informationen fehlen. Dennoch kann der Klassen-Rumpf
und der Konstruktor erzeugt werden.\\
Für die Generierung der Klassen wird in dieser
Arbeit Transformer Generation (siehe Kapitel \ref{Domänenspezifische Sprachen})
verwendet. Für die Generierung der IP- und FP-Klassen ist auch die
Templated Generation (siehe Kapitel \ref{Domänenspezifische Sprachen}) in Erwägung zu ziehen. Um bei der
Art der Generation einheitlich zu sein, wird auf diese Möglichkeit nicht weiter eingegangen.


\section{Umsetzung des frameworkspezifischen Generators}
\subsection*{GUI-Klassen}
Bei Betrachtung der Präsentation aus Abbildung \ref{Abb_ee} können die
Bäume auf der linken Seite als einzelne GUI-Beschreibungen betrachtet
werden, die jeweils mit einem fachlichen Konzepten assoziiert werden können. Der
obere Baum kann mit dem fachlichen Konzept des
\glossLink{Inhaltsbaum}{Inhaltsbaumes} in Verbindung gebracht werden und der
untere mit dem des \glossLink{Verweisebaum}{Verweisebaums}. Da sich die
fachlichen Konzepte erkennen lassen, sollten separate GUI-Skripte
erstellt werden (siehe Listing \ref{LST_Inhaltsbaum} und \ref{LST_Verweisebaum}).
\begin{lstlisting}[{caption = GUI-Skript für den Inhaltsbaum},{label =
LST_Inhaltsbaum}]
type: INNERCOMPLEX;
Label as: 'kopfzeile'->text='Inhaltsbaum';
Tree[testwerkzeuge.modelle.InhaltsModell] as: 'inhaltsbaum';
Structure:'kopfzeile','inhaltsbaum';
\end{lstlisting}

\begin{lstlisting}[{caption = GUI-Skript für den Verweisebaum},{label =
LST_Verweisebaum}]
type: INNERCOMPLEX;
Label as: 'kopfzeile'->text='Verweisebaum';
Tree[testwerkzeuge.modelle.VerweiseModell] as: 'verweisebaum';
Structure:'kopfzeile','verweisebaum';
\end{lstlisting}
Bei der Generierung betrachtet Xtext eine GUI-Beschreibung im Ganzen. Für
jede GUI-Beschreibung soll eine eigene GUI-Klasse angelegt werden. Die Klassen
enthalten in diesen beiden Fällen zwei globale Variablen. Darüber hinaus
enthalten sie Importe, die am Anfang der beiden Klassen stehen. Um das
GUI-Skript für jede zu generierende Datei nur einmal analysieren zu müssen, ist
es notwendig Importe, Methoden und globale Variablen zwischen zu speichern. Die
Methoden in Listing \ref{LST_Importe} realisieren das Speichern der Importe und
globalen Variablen beim generieren der Methoden. So ist es möglich die
bestehende Struktur der Klassen der deg beizubehalten.
\begin{lstlisting}[{caption = Speichern der Importe und der globalen
Variablen},{label = LST_Importe}]
def addImport(String newImport) {
		if (!imports.contains(newImport)) {
			imports.add(newImport)
		}
	}
	
def addGlobalVar(String globalVar) {
		if(!globalVars.contains(globalVar))
			globalVars.add(globalVar)
	}
\end{lstlisting}
Zu Beginn einer Generierung muss zwischen den Typen der GUI-Beschreibung
unterschieden werden. Je nachdem ob die Beschreibung als \emph{Window} oder
\emph{Innercomplex} definiert ist, werden entsprechende Importe benötigt. In
den Fällen der oben genannten Bäume wird ein \emph{Innercomplex} definiert (siehe Listing
\ref{LST_HeadComplex}).
\begin{lstlisting}[{caption = Generierung eines
Innercomplex},{label = LST_HeadComplex}]
def compileComplex(UIDescription description) '''
	«addImport("import DE.data_experts.jwammc.core.pf.PfPanel;")»
	public class «guiFilename» extends PfPanel{
	«description.genRest»
	}	
'''
	
def genRest(UIDescription description)'''
	«addImport("import java.awt.BorderLayout;")»
	public «guiFilename»(){
		super( new BorderLayout() );
		try {
    		init();
    	}
    	catch ( Exception e ) {
    		 e.printStackTrace();
   		}
	}
	«description.init»
	«genGlobalVars»
'''
\end{lstlisting}
In der Methode \emph{compileComplex} wird festgelegt, dass sich die
\gks auf einem Border-Layout anordnen. Wenn die Layout-Datei verwendet wird, muss der Generator
aus dem Inhalt dieser Datei auf einen entsprechenden Layout-Container
schließen. Zum Abschluss der Methode \emph{genRest} werden zwei weitere Methoden
aufgerufen.
Die erste Methode (\emph{descrition.init}) generiert die im Konstruktor
aufgerufene Methode \emph{init}.
Die andere Methode \emph{genGlobalVars} ist für die Generierung der globalen
Variablen zuständig.\\
In der Methode \emph{init} werden alle \gks und das Layout definiert.
Da für das Layout in dieser Arbeit keine Beschreibung existiert,
müssen diese Angaben nachgepflegt werden. Die Definition
der \gks mit ihren Properties können jedoch
erzeugt werden. Listing \ref{LST_Init} zeigt die Methode \emph{init} ohne
Berücksichtigung des Layouts.
\begin{lstlisting}[{caption = Generierung der Methode \emph{init} der
GUI-Klassen},{label = LST_Init}]
def getInit(UIDescription description) '''
	public void init(){
		«FOR def : description.definitions»
			«def.compileComponent»
		«ENDFOR»
	}
'''
\end{lstlisting}
In der Methode \emph{compileComponent} wird geprüft um welche UI-Komponente es
sich handelt. Diese wird anschließend compiliert, wobei der entsprechende
Quell-Code zur frameworkspezifischen Definition der Komponente generiert wird.
Im Fall des Labels werden der entsprechende Import und die globale Variable
hinzugefügt. Weiterhin muss die Referenz für die IP-Klasse definiert werden, da
Labels Standardinteraktionen besitzen. Wenn vorhanden, müssen letztlich die
Properties am Label gesetzt werden (siehe Listing \ref{LST_LabelGen}).
\begin{lstlisting}[{caption = Generierung eines Labels},{label =
LST_LabelGen}]
def compileLabel(LabelDefinition definition) '''
	«addImport("import DE.data_experts.jwammc.core.pf.PfLabel;")»
	«addGlobalVar("PfLabel " + definition.id + ";")»
	«definition.id» = new PfLabel();
	«definition.id».setIfName("«definition.id»");
	«IF definition.properties != null»
		«genProperty(definition.id, 'setText',definition.properties.text, true)»
	«ENDIF»
'''

def genProperty(String id, String method, String value, Boolean isString) '''
	«IF value != null»
		«IF isString»
			«id».«method»("«value»");
		«ELSE»
			«id».«method»(«value»);
		«ENDIF»
	«ENDIF»
	'''
'''
\end{lstlisting}
Die Eigenschaften aus den Properties-Dateien müssten an dieser Stelle zusätzlich
berücksichtigt werden.
Dies wurde aus Zeitgründen nicht umgesetzt.\\
Der Quell-Code für den Baum wird ähnlich generiert. Wenn der Input-Typ des
Baumes nicht gesetzt ist, muss ein Standard-Wert dafür eingesetzt werden.
Des Weiteren muss für den Baum ein \emph{CellRenderer} definiert
werden (siehe Listing \ref{LST_Tree}).
\begin{lstlisting}[{caption = Generierung eines Trees},{label =
LST_Tree}]
def compileTree(TreeDefinition definition)'''
	«addImport("import DE.data_experts.jwammc.core.pf.PfTree;")»
	«addImport("import DE.data_experts.jwammc.core.pf.TreeCellRenderer;")»
	«addImport("import DE.data_experts.jwammc.core.pf.PfTree;")»
	«addImport("import javax.swing.tree.DefaultTreeModel;")»
	«addGlobalVar("PfTree " + definition.id + ";")»
	«definition.id» = new PfTree();
	«definition.id».setIfName("«definition.id»");
	«IF definition.inputType == null»
		«addImport("import DE.data_experts.util.ObjectNode;")»
		«definition.id».setTreeModel( new DefaultTreeModel( new ObjectNode() ) );
	«ELSE»
		«definition.id».setTreeModel( new DefaultTreeModel( 
		new «definition.inputType.substring(1,definition.inputType.length-1)»() ) );
	«ENDIF»
		«definition.id».setCellRenderer( new TreeCellRenderer() );
'''
\end{lstlisting}
Durch die genannten Methoden kann der Generator die beiden GUI-Skripte
zur Beschreibung des Inhalts- und des Verweisebaums in GUI-Klassen
transformieren, die innerhalb der MCF ausgeführt werden können.\\
Die generierten Dateien (\emph{GuiInhaltsbaum.java} und
\emph{GuiVerweisebaum.java}) befinden sich auf dem beiliegenden Datenträger
(siehe Anlage \ref{cd}) im Projekt \emph{Explorer}.
Abbildung \ref{Abb_Trees} zeigt die beiden GUIs, welche bei der Ausführung
der generierten Dateien im Kontext von profil c/s erzeugt werden.
\myBigFigure{Trees.jpg}{Generierte GUI des Inhalts- und Verweisebaums}{Trees}
\noindent
Um die Explorer-GUI zu generieren, müssen diese beiden Bäume zusammen mit einem
austauschbaren Bereich in einem GUI-Skript definiert werden (siehe Listing
\ref{LST_Skript_Explorer}).
\begin{lstlisting}[{caption=GUI-Skript für das
Exlporer-GUI},{label=LST_Skript_Explorer}] 
type: WINDOW;
use: "Inhaltsbaum" as: 'inhaltsbaum';
use: "Verweisebaum" as: 'verweisebaum';
Interchangeable as: "austauschbarerBereich";
Structure:'inhaltsbaum', 'verweisebaum', 'austauschbarerBereich';
\end{lstlisting}
Da es sich um ein \emph{Window} handelt, wird in diesem Fall die Methode
\emph{compileWindow} aufgerufen. Der einzige Unterschied zur Methode
\emph{compileComplex} ist in diesem Fall die Oberklasse (siehe Listing
\ref{LST_complieWindow}).
\begin{lstlisting}[{caption=Generierung eines Windows
},{label=LST_complieWindow}]
def compileWindow(UIDescription description) '''
	«addImport("import DE.data_experts.jwammc.core.pf.PfRootPane;")»
	public class «guiFilename» extends PfRootPane{
	«description.genRest»
	}
''' 
\end{lstlisting}
Ebenso wie bei der Generierung der ersten beiden \glspl{GUI}, wird hier als
Layout-Container ein Border-Layout verwendet. Um die Anordnung der Bäume wie
gewünscht zu erhalten, wird ein weiterer Layout-Container benötigt. Da sich
diese Information auf das Layout bezieht, muss sie normalerweise von der
Layout-Datei geliefert werden.\\
Die GUI-Klassen der eingebundenen Gui-Skripte für die Bäume werden in der
zu generierenden GUI-Klasse für den Explorer deklariert. Dabei muss der Typ der
\emph{UsedDescription} im Vorfeld überprüft werden. Handelt es sich um
den Typ \emph{UIDescriptionImport}, ist lediglich die Deklarierung der
\gk und die Einbindung in einen Layout-Container nötig (siehe Listing
\ref{LST_Used}). Anderenfalls müssen die spezifischen Eigenschaften komplexer
Komponenten untersucht werden. Darauf wird in dieser Arbeit jedoch nicht weiter
eingegangen. 
\begin{lstlisting}[{caption= Generierung der Einbindung
anderer GUI-Skripte },{label=LST_Used}] 
def compile(UsedDescription description) '''
	«IF description.descriptionType instanceof UIDescriptionImport»
		«var castedDescriptionType = description.descriptionType asUIDescriptionImport» 
		«var usedQualifiedClassName = castedDescriptionType.descriptionName.genGuiFileName»
		«addGlobalVar(usedQualifiedClassName + ' ' + description.id + ';')»
		«description.id» = new « usedQualifiedClassName»();
	«ELSE»
		«genComplexComponent(description)»
	«ENDIF»
'''
\end{lstlisting}
Die letzte Komponente, die damit noch nicht in der GUI-Klasse deklariert wurde
ist die Interchangeable-Komponente. Da diese \gks keine
speziellen Properties besitzt, ist die Methode zur Generierung des Quellcodes
recht einfach gehalten (siehe Listing \ref{LST_Interchangeable}).
\begin{lstlisting}[{caption= Generierung einer Interchangeable-Komponente
},{label=LST_Interchangeable}] 
def compileInterchangeable(InterchangeableDefinition definition)'''
	«addImport("import DE.data_experts.jwammc.core.pf.PfCardPanel;")»
	«addGlobalVar("PfCardPanel " + definition.id + ";")»
	«definition.id» = new PfCardPanel();
	«definition.id».setIfName("«definition.id»");
'''
\end{lstlisting}
Die generierten Dateien sind auf dem beiliegenden Datenträger (siehe Anlage
\ref{cd}) zu finden.
Es handelt sich um die Dateien \emph{GuiInhaltsbaum.java}, \emph{GuiVerweisebaum.java} und
\emph{GuiExplorer.java}. Abbildung \ref{Abb_explorerGen} (in Anhang
\hyperref[explorergui]{B}) zeigt die \gui, welches durch die Klasse
\emph{GuiExplorer.java} erzeugt wird.


\subsection*{FP-Klassen}
Da für die FP-Klassen lediglich der Klassen-Rumpf und der Konstruktor generiert
wird, ist diese Aufgabe entsprechend einfach. Es werden wiederum eine Oberklasse
und entsprechende Importe benötigt, wie Listing \ref{LST_FPGen} zu entnehmen
ist.
\begin{lstlisting}[{caption= Generierung der FP-Klasse
},{label=LST_FPGen}] 
def genFpSource() '''
	«addImport("import DE.data_experts.jwam.tools.FpObject;")»
	«addImport("import de.jwam.handling.toolconstruction.request.RequestHandler;")»
	public class «specificFilename» extends FpObject{
		 public «specificFilename»( RequestHandler parent ) {
   	 		super( parent, "«descriptionname»" );
  		}
	}
'''	
\end{lstlisting}
\subsection*{IP-Klassen}
Um ein Objekt der IP-Klasse zu instantiieren wird ein Objekt der dazugehörigen
FP-Klasse benötigt. Die Generierung der IP-Klasse beginnt wiederum mit der
Generierung des Klassen-Kopfes mit entsprechend benötigten Imports (siehe
Listing \ref{LST_IpKopf}).
\begin{lstlisting}[{caption= Generierung des Klassen-Kopfs der
IP-Klasse},{label=LST_IpKopf}] 
def genIpSource(UIDescription description)'''
	«addImport("import DE.data_experts.jwam.tools.IpObject;")»
	«addImport("import de.jwamx.technology.iafpf.guimanagement.IAFContext;")»
	«addImport("import DE.data_experts.util.degexception.ExceptionManager;")»
	public class «specificFilename» extends IpObject{
		public «specificFilename»( IAFContext iafContext, final Fp«descriptionname» fp) {
    		super( iafContext, fp );
    		«addGlobalVar("Fp" + descriptionname + ' fp;')»
   			this.fp = fp;
   			try {
      			initCommands();
			    initIAFs( iafContext );
		    }
    		catch ( Exception ex ) {
      			ExceptionManager.getManager().addAndShow( ex );
    		}
   		}
   		«description.genIAF»
   		«description.genCommands»
   		«description.genCommandMethods»
   		«genGlobalVars»
	}
'''
\end{lstlisting}
Wie bei den GUI-Klassen müssen hier ebenfalls die globalen Variablen am Ende der
Klasse stehen. Zwischen dem Konstruktor und den globalen variablen werden die
Interaktionsformen mit den Kommandos bestimmt (\emph{genIAF} - siehe Listing
\ref{LST_GenIAF}), den Kommandos bestimmte Methoden zugeordnet
(\emph{genCommands} - siehe Listing \ref{LST_genCommands}) und die Rümpfe für
diese Methoden generiert (\emph{genCommandMethods} - siehe Listing
\ref{LST_GenCommandMethods}).\\
Bei der Bestimmung der Interaktionsformen werden die in der GUI-Beschreibung
definierten \gks durchlaufen und deren Standard-Interaktionsformen und
spezielle Interaktionsformen übersetzt (siehe Listing \ref{LST_genIAF}).
\begin{lstlisting}[{caption= Übersetzung der
Interaktionsformen},{label=LST_GenIAF}] 
def genIAF(UIDescriptiondescription)''' 
	protected void initIAFs( IAFContext iafContext ) {
	 	«FOR definition : description.definitions»
	 		«definition.compileIAF»
	 	«ENDFOR»
	 }
'''
	
def compileIAF(Definition definition)'''
	«IF definition.concreteDefition.name == 'Label'»
		«(definition.concreteDefition as LabelDefinition).compileLabelStandardIAF»
	«ELSEIF definition.concreteDefition.name == 'Tree'»
		«(definition.concreteDefition as TreeDefinition).compileTreeStandardIAF»
	«ENDIF»
	«««		Spezielle Interaktionsformen
		«definition.compileSpecificInteractionTypes»
	'''

\end{lstlisting}
Für die Standard-Interaktionsformen unterschieden werden um welche
UI-Komponente es sich handelt.\\
Zu jeder Interaktionsform gibt es ein entsprechendes Kommando, welches zur
Generierung des Quell-Codes relevant ist. Die Zuordnung von Kommando zu
Interaktionsform wird vom Generator vorgenommen (Beispiel Tree - siehe Listing
\ref{LST_compileTree}). Die dafür verwendeten Methoden (z.B.
\emph{genIAFActivator} oder \emph{genIAFTree}) können häufig wiederverwendet
werden.
\begin{lstlisting}[{caption= Übersetzung der Standard-Interaktionsform von
Trees},{label=LST_compileTree}] 
def compileTreeStandardIAF(TreeDefinition definition)'''
		«definition.id.genIAFActivator»
		«definition.id.genIAFTree»
	'''
	
def genIAFTree(String id) '''
		«genIAFSource("DE.data_experts.jwam.gui.interaction.IfTree","de.jwamx.technology.iafpf.command.cmdSelect",id)»
	'''
	
def genIAFActivator(String id) '''
		«genIAFSource("de.jwamx.technology.iafpf.interaction.ifActivator", "de.jwamx.technology.iafpf.command.cmdActivate", id)»
	'''
\end{lstlisting}
Die Methode \emph{genIAFSource} hat ebenfalls einen sehr hohen
Wiederverwendungsgrad.
Sie wird von allen Methoden, die für die Zuordnung von Interaktionsform zu Kommando
zuständig sind verwendet. In dieser Methode wird der Quellcode letztendlich
generiert (siehe Listing \ref{LST_genIAFSource}).
\begin{lstlisting}[{caption= Generierung einer
Interaktionsform},{label=LST_genIAFSource}] 
def genIAFSource(String iafSource, String commandSource, String id) '''
	«addImport("import "+ iafSource +  ";")»
	«var iafNameWithPrefix = iafSource.split("\\.").last»
	«var iafName = iafNameWithPrefix.substring(2)»
	«addGlobalVar(iafNameWithPrefix + " "+id+iafName+';')»
	«id+iafName» = («iafNameWithPrefix») iafContext.interactionForm( «iafNameWithPrefix».class, "«id»" );
	«IF !commandSource.equals("")»
		«addImport("import "+ commandSource +  ";")»
		«var commandNameWithPrefix = commandSource.getClassOfSource»
		«var commandName = commandNameWithPrefix.substring(3)» 
		«id + iafName».attach«commandName»Command( «id + commandName»Command );
		«addCommand(id, commandName)»
	«ENDIF»
'''
	
def addCommand(String id, String commandName) {
	addGlobalVar("cmd"+commandName + ' ' + id + commandName + "Command;")
	commands.put(id+commandName, commandName);
	return ""
}
\end{lstlisting}
Die Einzelheiten dieser Methode sind unter anderem abhängig von den
Konventionen die bzgl.
Namensgebung in der deg getroffen wurden. Der Aufruf der Methode
\emph{addCommand} ist für weitere Generierungen von Belang.\\
Nach Abschluss der Generierung des Quell-Codes zur Bestimmung der
Interaktionsformen und Kommandos, müssen den Kommandos entsprechende Methoden
zugeordnet werden. Die Referenz auf die Kommandos bietet die Liste
\emph{commands}, die durch den Aufruf der Methode \emph{addCommand}
(siehe Listing \ref{LST_genIAFSource}) gefüllt wird. Die Methode
\emph{genCommands} ist für die beschriebene Zuordnung zuständig (siehe Listing
\ref{LST_genCommands}).
\begin{lstlisting}[{caption= Generierung der
Kommandoinitialisierung},{label=LST_genCommands}] 
def genCommands(UIDescription description)'''
	 protected void initCommands() {
	 	«FOR id : commands.keySet»
	 		«var commandName = commands.get(id)»
	 		«addImport("import DE.data_experts.jwam.util.CmdAusfuehrer" + commandName + ";")»
	 		«id»Command = new CmdAusfuehrer«commandName»( getAusfuehrer() ) {
      			@Override
      			public void ausfuehren() {
        			«id»();
      			}
    		};
	 	«ENDFOR»
	 }
'''
\end{lstlisting}
Die genauen Bezeichnungen ergeben sich wiederum aus den Konventionen für die
Bezeichnungen innerhalb des MCF der deg.\\
Um Compilierungsfehler zu vermeiden, müssen die Methoden, die vom generierten
 Quell-Code verwendet werden, ebenfalls generiert werden. Dafür ist die Methode
 \emph{genCommandMethods} zuständig. In dieser Methode wird die Liste
 \emph{commands} nochmals benutzt, um die Methoden-Rümpfe zu erzeugen (siehe
 Listing \ref{LST_GenCommandMethods}).
 Die Implementierung der generierten Methoden muss der Entwickler übernehmen.
 \begin{lstlisting}[{caption= Generierung der
Methoden zur Bestimmung der auszuführenden Aktionen
bei einer Interaktion},{label=LST_GenCommandMethods}] 
def genCommandMethods(UIDescription description)'''
	«FOR commandId : commands.keySet»
		public void «commandId»(){}
	«ENDFOR»
	'''
\end{lstlisting}
\parskip 20pt
Die Generator-Klasse ist im Anhang \ref{AppXtext} zu finden.
In den Methoden zur Generierung von \gks für die GUI-Klassen sind die
Code-Abschnitte, die das Layout bestimmen, entsprechend gekennzeichnet.

