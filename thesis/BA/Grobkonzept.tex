\chapter{Festlegungen für die Entwicklung des Prototypen}\label{Aufteilung der
Anforderungen auf Sprache und Generator}
\section{Vorgehensmodell}
Das Vorgehensmodell für die Entwickler des DSL-Prototypen ist ein inkrementelles
Modell. Das bedeutet, dass mehrere Iterationen durchlaufen werden
(inkrementell), in denen unterschiedliche Versionen des Prototyps entwickelt
werden \vcite{SauerDiss}{5}. 
In Abbildung
\ref{Abb_inkrement} ist das Vorgehensmodell schematisch dargestellt.
\myBigFigure{inkrement.jpg}{Inkrementelles Modell}{inkrement}
\noindent
Nach der Definition der Anforderungen wird der
Prototyp für die aktuelle Iteration entworfen und entwickelt. Im folgenden
Verlauf werden diese beiden Phasen nicht separiert. An die
Implementierung des Prototypen der aktuellen Iteration
schließt sich ein Review an. Innerhalb des Reviews wird der Prototyp der
aktuellen Iteration vorgestellt und weitere Anforderungen festgelegt,
bestehende Anforderungen geändert oder Änderungen am gesamten Konzept gemacht. 
Das führt wiederum zu einem neuen Entwurf, woran sich eine weitere
Implementierung anschließt. Dieser Zyklus wird somit mehrmals durchlaufen
(Iteration) \vcite{SauerDiss}{5}.  \\
Grund für dieses Vorgehen ist, dass in der
deg bzgl.
DSL-Entwicklung wenig Know-How existiert. Aus den Iterationen soll so viel
Erfahrung und Wissen wie möglich geschöpft werden. Außerdem werden somit auch Irrwege aufgezeigt, die bei Entwicklung
anderer DSLs Beachtung finden können. Weiterhin können Anforderungen flexibel
angepasst und Missverständnisse reduziert werden, da der Entwicklungsprozess
transparent ist. \vcite{SauerDiss}{67}\\
Der weitere Verlauf (Kapitel \ref{Grobkonzept}, \ref{Entwicklung einer DSL zur
Beschreibung der GUI in profil c/s} und \ref{Entwicklung des Generators für das
Generieren von Klassen für das Multichannel-Framework}) wird die
durchgeführten Iterationen beschrieben. Dabei werden folgende Aspekte
beleuchtet.
\begin{itemize}
  \item [] \textbf{Vision} (siehe Kapitel \ref{Grobkonzept})\\
  Dadurch werden die Anforderungen an die DSL-Umgebung
  beschrieben. Die in Kapitel \ref{GUI-DSL} vorgestellten Anforderungen sind das
  Resultat der in dieser Arbeit durchgeführten Iterationen.
  \item []\textbf{Entwicklung}\\
  Die Entwicklung beschreibt die Phasen \emph{Entwerfen} und
  \emph{Implementieren}. 
  Sie teilt sich in zwei weitere Bereiche auf.
  \begin{itemize}
  	\item [$\bullet$]Entwicklung der DSL (siehe Kapitel \ref{Entwicklung einer
  	DSL zur Beschreibung der GUI in profil c/s})
  	\item [$\bullet$]Entwicklung eines Generators (siehe Kapitel \ref{Entwicklung
  	des Generators für das Generieren von Klassen für das Multichannel-Framework})
  \end{itemize}
\end{itemize}


\section{Grobkonzept der DSL-Umgebung (Vision)}\label{Grobkonzept}
\subsection{1. Iteration}
Die DSL-Umgebung soll sich in zwei Bereiche unterteilen. 
\begin{itemize}
  \item DSL zur Beschreibung der \acrshort{GUI}
  \item Generator zur Generierung von Quellcode
\end{itemize}
In Abbildung \ref{Abb_Konzept_1} sind die Artefakte mit den
Funktionen (blauer Kasten), die von ihnen umgesetzt werden sollen dargestellt.
\myBigFigure{konzept_1.jpg}{Konzeption der DSL-Umgebung (1.
Iteration)}{Konzept_1}
\noindent
Die elementare Aufgabe der GUI-DSL ist es, die
\gks, die in dem GUI verwendet werden sollen, zu
definieren (siehe Anforderung \hyperref[AS1]{AS1}). Ausgehend von den für profil
c/s verwendeten \gks, können diese in drei Kategorien unterteilt werden.
\begin{itemize}
  \item []\textbf{Basiskomponenten}\\
  Dabei handelt
es sich um \acrshort{GUI}-Komponenten, deren Funktionen in unterschiedlichen \acrshort{GUI}-Frameworks 
ähnlich sind und in unterschiedlichen Anwendungen eingesetzt werden
können. Das bedeutet, dass sie nicht als domänenspezifisch angesehen werden
können. Beispiele hierfür sind \acrshort{GUI}-Komponenten wie der \emph{Button} oder das
\emph{Label}.
  \item[]\textbf{Komplexe Komponenten}\\
  Diese zeichnen sich
dadurch aus, dass sie domänenspezifisch sind und speziell für profil c/s
entwickelt wurden und Interaktionen und Funktionalitäten bereits festgelegt
sind und nicht verändert werden können.
Ein Beispiel für eine komplexe Komponenten ist die \gloss{Multiselection-Komponente}. 

  \item[]\textbf{Layout-Komponenten}\\
  Dabei handelt es sich
um Komponenten, welche die Struktur der \acrshort{GUI} bestimmen. In anderen
\acrshort{GUI}-Frameworks sind dies bspw.
\emph{Panel} (\gloss{Swing}), \emph{Div} (HTML) oder \emph{Pane} (JavaFX).
\end{itemize}
\noindent
Bei den Beschreibungen der \Ks muss auch die Möglichkeit bestehen Interaktionen
festzulegen (siehe Anforderung \hyperref[AS5]{AS5}). Zu einer Interaktion
gehört die Art der Interaktion und bestimmte Aktionen, die bei der Interaktion ausgeführt
werden. Die anderen \gks haben festgelegte Interaktionsmöglichkeiten
(\kks) oder es ist nicht möglich mit ihnen zu interagieren (Layout-Komponenten).\\
Bezüglich der \knks ist darauf zu achten, dass sie für jedes verwendete
\acrshort{GUI}-Framework implementiert werden müssen. Damit wird verhindert,
dass die Entwickler, die mit der \g arbeiten,
eigene \kks entwerfen, deren Wiederverwendungsgrad niedriger ist, als wenn
diese Komponenten nach ausreichender Evaluation an einer zentralen Stelle
implementiert und bereitgestellt werden. Die Notwendigkeit dessen, dass die
Quellen für diese \knks sowohl zur Entwicklungszeit, als auch zur Laufzeit
vorhanden sein müssen, ist ein Nachteil dieses Konzeptes.\\
Bei den Layout-Komponenten ist besonders
auf die Ausdruckskraft der für die Beschreibung dieser Komponenten verwendeten Bezeichnungen zu
achten. Grund dafür ist, dass die \acrshort{GUI} auf unterschiedlichen
Plattformen abgebildet werden soll, die spezielle Layout-Bereiche unterstützen.
Beispielsweise lässt sich ein Programmfenster auf dem Desktop als oberste Layout
Komponente festlegen. In einem Web-Browser ist der Begriff \emph{Fenster} als
oberste Layout Komponenten in der \deg nicht geläufig. Die Komponente,
die in einem Browser mit dem Programmfester auf dem Desktop assoziiert wird,
ist in der \deg das Tab.\\
Darüber hinaus sollen die Skripte für die Beschreibung der \guis so
konzipiert werden, dass es möglich ist andere GUI-Beschreibungen dort
einzubinden (siehe Anforderung \hyperref[AS1]{AS1}). Somit werden eingebundene
GUIs wiederum zu \gui-Komponenten.
Ziel dessen ist es, dass die Entwickler aus mehreren einfachen \guis ein
komplexes \gui erstellen können (Modularisierung). Die Gefahr die dabei besteht
ist, dass mit der Zeit viel einfache GUI-Beschreibungen mit ähnlicher Strukturiert entwickelt werden. Da die
deg bei den GUIs von profil c/s ein bestimmtes Schema verfolgt (Cooperate
Design), sollte dieses Problem dadurch ausreichend eingedämmt sein. Wichtig ist
hierbei zu betonen, dass die DSL keine Sprache sein soll, mit der jedes GUI
beschrieben werden kann. Sie soll lediglich UIs für profil c/s beschreiben
können. Der Vorteil, der sich aus dieser starken Modularisierung ergibt, ist
dass viele GUI-Beschreibungen wiederverwendet werden können. So ist es meiner
Meinung nach möglich komplexe GUI-Beschreibungen zu entwickeln, die in
Fachabteilungen mit fachlichen Konzepten assoziiert werden können.\\\\
Beispielsweise können Suchmasken nach diesem Konzept gestaltet, beliebig
wiederverwendet und kombiniert werden. Hierzu werden unterschiedliche
Suchfelder definiert, die aus einem Label und einem Textfeld bestehen
(Beispiel siehe Abbildung \ref{Abb_suchfeld}).
\myBigFigure{suchfeld.jpg}{Beispiel: Suchfeld für Name}{suchfeld}
\noindent
In eine Suchmaske können mehrere dieser Suchfelder beliebig komponiert werden.
(Beispiel siehe Abbildung \ref{Abb_suchmaske}).
\myBigFigure{suchmaske.jpg}{Beispiel: Suchmaske}{suchmaske}
\noindent
Durch diese Möglichkeit der Komposition können auch komplexere fachliche
Konzepte auf die \acrshort{GUI} bezogen werden, wie z.B.
\emph{Personensuche}.\\\\
Um die miteinander komponierten \gks zu
strukturieren ist es notwendig, dass die \g Informationen über
die Anordnung der \gks enthält. Diese Informationen müssen
ausreichend abstrakt sein, damit sich diese Struktur auf unterschiedliche
\acrshort{GUI}-Frameworks beziehen lässt. Dazu wird die Struktur innerhalb einer
\acrshort{GUI} als Anordnung von Bereichen betrachtet. In der \g
werden diesen Bereichen die \gks zugeordnet. Genauere Informationen über die
Anordnung dieser Bereiche dürfen nicht enthalten sein, da dies eine Orientierung
an bestimmte Layouts bedingt (siehe Anforderung \hyperref[AS3]{AS3}). Dazu ist
weiterhin wichtig, dass den Bereichen jeweils nur eine Komponente zugeordnet werden kann. Dadurch wird der
Zwang zur vorher beschriebenen Komposition von eingebundenen \g-Skripten und definierten \gks verstärkt werden.\\
Der Generator übernimmt beim Erzeugen des frameworkspezifischen Quellcodes die
konkrete Anordnung der beschriebenen Bereiche. Grund dafür ist, dass die
Anordnung der Komponenten frameworkspezifisch ist und teilweise unterschiedliche
Layoutmanager in unterschiedlichen Frameworks unterstützt werden. Da für jedes
eingesetzte Framework ein eigener Generator implementiert werden muss (siehe
Kapitel \ref{Entwicklung einer Lösungsidee}), ist es theoretisch möglich diese
Aufgabe weitgehend unabhängig von der Beschreibung der verwendeten
\gui-Komponenten zu erfüllen.


\subsection{2. Iteration}
Nach dem Review der ersten Iteration des Prototypen wurde das grundsätzliche
Konzept um ein Artefakt erweitert (siehe Abbildung \ref{Abb_konzept_2}).
\myBigFigure{konzept_2.jpg}{Konzeption der DSL-Umgebung (2.
Iteration)}{konzept_2}
\noindent
Eine Änderung, die in dieser Grafik nicht dargestellt wird, ist, dass die
Aktionen, die bei Interaktionen mit \gks ausgeführt werden,
nicht in der GUI-DSL definiert werden sollen. Grund dafür ist, dass
diese Aktionen sehr unterschiedlich sind und somit kaum
abstrahiert werden können.\\
Eine weitere Änderung ist, dass die \gks, die einem
GUI-DSL-Skript direkt definiert werden, in einer anderen Beschreibung, wo jenes
GUI-DSL-Skript eingebunden ist, verändert werden können. Dadurch werden die
wiederverwendeten Beschreibungen anpassbar, was die Flexibilität enorm steigert
(siehe Anforderung \hyperref[AS2]{AS2}).\\
Darüber hinaus soll die Möglichkeit bestehen, bestimmte Werte, welche die
Attribute von \gks annehmen können, in Properties-Dateien auszulagern, wodurch
die GUI-DSL weitgehend entlastet wird. Allerdings muss für die
Zuweisung von \gks zu Wert-Beschreibung in der Properties-Datei und
dem DSL-Skript ein eindeutiger Schlüssel definiert werden.\\
Der Generator muss die festgelegten Properties-Dateien in die Generierung mit
einbeziehen und ihnen die entsprechenden Werte entnehmen. Dabei gilt die
Festlegung, dass wenn in dem GUI-DSL-Skript einem Attribut ein bestimmter Wert zugewiesen
ist, wird in der Properties-Datei (wenn diese nebst Schlüssel festgelegt wurde)
nicht mehr nach diesem Attribut der Komponente gesucht.

\subsection{3. Iteration}
In dem Review, welches vor der 3. Iteration durchführt wurde, entstanden die
letzten Änderungen, die bzgl. der Sprache innerhalb dieser Arbeit Beachtung
finden. Das grundsätzliche Konzept wurde nochmals erweitert. Neben den bekannten
Artefakten der DSL-Umgebung kommt ein weiteres Artefakt hinzu. Dabei handelt es
sich um eine Layout-Beschreibung. Somit findet die Beschreibung des Layout nicht
mehr im Generator statt, sondern muss nur noch frameworkspezifisch generiert
werden. In Abbildung \ref{Abb_konzept_3} ist das neue Konzept schematisch dargestellt.
\myBigFigure{konzept_3.jpg}{Konzeption der DSL-Umgebung (3.
Iteration)}{konzept_3}
\noindent
Da die Layout-Beschreibung in eine separate Datei ausgegliedert wurde, muss die
Referenzierung von \gks aus dem GUI-Skript mit den
Festlegungen in der Layout-Datei referenziert werden können.\\
Bezogen auf die im GUI-Skript definierten Bereiche ist aufgefallen,
dass die Angabe der Anzahl der Bereiche nicht notwendig ist. Grund dafür ist,
dass dieser Wert doppelt definiert weden würde. Einerseits direkt in der Angabe
der Anzahl und andererseits indirekt durch die Zuweisung der \gks und
eingebundenen GUI-Skripte zu den Bereichen. Ursprünglich war die Idee,
dass auf Basis dieser doppelten Angabe Validierungen ausgeführt werden können.
Die doppelte Deklarierung widerspricht jedoch der Anforderung, dass so wenig
Codezeilen wie möglich geschrieben werden sollen, um eine \acrshort{GUI} zu
beschreiben (siehe Anforderung \hyperref[AS4]{AS4}).\\
Weiterhin ist aufgefallen, dass in einem GUI-Skript nur eine
Properties Datei angegeben werden kann. In den GUI-Klassen der deg können jedoch
mehrere Properties-Dateien angegeben werden. Dies ist auch in der
GUI-DSL zu beachten.\\
Neben den \Ks \emph{Button} und \emph{Label} müssen folgende weitere
\Ks definiert werden können.
\begin{itemize}
  \item [] \textbf{Textfield}\\
  Ein Feld in dem ein einzeiliger Text editiert werden kann.
  \item [] \textbf{Textarea}\\
  Ein Feld in dem ein mehrzeiliger Text editiert werden kann.
  \item [] \textbf{Tree}\\
  Eine Baumstruktur in der mehrere Element eingebunden werden können.
  \item [] \textbf{Table}\\
  Eine Tabellenstruktur in der mehrere Elemente eingebunden werden können.
  \item [] \textbf{TabView}\\
  Eine Ansicht in der aus mehreren Taben eine Tab betrachtet werden kann. 
  \item [] \textbf{Interchangeable}\\
  Ein Bereich, in dem während der Laufzeit unterschiedliche \glspl{GUI}
  eingebunden werden können.
\end{itemize}
Weiterhin müssen die Bezeichnungen der
Interaktionstypen den Bezeichnungen der Interaktionsformen (IF) der deg
angeglichen werden. Darüber hinaus sollen folgende Standard-Interaktionstypen
in den \gks, die für den Prototypen benötigt werden, verwendet werden. (Zuerst
wird die Komponente genannt und anschließend die Standard-Interaktionstypen)
\begin{itemize}
  \item Label: IfTextDisplay
  \item Tree: IfTree, IfActivator
\end{itemize}
Diese Standard-Interaktionstypen müssen nicht in den jeweiligen Komponenten
definiert werden.
