\chapter{Festlegungen für die Entwicklung des Prototypen}\label{Aufteilung der
Anforderungen auf Sprache und Generator}
\section{Vorgehensmodell}
Das Vorgehensmodell für die Entwickler des DSL-Prototypen ist ein inkrementelles
Modell. Das bedeutet, dass mehrere Iterationen durchlaufen werden
(inkrementell), in denen unterschiedliche Versionen des Prototyps entwickelt werden.
\vcite{SauerDiss}{5} 
Inkrementelle Modelle können wie in Abbildung
\ref{Abb_inkrement} dargestellt werden.\\
Nach der Definition der Anforderungen wird der
Prototyp für die aktuelle Iteration entworfen und entwickelt. Im folgenden
Verlauf werden diese beiden Phasen nicht separiert. An die
Implementierung des Prototypen der aktuellen Iteration
schließt sich ein Review an. Innerhalb des Reviews wird der Prototyp der
aktuellen Iteration vorgestellt und weitere Anforderungen festgelegt,
bestehende Anforderungen geändert oder Änderungen am gesamten Konzept gemacht. 
Das führt wiederum zu einem neuen Entwurf, woran sich eine weitere
Implementierung anschließt. Dieser Zyklus wird somit mehrmals durchlaufen
(Iteration). \vcite{SauerDiss}{5} \\
\myBigFigure{inkrement.jpg}{Inkrementelles Modell}{inkrement}
\noindent
Grund für dieses Vorgehen ist, dass in der
deg bzgl.
DSL-Entwicklung wenig Know-How existiert. Aus den Iterationen soll so viel
Erfahrung und Wissen wie möglich geschöpft werden. Außerdem werden somit auch Irrwege aufgezeigt, die bei Entwicklung
anderer DSLs Beachtung finden können. Weiterhin können Anforderungen flexibel
angepasst und Missverständnisse reduziert werden, da der Entwicklungsprozess
transparent ist. \vcite{SauerDiss}{67}\\
Der weitere Verlauf (Kapitel \ref{Grobkonzept}, \ref{Entwicklung einer DSL zur
Beschreibung der GUI in profil c/s} und \ref{Entwicklung des Generators für das
Generieren von Klassen für das Multichannel-Framework}) wird die
durchgeführten Iterationen beschrieben. Dabei werden folgende Aspekte
beleuchtet.
\begin{itemize}
  \item \textbf{Vision} (siehe Kapitel \ref{Grobkonzept})\\
  Dabei wird das Konzept der DSL beschrieben. Bezogen auf die schematische
  Darstellung eines inkrementellen Modells (siehe Abbildung \ref{Abb_inkrement})
  ist die Vision als \emph{Anforderung} zu betrachten.
  \item \textbf{Entwicklung}\\
  Die Entwicklung beschreibt die Phasen \emph{Entwerfen} und
  \emph{Implementieren}. Sie teilt sich in zwei weitere Bereiche.
  \begin{itemize}
  	\item \textbf{Entwicklung der DSL} (siehe Kapitel \ref{Entwicklung einer DSL zur Beschreibung der GUI in profil c/s})
  	\item \textbf{Entwicklung eines Generators} (siehe Kapitel \ref{Entwicklung des Generators für das Generieren von Klassen für das Multichannel-Framework})
  \end{itemize}
\end{itemize}


\section{Grobkonzept der DSL-Umgebung (Vision)}\label{Grobkonzept}
\subsection{1. Iteration}
Die DSL-Umgebung soll sich in zwei Bereiche unterteilen. 
\begin{itemize}
  \item DSL zur Beschreibung des GUI
  \item Generator zur Generierung von Code
\end{itemize}
In Abbildung \ref{Abb_Konzept_1} sind die Artefaktion mit den
Funktionen (Blauer Kasten), die von ihnen umgesetzt werden sollen dargestellt.
\myBigFigure{konzept_1.jpg}{Konzeption der DSL-Umgebung (1.
Iteration)}{Konzept_1}
\noindent
Die elementare Aufgabe der GUI-Beschreibung ist es, die
\gks, die in dem GUI verwendet werden sollen, zu
definieren (siehe Anforderung \hyperref[AS1]{AS1}). Ausgehend von den für profil
c/s verwendeten \gks, können diese in drei Kategorien unterteilt werden.
\begin{itemize}
  \item []\textbf{{\Ks}}\\
  Dabei handelt
es sich um \acrshort{GUI}-Komponenten, deren Funktionen in unterschiedlichen \acrshort{GUI}-Frameworks 
ähnlich sind und in unterschiedlichen Anwendungen eingesetzt werden
können. Das bedeutet, dass sie nicht als domänenspezifisch angesehen werden
können. Beispiele hierfür sind \acrshort{GUI}-Komponenten wie der \emph{Button} oder das
\emph{Label}.
  \item[]\textbf{{\kks}}\\
  Diese zeichnen sich
dadurch aus, dass sie domänenspezifisch sind und speziell für profil c/s
entwickelt wurden und Interaktionen und Funktionalitäten bereits festgelegt
sind und nicht verändert werden können.
Ein Beispiel für eine komplexe Komponenten ist die \gloss{Multiselection-Komponente}. 

  \item[]\textbf{{Layout-Komponenten}}\\
  Dabei handelt es sich
um strukturgebende Komponenten. In anderen \acrshort{GUI}-Frameworks sind dies bspw.
\emph{Panel} (\gloss{Swing}), \emph{Div} (HTML) oder \emph{Pane} (JavaFX).
\end{itemize}
\noindent
Bei den Beschreibungen der \Ks muss auch die Möglichkeit bestehen Interaktionen
festzulegen (siehe Anforderung \hyperref[AS5]{AS5}). Zu einer Interaktion
gehört die Art der Interaktion und bestimmte Aktionen, die bei der Interaktion ausgeführt
werden. Die anderen \gks bestimmen haben festgelegte Interaktionsmöglichkeiten
(\kks) oder es ist nicht möglich mit ihnen zu interagieren (Layout-Komponenten).\\
Bezüglich der \knks ist darauf zu achten, dass sie für jedes verwendete
\acrshort{GUI}-Framework implementiert werden müssen. Damit wird verhindert,
dass die Entwickler, die bzgl. der \acrshort{GUI} nur mit der DSL arbeiten,
eigene \kks entwerfen, deren Wiederverwendungsgrad nierdirger ist, als wenn
diese Komponenten nach ausreichender Evaluation an einer zentralen Stelle
implementiert und bereitgestellt werden. Die Notwendigkeit dessen, dass die
Quellen für diese \knks sowohl zur Entwicklungszeit, als auch zur Laufzeit
vorhanden sein müssen, ist ein Nachteil dieses Konzeptes.\\
Beim Layout und den Layout-Komponenten ist besonders
auf die Ausdruckskraft der für die Beschreibung dieser Komponenten verwendeten Bezeichnungen zu
achten. Grund dafür ist, das sich bspw. auf dem Desktop ein Programmfenster als
oberste Layout Komponente festlegen lässt. In einem Web-Browser ist der Begriff
\emph{Fenster} als oberste Layout Komponenten jedoch nicht geläufig. Die
Komponente, die in einem Browser dem Programmfester auf dem Desktop am nächsten 
kommt, ist meiner Meinung nach das Tab.\\
Darüber hinaus sollen die Skripte für die Beschreibung der UIs so
konzipiert werden, dass es möglich ist andere GUI-Beschreibungen dort
einzubinden. Somit werden eingebundene GUIs wiederum zu UI-Komponenten.
Ziel dessen ist es, dass die Entwickler aus mehreren einfachen UIs ein komplexes
UI erstellen können (Modularisierung). Die Gefahr die dabei besteht ist, dass
mit der Zeit viel einfache GUI-Beschreibungen mit ähnlicher Strukturiert entwickelt werden. Da die
deg bei den GUIs von profil c/s ein bestimmtes Schema verfolgt (Cooperate
Design), sollte dieses Problem dadurch ausreichend eingedemmt sein. Wichtig ist
hierbei zu betonen, dass die DSL keine Sprache sein soll, mit der jedes GUI
beschrieben werden kann. Sie soll lediglich UIs für profil c/s beschreiben
können. Der Vorteil, der sich aus dieser starken Modularisierung ergibt, ist
dass viele GUI-Beschreibungen wiederverwendet werden können. So ist es meiner
Meinung nach möglich komplexe GUI-Beschreibungen zu entwickeln, die in
Fachabteilungen mit fachlichen Konzepten assoziiert werden können.\\\\
Beispielsweise können Suchmasken nach diesem Konzept gestaltet und beliebig
wiederverwendet und kombiniert werden. Hierzu werden unterschiedliche
Suchfelder definiert, die aus einem Label und einem Textfeld bestehen
(Beispiel siehe Abbildung \ref{Abb_suchfeld}).
\myBigFigure{suchfeld.jpg}{Beispiel: Suchfeld für Name}{suchfeld}
\noindent
In eine Suchmaske können mehrere dieser Suchfelder beliebig komponiert werden.
(Beispiel siehe Abbildung \ref{Abb_suchmaske}).
\myBigFigure{suchmaske.jpg}{Beispiel: Suchmaske}{suchmaske}
\noindent
Durch diese Möglichkeit der Komposition können auch komplexere fachliche
Konzepte auf das UI bezogen werden, wei z.B. \emph{Personensuche}.\\\\
Um die miteinander komponierten UI-Komponenten zu
strukturieren ist es notwendig, dass die GUI-Beschreibung Informationen über
die Anordnung der UI-Komponenten enthält. Diese Inforamtionen sollen
ausreichd abstrakt sein, damit sich diese Struktur auf unterschiedliche
UI-Frameworks beziehen lässt. Dazu wird die Struktur innerhalb eines GUIs als
Anordnung von Bereichen betrachtet. In der GUI-Beschreibung werden diesen
Bereichen die UI-Komponenten zugeordnet. Genauere Informationen über die
Anordnung dieser Bereiche dürfen nicht enthalten sein, da dies eine Orientierung
an bestimmte Layouts bedingt (was per Anforderung ausgeschlossen ist - siehe
Kapitel \ref{AllgAnforderungen}). Dazu ist weiterhin wichtig, dass den Bereichen jeweils nur eine Komponente zugeordnet werden kann. Dadruch wird der Zwang zur
vorher beschriebenen Komposition von eingebundenen GUI-Beschreibungen und
definierten UI-Komponenten verstärkt werden.\\
Der Generator übernimmt die konkrete Anordnung der beschriebenen Bereiche. Grund
dafür ist, dass die Anordung der Komponenten frameworkspezifisch ist
(teilweise werden unterschiedliche Layoutmanager in unterschiedlichen
Frameworks unterstützt). Da für jedes eingesetzte Framework ein eigener
Generator implementiert werden muss (siehe Kapitel \ref{Entwicklung einer
Lösungsidee}), ist es theoretisch möglich diese Aufgabe weitgehend unabhängig
von der Beschreibung der verwendeten Komponenten zu erfüllen.\\
Die wichtigste Aufgabe des Generator ist jedoch die Generierung des
frameworkspezifischen Quell-Codes.

\subsection{2. Iteration}
Nach dem Review der ersten Iteration des Prototypen wurde das grundsätzliche
Konzept um ein Artefakt erweitert (siehe Abbildung \ref{Abb_konzept_2}).
\myBigFigure{konzept_2.jpg}{Konzeption der DSL-Umgebung (2.
Iteration)}{konzept_2}
\noindent
Eine Änderung, die in dieser Grafik nicht dargestellt wird, ist, dass die
Aktionen, die bei Interaktionen mit UI-Komponenten ausgeführt werden sollen,
nicht in der GUI-Beschreibung definiert werden sollen. Grund dafür ist, dass
diese Aktionen sehr unterschiedlich bei profil c/s sind und somit kaum
abstrahiert werden können.\\
Eine weitere Änderung ist, dass die UI-Komponenten, die einer
GUI-Beschreibungen direkt definiert werden, in einer anderen Beschreibung, wo jene GUI-Beschreibung eingebunden ist, verändert werden können. Dadruch
werden die wiederverwendeten Beschreibungen anpassbar, was die Flexibilität
enorm steigert.\\
Darüber hinaus soll die Möglichkeit bestehen, bestimmte Werte, welche die
Attribute von UI-Komponenten annehmen können, in Properties-Dateien auszulagern.
Dadruch wird die GUI-Beschreibung weitgehend entlastet. Allerdings muss für die
Zuweisung von UI-Komponenten zu Wert-Beschreibung in der Properties-Datei und
dem DSL-Skript ein eindeutiger Schlüssel definiert werden.\\
Der Generator muss die festgelegten Properties-Dateien in die Generierung mit
einbeziehen und ihnen entsprechende Werte entnehmen. Dabei gilt die Festlegung,
dass wenn in der GUI-Beschreibung einem Attribut ein bestimmter Wert zugewiesen
ist, wird in der Properties-Datei (wenn eine festgelegt wurde) nicht mehr nach
diesem Attribut der Komponente gesucht.

\subsection{3. Iteration}
In dem Review, welches vor der 3. Iteration durchführt wurde, entstanden die
letzten Änderungen, die bzgl. der Sprache innerhalb dieser Arbeit Beachtung
finden. Das grundsätzliche Konzept wurde nochmals erweitert. Neben den bekannten
Artefakten der DSL-Umgebung kommt ein weiteres Artefakt hinzu. Dabei handelt es
sich um eine Layout-Beschreibung. Somit findet die Beschreibung des Layout nicht
mehr im Generator statt, sondern muss nur noch frameworkspezifisch generiert
werden. In Abbildung \ref{Abb_konzept_3} ist das neue Konzept schematisch dargestellt.
\myBigFigure{konzept_3.jpg}{Konzeption der DSL-Umgebung (3.
Iteration)}{konzept_3}
\noindent
Da die Layout-Beschreibung in eine separate Datei augegliedert wurde, muss die
Referenzierung von UI-Komponenten und Bereichen aus der GUI-Beschreibung mit den
Festlegungen in der Layout-Datei referenziert werden können.\\
Bezogen auf die in der GUI-Beschreibung definierten Bereiche ist aufgefallen,
dass die Angabe der Anzahl der Bereiche nicht notwendig ist. Grund dafür ist,
dass dieser Wert doppelt definiert weden würde. Einerseits direkt in der Angabe
der Anzahl und andererseits indirekt durch die Zuweisung der UI-Komponenten und
eingebundenen GUI-Beschreibungen zu den Bereichen. Ursprünglich war die Idee,
dass auf Basis dieser doppelten Angabe Validierungen ausgeführt werden können.
Die doppelte Deklaration wiederspricht jedoch der Anforderung, dass so wenig
LOCs wie möglich geschrieben werden sollen, um eine GUI zu beschreiben (siehe
Kapitel \ref{AllgAnforderungen}).\\
Weiterhin ist aufgefallen, dass in einer GUI-Beschreibung nur eine
Properties Datei angegeben werden kann. In den GUI-Klassen der deg können jedoch
mehrere Properties-Dateien angegeben werden. Dies ist auch in der
GUI-Beschreibung via DSL zu beachten.\\
Neben den \Ks \emph{Button} und \emph{Label} müssen folgende weitere
\Ks definiert werden können.
\begin{itemize}
  \item Textfield
  \item Textarea
  \item Tree
  \item Table
  \item TabPane
  \item Interchangeable\\
  Ein Bereich, in dem während der Laufzeit unterschiedliche UIs eingebunden
  werden können.
\end{itemize}
Weiterhin müssen die Bezeichnungen der
Interaktionstypen den Bezeichnungen der Interaktionsformen (IF) der deg
angeglichen werden. Darüber hinaus sollen folgende Standard-Interaktionstypen verwendet werden. (Zuerst wird die
Komponente genannt und anschließend die Standard-Interaktionstypen)
\begin{itemize}
  \item Button: IfActivator, IfTextDisplay
  \item Interchangeable: Änderung des GUIs
  \item Tree: Doppelklick
\end{itemize}
Diese Standard-Interaktionstypen müssen nicht in den jeweiligen Komponenten
definiert werden.
