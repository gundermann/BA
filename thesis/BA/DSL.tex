\chapter{Domänenspezifische Sprachen}\label{Domänenspezifische Sprachen}
\section{Begriffsbestimmungen}
\begin{itemize}
  \item[] \textbf{Sprache/Programmiersprache}\\
  Rein formal betrachtet ist eine Sprache ist eine beliebige Teilmenge aller
  Wörter über einem Alphabet.
  \emph{Ein Alphabet ist eine endliche, nichtleere Menge von Zeichen (auch
  Symbole oder Buchstaben genannt)}\cite[S.6]{hedtstueck}. Zur Verdeutlichung
  der Definition einer Sprache sein $V$ ein Alphabet und $k \in
  N$   \footnote{N ist die Menge der natürlichen Zahlen
  einschließig der Null. \cite[S.
  6]{hedtstueck} }. \emph{Eine endliche Folge ($x_1, \ldots, x_k$) mit $x_i
  \in V (i = 1, \ldots, k)$ heißt Wort über $V$ der Länge
  $k$}\cite[S.6]{hedtstueck}.\\
  Bei Programmiersprachen grenzt die Bestandteile einer Sprache wie folgt ab:
  \begin{itemize}
    \item[] \textbf{abstrakte Syntax}\\
    Die abstrakte Syntax ist eine Datenstruktur, welche die Kerninformationen eines
	Programms beschreibt.
	Sie enthält keinerlei Informationen über Details bezüglich der Notation. Zur
	Darstellungs dieser Datenstruktur werden abstrakte Syntaxbäume
	genutzt. \cite[S.179]{voelter}.
	\newpage
    \item[] \textbf{konkrete Syntax}\\
   	Die konkrete Syntax beschreibt die Notation der Sprache. Demnach bestimmt
   	sie, welche Sprachkonstrukte der Nutzer einsetzen kann, um ein Programm in
    dieser Sprache zu schreiben.
	Die konkrete Syntax wird in so genannten Parse-Bäumen (konkrete
	Syntaxbäume) dargestellt.\cite[S.87]{alfred}
    \item[] \textbf{statische Semantik}\\
    Die statische Semantik beschreibt die Menge an Regeln bezüglich des Typ-Systems, 
    die ein Programm befolgen muss. \cite[S.26]{voelter}
    \item[] \textbf{ausführbare Semantik}\\
    Die ausführbare Semantik ist abhängig vom Compiler. 
    Sie beschreibt wie ein Programm zu seiner Ausführung funktioniert.
    \cite[S.26]{voelter}
  \end{itemize}
  Programmiersprachen werden dazu verwendet, um mit einem Computer
  Instruktionen zukommen zu lassen. \cite[S.27]{fowler}
  \cite[S.27]{voelter}
  \item[] \textbf{General Purpose Language (GPL)}\\
  Bei GPLs handelt es sich um Programmiersprachen, die Turing-vollständig sind.
  Das bedeutet, dass mit einer GPL alles berechnet werden kann, was auch mit
  einer \gloss{Turing-Maschine} berechenbar ist. Völter et. Al. behaupten, dass
  alle GPLs aufgrund dessen untereinander austauschbar. Dennoch 
  sind Abstufungen bei der Ausführung dieser Programmiersprachen zu machen.
  Unterschiedliche GPL sind für spezielle Aufgaben optimiert.
  \cite[S.27f]{voelter}
  \newpage
  \item[] \textbf{Domain Specific Language (DSL)}\\
  Eine DSL ist eine Programmiersprache, welche für eine bestimmte \gloss{Domain}
  optimiert ist.\cite[S.28]{voelter} Das Entwickeln einer DSL ermöglicht es, die
  Abstarktion der  Sprache der Domäne anzupassen. \cite[S.10]{ghosh} Das
  bedeutet, dass Aspekte, welche für die Domäne unwichtig sind, auch von der
  Sprache außer Acht gelassen werden können (Abstraktion). Die Semantik und
  Syntax sollten dieser Abstraktionebene angepassen sein. Darüber hinaus sollte ein Programm,
  welches in einer DSL geschrieben wurde, alle Qualitätsanforderungen erfüllen, die auch bei einer Umsetzung des Programms mit anderen
  Programmiersprachen realisiert werden. \cite[S.10f]{ghosh} Eine DSL ist
  demnach in ihren Ausdrucksmöglichkeiten eingeschränkt. Je stärker diese Einschränkung
  ist, desto besser ist die Unterstützung der Domäne sowie die Ausdruckskraft
  der DSL. \cite[S.27f]{fowler} In machen Fällen findet eine Unterscheidung
  zwischen technischen DSLs und fachlichen DSL statt. Markus Völter
  unterscheidet diese beiden Kategorien im Allgemeinen dahingehend, dass
  technische DSLs von Programmierern genutzt werden und fachliche DSL von
  Personen, die keine Programmierer sind (bspw. Kunden bzw. Personen, die sich
  in der Domäne auskennen). \cite[S.26]{voelter}
  \item[] \textbf{Grammatik}\\
  Grammatiken und insbesondere Grammatikregeln können dazu verwendet um
  Sprachen zu beschreiben und somit auch den Aufbau eines
  Computerprogramms. \cite[S.23f]{hedtstueck} Für die Definition einer Grammatik
  verweise ich auf den Praxisbericht \cite[S.5ff]{gundermann5}. Grammatiken
  können in einer Hierachrie dargestellt werden (\emph{Chomsky-Hierarchie}). \cite[S.32f]{} Bei
  Programmiersprachen handelt es sich dabei um \emph{kontextfreie Sprachen}, da
  diese Sprachen entscheidar sind und somit von einem \gloss{Compiler}
  verarbeitet werden. \cite[S. 16f]{hedtstueck}
  
  \newpage
  \item[] \textbf{Parser}\\
  Ein Parser ist ein Teil der Infrastruktur der DSL. \cite[S.211]{ghosh} Er ist
  dafür verantworlich aus dem DSL-Script ein Output zu generieren, mit dem
  weitere Aktionen durchgeführt werden können.\cite[S.212]{ghosh} Der Output
  wird in Form eines Syntax-Baums (Parse-Baum) (\gloss{AST}) generiert.
  \cite[S.47]{fowler} Ein solcher Baum ist laut Martin Fowler eine weitaus nutzbarere Darstellung
  dessen, was mit dem DSL-Script dargestellt werden soll. 
  Daraus lässt sich auch das semantische Model generieren. \cite[S.48]{fowler}
  \item[] \textbf{Semantisches Model}\\
  Das semantische Model ist eine Repräsentation dessen, was mit der DSL
  beschrieben wurde. Es wird laut Martin fowler auch als das Framework oder
  die Bibliothek betrachtet, welche von der DSL nach außen hin sichtbar ist.
  \cite[S.159]{fowler} In Anlehnung an Ghosh ist das semantische
  Model mit dem AST gleichzusetzen, der durch eine
  laxikalische Analyse des DSL-Scripts mithilfe eines Parsers erzeugt wird.
  Somit wird es als Datenstruktur betrachtet, dessen Struktur von der Syntax der
  DSl unabhängig ist \cite[S.214]{ghosh}. Das Gleichsetzen des semantischen
  Models mit dem AST ist laut Martin Folwer in den meisten Fällen nicht
  effektiv. Grund dafür ist, dass der AST sehr stark an die Syntax der DSL
  gebunden, wohingegen das semantische Model von der Syntax unabhängig ist.
  \cite[S.48]{fowler}
  
  \newpage
  \item[] \textbf{Generator}\\
  In Anlehnung an Martin Fowler ist ein Generator ist ein Teil der einer
  \gloss{DSL Umgebung}, der für das Erzeugen von Quellcode für die
  \gloss{Zielumgebung} zuständig ist. \cite[S.121]{fowler} Bei der Generierung
  von Code wird zwischen zwei Arten unterschieden.
  \begin{itemize}
  	\item[] \textbf{Transformer Generation}\\
  	Bei der Transformer Generation wird das semantische Model als Input
  	verwendet, woraus Quellcode für die Zielumgebung generiert wird.
  	\cite[S.533f]{fowler} Eine solte Generation wird oft verwendet, wenn ein
  	Großteil des Output generiert wird und die Inhalte des semantischen Models
  	einfach in den Quellcode der Zielumgebung überführt werden
  	können.\cite[S.535]{fowler}
  	\item[] \textbf{Templated Generation} \\
  	Bei der Templated Generation wird eine Vorlage benötigt. In dieser Vorlage
  	befinden sich Platzhalter, an deren Stelle der Generator speziellen Code
  	generiert. \cite[S.539f]{fowler} Diese Art der Codegenerierung wird oft
  	verwendet, wenn sich in der generierte Quellcode für die Zielumgebung viele statische Inhalte befinden
  	und der dynamisch generierte Anteil sehr einfach gehalten
  	ist. \cite[S.541]{fowler}
  \end{itemize}
\end{itemize}

\newpage
\section{Anwendungsbeispiele}
Die Anwendungsbereiche für DSLs sind sehr unterschiedlich. Die bekanntesten DSL
sind Sprachen wie \emph{SQL} (zur Abfrage und Manipulation von Daten in einer
realtionalen Datenbank), \emph{HTML} (als Markup-Sprache für das Web) oder
\emph{CSS} (als Layoutbeschreibung). \cite[S.12]{ghosh} Alle Sprachen besitzen
eine eingeschärkte Ausdrucksmöglichkeiten und sind von der Abstraktion her direkt auf eine Domäne
(jeweils dahinter in Klammern genannt) zugeschnitten.\cite[S.12f]{ghosh}\\
Weitere Beispiele für DSL befinden sich im Bereich der
Sprachen für Parser-Generatoren (\emph{YACC}, \emph{ANTLR}) oder im Bereich der
Sprachen für das Zusammenbauen von Softwaresystemen (\emph{Ant}, \emph{Make}).
\cite[S.12]{ghosh}\\
Für den Bereich der UI-Entwicklung gibt es ebenfalls Anwendungsbeispiele. Diese
werden in Kapitel \ref{GUI-DSL} genauer beleuchtet.

\section{Model-Driven Software Development (MDSD)}\label{mdsd}
In der Einleitung wurde schon der Model-Driven Ansatz in Verbindung mit
UI-Entwicklung erwähnt. Dieser Ansatz versucht den technischen Lösungen der
IT-Industrie einen gewissen Grad an Agilität zu verleihen. \cite{3} Das ist
damit verbunden, dass die Produktion von Softwareprodukten schneller und besser
von statten geht und mit weniger Kosten verbunden ist. \cite[S.71]{mdsd}
Erreicht wird dies indem die Modelle formaler, strenger, vollständiger und konsistenter beschrieben werden. 
\cite[S.31]{voelter} Die Kernidee ist, dass die Modelle Quellcode oder
Funktionalitäten beschreiben und diese in der Evolution der Software immer
wiederverwendet werden können. \cite[S.72]{mdsd} Somit wird wiederkehrender
oder schematischer Quellcode vermieden und es ist möglich diese Modelle auch in
anderen Anwendungen zu verwenden. \cite[S.71]{mdsd}
Daraus lassen sich folgende Ziele des MDSD ableiten:
\begin{itemize}
  \item schnelleres Entwicklen durch Automatisierungen
  \item bessere Softwarequalität durch automatisierte Transformationen
  (Generation) und formalen Model-Definitionen
  \item Verhinderung von Wiederholungen und besseres Management von veränderbare
  Technologien durch die separierung der Gegenstandsbereiche\ldots\ldots\ldots.
  \item Bessere Wiederverwendung von Architekturen,
  Modelierungssprachen\footnote{bspw. eine DSL} und Generatoren/Transformatoren
  \item Verringerte Komplexität durch höhere Abstraktion
\end{itemize}
\cite[S.13f]{mdsdvoelter}
Die Modelle sind somit nicht länger nur zur Dokumentation geeignet. Sie sind
Teil der Software. \cite[S.14f]{mdsdvoelter} Die Modelle sind dabei auf ein
bestimmtes Domänenproblem angepasst. Um diese Modelle zu beschreiben wird eine
DSL benötigt. \cite[S.15]{mdsdvoelter} In Abbildung \ref{mdsd} ist die Idee des
MDSD schematisch dargestellt.
\myBigFigure{mdsd.jpg}{Die grundlegenden Ideen hinter dem MDSD
\cite[S.15]{mdsdvoelter}}{mdsd}
\section{Abgrenzung zu GPL}
Wie zu Beginn dieses Kapitels schon erwähnt sind GPLs. Sprachen mit denen alles
Berechnet werden kann, was auch mit einer Turing-Maschine berechenbar ist.
\cite[S.27]{voelter} Folglich kann mit einer GPL jedes berechenbare Problem
gelöst werden. Eine DSL hat diese Eigenschaft nicht. Da sie auf eine bestimmte
Domäne zugeschnitten ist, können auch nur Probleme innerhalb dieser Domäne mit
ihr gelöst werden.\cite[S.28]{voelter} Martin Fowler bezeichnet diese
Eigenschaft des Domänen Fokus als ein Schlüsselelement der Definition einer DSL.
\cite[S.27f]{fowler} Allein aus dieser Abgrenzung lassen sich bereits Vor- und
Nachteile von DSLs oder GPLs ableiten. Diese werden im folgenden Kapitel genauer
betrachtet.\\
\section{Vor- und Nachteile von DSL gegenüber GPL}
Gründe weshalb man eine DSL nutzen sollte, gibt es viele. Allerdings dürfen die
Herausforderungen, die aufkommen noch bevor man eine DSL einsetzen kann, nicht
außer Acht lassen. Bei der Erklärung der Vorteile wird davon ausgegangen, dass
eine DSL zum Einsatz bereit steht. Bei den Nachteilen hingegen wird i.d.R davon
ausgegangen, dass eine solche DSL erst noch entwickelt werden muss.
\subsection*{Vorteile}
\begin{itemize}
  \item \textbf{Verbesserte Produktivität bei der Entwicklung der
  Software}\cite{fowler}\cite{voelter}\cite{ghosh}
  
  \item \textbf{Bessere Kommunikation mit
  Domänen-Experten}\cite{fowler}\cite{voelter}\cite{ghosh}
  
  \item \textbf{Veränderung des Ausführungskontextes}\cite{fowler}
  
  \item \textbf{Alternativ berechenbares Model} \cite{fowler}
  
  \item \textbf{Höhere Qualität}\cite{voelter}	
  
  \item \textbf{Einfachere Validierung und Verifizierung}\cite{voelter}
  
  \item \textbf{Einfache Migration}\cite{voelter}
  
  \item \textbf{Plattform unabhängig}\cite{voelter}
  
  \item \textbf{Ausdruckskraft}\cite{ghosh}\cite{fowler}
  
  \item \textbf{Skalierbarkeit} \cite{ghosh} 
  Wobei Völter das eher als Gefahr sieht.
\end{itemize}

\subsection*{Nachteile}
\begin{itemize}
  \item \textbf{Sprach-Cacophony}\cite{fowler}\cite{ghosh}
  
  \item \textbf{Kosten für die Entwicklung der
  DSL}\cite{fowler}\cite{voelter}\cite{ghosh}
  
  \item \textbf{Ghetto Slang} \cite{fowler}
  
  \item \textbf{Blinkered Abstraktion}\cite{fowler}
  
  \item \textbf{Großes Know-How gefordert}\cite{voelter}\cite{ghosh}
  
  \item \textbf{Investitions-Gefängnis}\cite{voelter}
  
  \item \textbf{Unvollständige DSLs}\cite{voelter}
  
  \item \textbf{Kulturelle Herausforderungen}\cite{voelter}\cite{ghosh}
  
\end{itemize}

Zusammenfassend ist der Aufwand für die Vorbereitung des Einsatzes einer DSL
sehr hoch. Wurde eine DSL jedoch eingeführt, wird sich der Arbeitsaufwand um ein
Vielfaches verringern.
\section{Interne DSL}
Bei einer internen DSL handelt es sich um eine DSL, die in eine GPL integriert
sind. Sie übernehmen dabei das Typ-System der GPL in die sie
integriert sind.\cite[S.50]{voelter} In Betrachtung der Ziele auf Kapitel
\ref{mdsd} können einige dieser mit Applikation Interfaces (API) erreichen werden. 
Diese APIs werden i.d.R. für GPLs zur Verfügung gestellt. 
Martin Fowler sieht den großen Unterschied zwischen API und DSL darin, dass das
eine DSL neben einem abstrahierten Vokabular auch eine spezifische Grammatik
nutzt. \cite[S.29]{fowler} Zwischen einer internen DSL und einem API steht das
\emph{Fluent Interface} (\cite[S.50]{voelter}), welches als
Implementierungstechnik von internen DSL im Folgenden genauer beleuchtet wird.
\subsection{Implementierungstechniken}
\subsubsection*{Fluent Interfaces}
\subsubsection*{Parse-Tree Manipulation}
\subsubsection*{Annotationen}
\section{Externe DSL}
\subsection{Implementierungstechniken}
Bei den Implementierungstechniken von externen DSL geht es um die Art und Weise,
wie der DSL-Code vom Parser in ein semantisches Model oder einem AST überführt
wird. \cite[S.89]{fowler}  
\subsubsection*{Parser Generator}
\subsubsection*{Parser Kombinator}
\subsubsection*{Vermischung mit anderen Sprachen}
\section{Nicht-Textuelle DSL}
Bei den in den letzten Kapiteln vorgestellten internen und externen DSLs
handelt es sich um textuelle DSLs. Auch wenn eine DSL eine bestimmte domäne
repräsentiert, bedeutet dies nicht, dass diese Repräsentation 
immer textuell erfolgen muss. \cite[S.19]{ghosh} 
Es gibt einige Gründe, mit einer nicht-textuellen DSL zu arbeiten:
\begin{itemize}
  \item Viele Domänenprobleme können durch die Domänen-Nutzer besser durch
  Tabellen oder grafischen Darstellungen erklärt werden
  \item Domänenlogik ist in textueller Form oft zu komplex und enthält zu viele
  syntaktische strukturen
  \item visuelle Modelle sind einfacher zu durchdringen und zu verändern durch
  Domänenexperten
\end{itemize}\cite[S.19]{ghosh}
Für diesen Ansatz muss der Domänen-Nutzer die Repräsentation des Wissens über
eine Domäne in einem Editor (Projection Editor) visualisieren. Mit diesem Editor
kann der Domänen-Nutzer die Sicht auf die Domäne verändern, ohne auch nur eine
Zeile code schreiben zu müssen. Im Hintergrund generiert dieser Editor den Code,
welcher Sicht auf die Domäne modelliert. \cite[S.19f]{ghosh}
