\chapter{Domänenspezifische Sprachen}\label{Domänenspezifische Sprachen}
\section{Begriffsbestimmungen}
\begin{itemize}
  \item[] \textbf{Sprache/Programmiersprache}\\
  Rein formal betrachtet ist eine Sprache ist eine beliebige Teilmenge aller
  Wörter über einem Alphabet.
  \emph{Ein Alphabet ist eine endliche, nichtleere Menge von Zeichen (auch
  Symbole oder Buchstaben genannt)}\cite[S.6]{hedtstueck}. Zur Verdeutlichung
  der Definition einer Sprache sein $V$ ein Alphabet und $k \in
  N$   \footnote{N ist die Menge der natürlichen Zahlen
  einschließig der Null. \cite[S.
  6]{hedtstueck} }. \emph{Eine endliche Folge ($x_1, \ldots, x_k$) mit $x_i
  \in V (i = 1, \ldots, k)$ heißt Wort über $V$ der Länge
  $k$}\cite[S.6]{hedtstueck}.\\
  Bei Programmiersprachen grenzt die Bestandteile einer Sprache wie folgt ab:
  \begin{itemize}
    \item[] \textbf{abstrakte Syntax}\\
    Die abstrakte Syntax ist eine Datenstruktur, welche die Kerninformationen eines
	Programms beschreibt.
	Sie enthält keinerlei Informationen über Details bezüglich der Notation. Zur
	Darstellungs dieser Datenstruktur werden abstrakte Syntaxbäume
	genutzt. \cite[S.179]{voelter}.
	\newpage
    \item[] \textbf{konkrete Syntax}\\
   	Die konkrete Syntax beschreibt die Notation der Sprache. Demnach bestimmt
   	sie, welche Sprachkonstrukte der Nutzer einsetzen kann, um ein Programm in
    dieser Sprache zu schreiben.
	Die konkrete Syntax wird in so genannten Parse-Bäumen (konkrete
	Syntaxbäume) dargestellt.\cite[S.87]{alfred}
    \item[] \textbf{statische Semantik}\\
    Die statische Semantik beschreibt die Menge an Regeln bezüglich des Typ-Systems, 
    die ein Programm befolgen muss. \cite[S.26]{voelter}
    \item[] \textbf{ausführbare Semantik}\\
    Die ausführbare Semantik ist abhängig vom Compiler. 
    Sie beschreibt wie ein Programm zu seiner Ausführung funktioniert.
    \cite[S.26]{voelter}
  \end{itemize}
  Programmiersprachen werden dazu verwendet, um mit einem Computer
  Instruktionen zukommen zu lassen. \cite[S.27]{fowler}
  \cite[S.27]{voelter}
  \item[] \textbf{General Purpose Language (GPL)}\\
  Bei GPLs handelt es sich um Programmiersprachen, die Turing-vollständig sind.
  Das bedeutet, dass mit einer GPL alles berechnet werden kann, was auch mit
  einer \gloss{Turing-Maschine} berechenbar ist. Völter et. Al. behaupten, dass
  alle GPLs aufgrund dessen untereinander austauschbar. Dennoch 
  sind Abstufungen bei der Ausführung dieser Programmiersprachen zu machen.
  Unterschiedliche GPL sind für spezielle Aufgaben optimiert.
  \cite[S.27f]{voelter}
  \newpage
  \item[] \textbf{Domain Specific Language (DSL)}\\
  Eine DSL ist eine Programmiersprache, welche für eine bestimmte \gloss{Domain}
  optimiert ist.\cite[S.28]{voelter} Das Entwickeln einer DSL ermöglicht es, die
  Abstarktion der  Sprache der Domäne anzupassen. \cite[S.10]{ghosh} Das
  bedeutet, dass Aspekte, welche für die Domäne unwichtig sind, auch von der
  Sprache außer Acht gelassen werden können (Abstraktion). Die Semantik und
  Syntax sollten dieser Abstraktionebene angepassen sein. Darüber hinaus sollte ein Programm,
  welches in einer DSL geschrieben wurde, alle Qualitätsanforderungen erfüllen, die auch bei einer Umsetzung des Programms mit anderen
  Programmiersprachen realisiert werden. \cite[S.10f]{ghosh} Eine DSL ist
  demnach in ihren Ausdrucksmöglichkeiten eingeschränkt. Je stärker diese Einschränkung
  ist, desto besser ist die Unterstützung der Domäne sowie die Ausdruckskraft
  der DSL. \cite[S.27f]{fowler} In machen Fällen findet eine Unterscheidung
  zwischen technischen DSLs und fachlichen DSL statt. Markus Völter
  unterscheidet diese beiden Kategorien im Allgemeinen dahingehend, dass
  technische DSLs von Programmierern genutzt werden und fachliche DSL von
  Personen, die keine Programmierer sind (bspw. Kunden bzw. Personen, die sich
  in der Domäne auskennen). \cite[S.26]{voelter}
  
  \item[] \textbf{Grammatik}\\
  Grammatiken und insbesondere Grammatikregeln können dazu verwendet um
  Sprachen zu beschreiben und somit auch den Aufbau eines
  Computerprogramms. \cite[S.23f]{hedtstueck} Für die Definition einer Grammatik
  verweise ich auf den Praxisbericht \cite[S.5ff]{gundermann5}. Grammatiken
  können in einer Hierachrie dargestellt werden (\emph{Chomsky-Hierarchie}). \cite[S.32f]{} Bei
  Programmiersprachen handelt es sich dabei um \emph{kontextfreie Sprachen}, da
  diese Sprachen entscheidar sind und somit von einem \gloss{Compiler}
  verarbeitet werden. \cite[S. 16f]{hedtstueck}
  
  \newpage
  \item[] \textbf{Lexikalische Analyse}\\
  Bevor ein DSL-Script verarbeitet werden kann, muss es vom so genannten
  \emph{Lexer} oder \emph{Scanner} gelesen werden. \cite[S.221]{fowler} Dabei
  wird ein Texte (DSL-Script) als Input-Stream betrachtet. Der Lexer wandelt diesen Input-Stream in einzelne
  Tokens. vgl. \cite[S.220]{ghosh} Allgemein ist der Lexer die Instanz
  innerhalb der Infrastruktur einer DSL, die für das Auslesen des
  DSL-Scriptes verantwortlich ist.
    
  \item[] \textbf{Parser}\\
  Ein Parser ist ein Teil der Infrastruktur der DSL. \cite[S.211]{ghosh} Er ist
  dafür verantworlich aus dem DSL-Script ein Output zu generieren, mit dem
  weitere Aktionen durchgeführt werden können.\cite[S.212]{ghosh} Der Output
  wird in Form eines Syntax-Baums (Parse-Baum) (\gloss{AST}) generiert.
  \cite[S.47]{fowler} Ein solcher Baum ist laut Martin Fowler eine weitaus nutzbarere Darstellung
  dessen, was mit dem DSL-Script dargestellt werden soll. 
  Daraus lässt sich auch das semantische Model generieren. \cite[S.48]{fowler}
  \item[] \textbf{Semantisches Model}\\
  Das semantische Model ist eine Repräsentation dessen, was mit der DSL
  beschrieben wurde. Es wird laut Martin fowler auch als das Framework oder
  die Bibliothek betrachtet, welche von der DSL nach außen hin sichtbar ist.
  \cite[S.159]{fowler} In Anlehnung an Ghosh ist das semantische
  Model mit dem AST gleichzusetzen, der durch eine
  laxikalische Analyse des DSL-Scripts mithilfe eines Parsers erzeugt wird.
  Somit wird es als Datenstruktur betrachtet, dessen Struktur von der Syntax der
  DSl unabhängig ist \cite[S.214]{ghosh}. Das Gleichsetzen des semantischen
  Models mit dem AST ist laut Martin Folwer in den meisten Fällen nicht
  effektiv. Grund dafür ist, dass der AST sehr stark an die Syntax der DSL
  gebunden, wohingegen das semantische Model von der Syntax unabhängig ist.
  \cite[S.48]{fowler}
  
  \newpage
  \item[] \textbf{Generator}\\
  In Anlehnung an Martin Fowler ist ein Generator ist ein Teil der einer
  \gloss{DSL Umgebung}, der für das Erzeugen von Quellcode für die
  \gloss{Zielumgebung} zuständig ist. \cite[S.121]{fowler} Bei der Generierung
  von Code wird zwischen zwei Arten unterschieden.
  \begin{itemize}
  	\item[] \textbf{Transformer Generation}\\
  	Bei der Transformer Generation wird das semantische Model als Input
  	verwendet, woraus Quellcode für die Zielumgebung generiert wird.
  	\cite[S.533f]{fowler} Eine solte Generation wird oft verwendet, wenn ein
  	Großteil des Output generiert wird und die Inhalte des semantischen Models
  	einfach in den Quellcode der Zielumgebung überführt werden
  	können.\cite[S.535]{fowler}
  	\item[] \textbf{Templated Generation} \\
  	Bei der Templated Generation wird eine Vorlage benötigt. In dieser Vorlage
  	befinden sich Platzhalter, an deren Stelle der Generator speziellen Code
  	generiert. \cite[S.539f]{fowler} Diese Art der Codegenerierung wird oft
  	verwendet, wenn sich in der generierte Quellcode für die Zielumgebung viele statische Inhalte befinden
  	und der dynamisch generierte Anteil sehr einfach gehalten
  	ist. \cite[S.541]{fowler}
  \end{itemize}
\end{itemize}

\newpage
\section{Anwendungsbeispiele}
Die Anwendungsbereiche für DSLs sind sehr unterschiedlich. Die bekanntesten DSL
sind Sprachen wie \emph{SQL} (zur Abfrage und Manipulation von Daten in einer
realtionalen Datenbank), \emph{HTML} (als Markup-Sprache für das Web) oder
\emph{CSS} (als Layoutbeschreibung). \cite[S.12]{ghosh} Alle Sprachen besitzen
eine eingeschärkte Ausdrucksmöglichkeiten und sind von der Abstraktion her direkt auf eine Domäne
(jeweils dahinter in Klammern genannt) zugeschnitten.\cite[S.12f]{ghosh}\\
Weitere Beispiele für DSL befinden sich im Bereich der
Sprachen für Parser-Generatoren (\emph{YACC}, \emph{ANTLR}) oder im Bereich der
Sprachen für das Zusammenbauen von Softwaresystemen (\emph{Ant}, \emph{Make}).
\cite[S.12]{ghosh}\\
Für den Bereich der UI-Entwicklung gibt es ebenfalls Anwendungsbeispiele. Diese
werden in Kapitel \ref{GUI-DSL} genauer beleuchtet.

\section{Model-Driven Software Development (MDSD)}\label{mdsd}
In der Einleitung wurde schon der Model-Driven Ansatz in Verbindung mit
UI-Entwicklung erwähnt. Dieser Ansatz versucht den technischen Lösungen der
IT-Industrie einen gewissen Grad an Agilität zu verleihen. \cite{3} Das ist
damit verbunden, dass die Produktion von Softwareprodukten schneller und besser
von statten geht und mit weniger Kosten verbunden ist. \cite[S.71]{mdsd}
Erreicht wird dies indem die Modelle formaler, strenger, vollständiger und konsistenter beschrieben werden. 
\cite[S.31]{voelter} Die Kernidee ist, dass die Modelle Quellcode oder
Funktionalitäten beschreiben und diese in der Evolution der Software immer
wiederverwendet werden können. \cite[S.72]{mdsd} Somit wird wiederkehrender
oder schematischer Quellcode vermieden und es ist möglich diese Modelle auch in
anderen Anwendungen zu verwenden. \cite[S.71]{mdsd}
Daraus lassen sich folgende Ziele des MDSD ableiten:
\begin{itemize}
  \item schnelleres Entwicklen durch Automatisierungen
  \item bessere Softwarequalität durch automatisierte Transformationen
  (Generation) und formalen Model-Definitionen
  \item Verhinderung von Wiederholungen und besseres Management von veränderbare
  Technologien durch die Trennung der Funktionsbereiche (Separation of Concers).
  \item Architekturen,
  Modelierungssprachen\footnote{bspw. eine DSL} und Generatoren/Transformatoren
  können besser wiederverwendet werden
  \item Verringerte Komplexität durch höhere Abstraktion
\end{itemize}
\cite[S.13f]{mdsdvoelter}\\
Die Modelle sind somit nicht länger nur zur Dokumentation geeignet. Sie sind
Teil der Software. \cite[S.14f]{mdsdvoelter} Die Modelle sind dabei auf ein
bestimmtes Domänenproblem angepasst. Um diese Modelle zu beschreiben wird eine
DSL benötigt. \cite[S.15]{mdsdvoelter} In Abbildung \ref{mdsd} ist die Idee des
MDSD schematisch dargestellt.
\myBigFigure{mdsd.jpg}{Die grundlegenden Ideen hinter dem MDSD
\cite[S.15]{mdsdvoelter}}{mdsd}

\newpage
\section{Abgrenzung zu GPL}
Wie zu Beginn dieses Kapitels schon erwähnt sind GPLs. Sprachen mit denen alles
Berechnet werden kann, was auch mit einer Turing-Maschine berechenbar ist.
\cite[S.27]{voelter} Folglich kann mit einer GPL jedes berechenbare Problem
gelöst werden. Eine DSL hat diese Eigenschaft nicht. Da sie auf eine bestimmte
Domäne zugeschnitten ist, können auch nur Probleme innerhalb dieser Domäne mit
ihr gelöst werden.\cite[S.28]{voelter} Martin Fowler bezeichnet diese
Eigenschaft des Domänen Fokus als ein Schlüsselelement der Definition einer DSL.
\cite[S.27f]{fowler}
\section{Vor- und Nachteile von DSL gegenüber GPL}
\subsection*{Vorteile}
\begin{itemize}
 \item \textbf{Ausdruckskraft}\\
 Laut Ghosh sollten DSLs so umgesetzt werden, dass sie präsize sind. Das
 bedeutet, dass eine DSL zu sehen, zu betrachten,
 vorzustellen und es zu zeigen ist.\footnote{Diese vier
 Schritte beschreiben den Prozess des visuellen Denkens. \cite{Roam2009}}
 Weiterhin ist es wichtig bei der Entwicklung einer DSL darauf zu
 achten, dass sich die Abstraktion der Sprache präzise an der semantik
 der Domäne orientiert. \cite[S.20]{ghosh} Resultat dessen ist es, dass das
 Verständis für das, was entwickelt wird verbessert wird und die Abstraktion
 auf einer höheren Ebene beherrschbar bleibt. (vgl. \cite{journals/insk/BrauerCK08})
 
  \item \textbf{Höhere Qualität}\cite{voelter}\\
  Bei der Entwicklung einer DSL werden Sprachkonstrukte und Freiheitsgrade
  der Sprache festgelegt. Richtig konzipiert, schränken sie den Entwickler beim
  Umgang mit dieser DSL so ein, dass doppelter Code und doppelte Arbeit
  verhindert wird. Zusätzlich wird die Anzahl von Fehlern
  verringert. \cite[S.40f]{voelter} Auch durch die hohe Abstraktion einer DSL
  wird die Wiederverwendung von Code gefördert, was ebenso zu qualitativ höherem
  Code führt. \cite[S.21]{ghosh}
  
  \newpage
  \item \textbf{Verbesserte Produktivität bei der Entwicklung der
  Software}\\
  Durch die Ausdruckskraft und der Abstraktion der Sprache muss i.d.R. auch
  weniger DSL-Code für die Implementierung eines Programms geschrieben werden, als wenn dieses
  Programm mit einer GPL implementiert wird. Wobei man
  mit einem entsprechenden Framework für GPLs
  ähnliches erreichen könnte. \cite[S.40]{voelter}\\
  Die stärkere Ausdruckskraft führt zu einer
  bessere Lesbarkeit von DSL-Code im
  Verlgiech zu GPL-Code, wordurch DSL-Code einfacher
  zu verstehen ist. Dadurch ist es
  auch einfacher Fehler in diesem Code zu
  finden, sowie Apassungen an dem System
  vorzunehmen. Bei einer GPL werden diese Vorteile durch Dokumentationen,
  ausdrucksvolle Varialblenbezeichnungen und festgeleten Konventionen
  angestrebt.
  \cite[S.33]{fowler} Dies ist jedoch mit einem
  höheren Aufwand verbunden. Zumal der Entwickler diese Vorschriften
  von sich aus einhalten muss. Bei der Verwendung
  einer DSL ist er zur Umsetzung einer besseren Lesbarkeit gezwungen, da die
  Sprache es nicht anders zulässt.
  
  
  \item \textbf{Bessere Kommunikation mit
  Domänen-Experten und Kunden}\\
  Aufgrund domänenspezifischer und präziser Ausdrücke,
  die in der Sprache verwendet
  werden, sind die Domänen-Experten bzw.
  die Kunden vertrauter mit der Implementiertung,
  als wenn für die Umsetzung eine GPL
  verwendet werden würde. \cite[S.42]{voelter}  Die hohe Ausdruckskraft fördert
  das Verständnis dieser DSL. Damit ist es einfacher, die Kunden in die
  Entwicklung mit einzubeziehen. Dabei sollten jedoch zusätzliche Hilfsmittel
  wie Visualisierungen oder Simulationen verwendet
  werden.\cite[S.34]{fowler}, \cite[S.42]{voelter} Das fördert die Kommunikation
  zwischen Kunden und Auftragnehmen, die oft vernachlässnigt wird. Martin Fowler beschreibt sogar den Einsatz einer DSL als reine Kommunikationplattform als
  vorteilhaft. \cite[S.34f]{fowler} Grund dafür ist auch, dass die Entwicklung
  einer DSL das Verständnis der Domäne des Auftragnehmers steigert.
  \cite[S.41]{voelter}
  
  \newpage
  \item \textbf{Plattformunabhängigkeit}\cite{fowler}\\
  Durch die Nutzung einer DSL kann ein Teil der Logik von der Kompilierung in
  den Ausführungskontext überführt werden. Die Definition der Logik findet dabei
  in der DSL statt, welche erst bei der Ausführung evaluiert werden. Das wird
  auch oft unter der Verwendung von XML umgesetzt. \cite[S.35]{fowler} Dadurch
  ist es möglich die Logik auf unterschiedlichen Plattformen auszuführen.
  \cite[S.43]{voelter} Dieser Vorteil ist besonders für den praktischen Teil
  dieser Arbeit interessant.
  
  \item \textbf{Einfachere Validierung und Verifizierung}\\
  Da DSLs Details der implementierung ausblenden sind sie auf semantischer Ebene
  reichhaltiger als GPLs. Das führt dazu, dass Analsyen einfacher umzusetzten
  sind und Fehler-Meldungen verständlicher gestaltet werden können, indem die
  Terminologie der Domäne verwendet wird. Dadruch und durch die vereinfachte
  Kommunikation mit den Domänen-Experten werden Reviews und Validierungen des
  Code weitaus effizienter. \cite[S.41]{voelter}
  
  
  \item \textbf{Unabhängigkeit von Technologien}\\
  Die Modelle, die zur Beschreibung von Systemen verwendet werden, können so
  gestaltet werden, dass sie von Implementierungstechniken unabhängig sind. Dies
  wird durch ein hohes Abstarktionsniveau ereicht, welches an die Domäne
  angepasst ist. Dadruch kann die Beschreibung der Modelle von den genutzten
  Technologien weitgehend entkoppelt werden. \cite[S.41]{voelter}
  
  \newpage
  \item \textbf{Skalierbarkeit des Entwicklungsprozess}\\
  Die Integration von neuen Mitarbeitern in ein Entwicklerteam forder immer
  eine gewisse Einarbeitungszeit. Diese Einarbeitungszeit kann durch die
  Nutzung einer DSL verküzt werden, wenn die DSL eine hohen Abstraktionsgrad
  hat und dadurch leichter verstehen und zu erlernen ist.\cite[S.21]{ghosh}
  Innerhalb eines Entwickler-Teams haben die Mitarbeiter oft einen
  unterschiedlicher Erfahrungstand bzgl. einer speziellen Programmiersprache,
  die zur Entwicklung genutzt werden soll. Erfahrene Teammitglieder können sich
  mit der Implementierung der DSL befassen und die Grundlage für die anderen 
  Teammitglieder schaffen. Diese wiederum nutzen die DSL um die fachlichen
  Anforderung der Kunden zu implementieren. \cite[S.21]{ghosh} Markus Völter
  hingegen sieht die Teilung der Programmieraufgaben als Gefahr bzw. Nachteil.
  \cite[S.44]{voelter}
\end{itemize}

\subsection*{Nachteile}
\begin{itemize}
  \item \textbf{Großes Know-How gefordert}\\
  Bevor die Vorteile einer DSL genutzt werden können, muss die DSL entwickelt
  werden. \cite[S.43]{voelter} Das Designen einer Sprache ist eine komplexe
  Aufgabe, die nur schwer skalierbar. \cite[S.21]{ghosh}Die Vorteile, die eine
  DSL bietet, können nur geboten werden, wenn diese DSL auch entsprachend gutes
  Konzept hat. Dazu muss zum einen der richtige Abstraktionsgrad gefunden
  werden und zum anderen die Sprache so einfach wie möglich gehalten werden.
  Für beide Aufgaben werden Entwickler benötigt, die viel Erfahrung mit
  Sprach-Design haben. \cite[S.44]{voelter}
  
  \newpage
  \item \textbf{Kosten für die Entwicklung der
  DSL}
  Bei wirtschaftliche Entscheidungen wird der Input mit dem Output verglichen.
  Investitionen führen dazu, dass der Input größer wird. Da eine DSL vor dem
  Einsatz zuerst entwickelt werden muss, ist notwendig Investitionen für die
  Entwickler der DSL zu tätigen. Ob sich eine Investition lohnt, wird mittels
  vorher durchzuführenden Analysen überprüft. Dabei muss festgestellt werden,
  ob die Entwicklung der DSL gerechtfertigt ist. Im Bereich der technischen DSLs
  ist fällt die Rechtfertigung einfach, da diese DSLs oft wiederverwendet werden
  können. Fachliche DSL hingegen haben oft eine weitaus kompaktere Domäne, als
  eine technische DSL. Daher ergeben sich die Möglichkeiten zur
  Wiederverwendung erst zu einem späteren Zeitpunkt und
  können nur schwer von der im Vorfeld durchgeführten
  Analyse wahrgenommen werden.\cite[S.43]{voelter}\\
  Weiterhin ist in der Phase, in der die DSL entwickelt wird, keine große
  positive Änderungen in den Kosten zu erwarten. Die Kosten reduzieren sich
  i.d.R erst wenn die DSL eingesetzt wird. \cite[S.21]{ghosh}\\
  Bevor eine DSL entwickelt werden kann, sollte ein entsprechendes Know-How
  aufgebaut werden. Der Aufbau dieses Wissens erfordert wiederum Kosten.
  \cite[S.37]{fowler}
  
  \item \textbf{Investitions-Gefängnis}\cite{voelter}\\
  Der Begriff stammt von Markus Völter. Er beruht auf der Annahme, dass sich ein
  Unternehmen dessen bewusst ist, dass mehr Investitionen in wiederverwendbare
  Artefakte zu einer besseren Produktivität führen. \cite[S.45]{voelter}
  Artefakte, die wiederverwendet werden können, führen dennoch zu Einschränkungen. Die
  Flexibilität geht dabei verloren. Dabei besteht die Gefahr, dass die Artefakte
  aufgrund geänderter Anforderungen, unbrauchbar werden.
  Weiterhin ist es auch gefährlich Artefakte zu Verändern, die häufig wiederverwendet werden, da
  durch diese Veränderung Nebeneffekte auftreten können, die nicht erwüscht
  sind.
  Somit muss das Unternehmen wiederum mehr investieren um die Anforderungen
  umzusetzen. Von daher der verwendete Begriff \emph{Investitions-Gefängnis}.

\newpage
  \item \textbf{Kakophonie}\\
  Die Kakophonie beschreibt eine schlechten Klang einer Sprache. Eine DSL
  abstrahiert von Domänen-Model. \cite[S.22]{ghosh} Je besser diese Absatrktion
  ist, desto euphonischer und ausdrucksstärker ist die Sprache. Dass dafür viel
  Erfahrung benötigt wird, wurde bereits erwähnt.\\
  Normaler Weise werden für eine Applikation mehrere DSLs benötigt. Diese
  unterschiedlichen DSLs haben i.d.R unterschiedliche syntaktische Strukturen.
  Das führt dazu, dass Mitarbeiter immer wieder neue Sprachen lernen müssen. Das
  wiederum führt zu höheren Kosten. Weiterhin müssen die Entwickler bei der
  Verwendung mehrerer Sprachen öfter umdenken, als wenn sie fortwährend mit
  einer Sprache arbeiten würden. Das macht den Entwicklungsprozess weitaus
  komplizierter. \cite[S.37]{fowler}

  \item \textbf{Ghetto Slang}\\
  Dieser Nachteil steht in Konstrast zum Punkt \emph{Kakophonie}. Wenn ein
  Unternehmen nur mit eigenen DSLs arbeitet, die niemand sonst kennt, oder
  einsatzt, gleichen diese Sprachen einem Ghetto Slang, die niemand sonst
  versteht. Dadruch ist es schwer neue Technologien in den Bereichen, wo vermehr
  DSLs eingesetzt werden, zu integrieren. Außerdem ist es kaum möglich von neuen
  Mitarbeitern in diesem Bereichen zu provitieren, da diese sich
  höchwahrscheinlich nicht einmal diese DSLs kennen. \cite[S.38]{fowler}\\
  Dieser Punkt ist auch in Verbindung mit dem \emph{Investitions-Gefängnis} zu
  betrachten. Durch die Verwendung übermäßig vieler DSLs ist das Unternehmen
  gezwungen, diese durch eine große Investition abzusetzen und allgemein
  bekannte Technologien einzuführen, um von diesen zu profitieren, oder das
  Unternehmen investiert weiter in die Entwicklung eigener DSLs um seine Systeme
  aufrecht zu erhalten.
  
  \newpage
  \item \textbf{Abstraktion als Scheuklappen}\\
  Abstraktion ist von großer Wichtigkeit für eine DSL. Wenn ein Entwickler mit
  der Arbeit an einer DSL begonnen hat, hat dieser die Abstraktion
  in einem bestimmen Maß bereits festgelegt. Ein Problem tritt auf,
  wenn im Nachhinein etwas mit der Sprache beschrieben werden soll,
  dass nicht zu der Abstraktion der Sprache passt. Dabei besteht
  die Gefahr, dass der Entwickler sich von der Abstraktion der
  Sprache gefangen nehmen lässt. Das bedeutet, dass der Entwickler
  versucht, das Problem aus der realen Welt auf seine Abstraktion
  anzupassen. Der richtige Weg hingegen ist es, die Sprache und
  deren Abstraktionsgrad so anzupassen, dass das Problem mit
  beschrieben werden kann. \cite[S.39]{fowler}
  
  \item \textbf{Kulturelle Herausforderungen}\\
  Die genannten Nachteile den Einsatzes von DSLs führen zu Äußerungen wie
  \emph{Die Entwicklung von Sprachen ist kompliziert}, \emph{Domänen-Experten
  sind keine Programmieren} oder \emph{Ich möchte nicht schon wieder eine
  neue Sprache lernen} (\emph{Yet-Another-Language-To-Learn
  Syndrom}\cite[S.22]{ghosh}).
  Solche kulturellen Probleme entstehen immer, wenn etwas neues eingeführt
  werden soll. \cite[S.45]{voelter} Die Mitarbeiten müssen demnach entsprechend
  geschult und motiviert werden.
  
  \newpage
  \item \textbf{Unvollständige DSLs}\\
  Wenn ein Unternehmen viel Erfahrung bei der
  Entwicklung von DSLs aufgebaut hat und die Entwicklung
  durch entsprechende Tools vereinfacht wurde, besteht
  die Gefahr, dass DSLs zu schnell entwickelt werden.  Durch die
  Einfachheit der Entwicklung scheint es einfacher eine neue DSL zu entwickeln,
  als nach bestehenden Ansätzen für dasselbe Problem zu suchen.
  \cite[S.44f]{voelter} Der Gedanke daran, dass sich die Investition in die
  Entwicklung einer DSL zu einem späteren Zeitpunkt armotisieren wird, bestätigt
  diese Haltung. \cite[S.38]{fowler} Dadurch entstehen immer mehr DSLs, die auf
  gleichen Problemen basieren, aber inkopatibel zueinander sind. Außerdem
  führt der Fakt, dass die Entwicklung einer DSL bei dem Verstehen der Domäne
  und dem Entwerfen des Models sehr hilfreich ist, dazu,
  dass eine DSL nur zum Verständis des Problems oder der Domäne genutzt
  wird. \cite[S.38]{fowler} Das wiederum führt dazu, dass mehrere halb-fertige
  DSLs existieren. Markus Völter et. Al. nennen dieses Phanomän die \emph{DSL
  Hell}.
  \cite[S.44f]{voelter}
\end{itemize}
Zusammenfassend ist zu sagen, dass der Aufwand für die Vorbereitung des
Einsatzes einer DSL sehr hoch ist. Wurde eine DSL jedoch eingeführt, wird sich
der Arbeitsaufwand um ein Vielfaches verringern und der letzendliche
Gewinn fällt höher aus. \cite[S.21]{ghosh}
\section{Interne DSL}
Bei einer internen DSL handelt es sich um eine DSL, die in eine GPL integriert
sind. Sie übernehmen dabei das Typ-System der GPL in die sie
integriert sind.\cite[S.50]{voelter} In Betrachtung der Ziele aus Kapitel
\ref{mdsd} können einige dieser mit Application Programming Interfaces (API)
erreichen werden.
In vielen Fällen ist eine DSL nicht mehr als ein API.
Martin Fowler sieht den größten Unterschied zwischen API und DSL darin, dass das
eine DSL neben einem abstrahierten Vokabular auch eine spezifische Grammatik
nutzt (\cite[S.29]{fowler}), welche die Syntax der DSL bestimmt. Ein API
hingegen besitzt die gleichen syntaktischen Strukturen wie die GPL, in der das
API bereitgestellt wurde. Somit werden überflüssige Notationsformen in das API
mit übernommen, was bei einer DSL nicht der Fall ist. \cite[S.30]{voelter}
Weiterhin können DSLs so konstruiert werden, dass durch Restriktionen und
Limitierungen nur korrekte Programme geschrieben werden können. Markus Völter
et. al. bezeichnen diese Eigenschaft als \emph{correct-by-construction}.
\cite[S.30]{voelter} 
\subsection{Implementierungstechniken}
\subsubsection*{Parse-Tree Manipulation}
Allgemein betrachtet funktioniert diese Technik wie folgt.\\ Ein Code-Fragment,
welches zu einem Späteren Zeitpunkt ausgewertet werden soll, als es gelesen
wurder, wird in einem Parse-Tree hinterlegt. Dieser Parse-Tree wird noch vor der
Ausführung modifiziert. Um diese Implementierungstechnik nutzen zu können, muss
eine Umgebung vorliegen in der es möglich ist ein Code-Fragment in einen
Parse-Tree umzuformen und diesen zu bearbeiten. Diese Möglichkeit existiert
nur in wenigen Sprachen.
Martin Fowler et. al. geben hierzu nur die Beispiele C\#, ParseTree (Ruby) und
Lisp. \cite[S.45f]{fowler}\\
Anders als Lisp bieten die anderen Beispiele die
Möglichkeit über den Parse-Tree zu iterieren. Bei Lisp-Code handelt es sich
schon um einen Parse-Tree von verschachtelten Listen. Bei der Iteration über den
Parse-Tree ist aufgrund der Performance darauf zu achten, dass möglichst nur die
notwendigen Teile des Baum beachtet werden. \cite[S.46]{fowler}\\
Konstrukte, die in der Hostsprache geschrieben
wurden und nicht verändert werden sollen, spielen
bei der Parse-Tree Manipulation keine Rolle, um das semantische Model zu
erzeugen. \cite[S.46]{fowler}

\newpage
\subsubsection*{Fluent Interfaces}
In einem klassischen API hat jede Methode eine eigene
Aufgabe und ist nicht von anderen Methoden in diesem API abhängig.
\cite[S.28]{fowler} In einer internen DSL hingenen ist es möglich Methoden
bereitzustellen, die hintereinander gekettet werden können und somit komplette
Sätze darstellen. Somit wird der Output einer Methode zum Input der folgenden
Methode. Die Lesbarkeit der DSL wird dadurch weitaus besser, da es einer
Sequenz von Aktionen gleicht, die in der Domäne ausgeführt werden
(vgl. \cite[S.94]{ghosh}) und ohne eine Vielzahl von Variablen aufgerufen werden
müssen (vgl. \cite[S.68]{fowler}). Eine solche Verkettung von Methoden wird als
\emph{Fluent Interface} bezeichnet. Das Fluent Interface steht laut Voelter et.
al. zwischen dem API und einer DSL. \cite[S.50]{voelter} Ein Beispiel für ein
Fluent Interface bietet Fowler et. al. Dabei wird ein
Computer mit einem Processor und zwei Festplatten
beschrieben.
\begin{lstlisting}[caption = Beispiel: Fluent Interface]
computer()
	.processor()
		.cores(2)
		.speed(2500)
		.i386()
	.disk()
		.size(150)
	.disk()
		.size(75)
		.speed(7200)
		.sata()
	.end()
\end{lstlisting}
vgl. \cite[S.68]{fowler}

\newpage
\subsubsection*{Annotationen}
Annotationen sind ein Teil der Informationen über ein Programmelement, wie eine
Methoden oder Variablen. Diese Informationen können zur
Laufzeit oder zur Übersetzungzeit (wenn die Umgebung die
Möglichkeit dazu bietet) manipuliert werden. \cite[S.445]{fowler} \\
Bevor eine Annotation verarbeitet werden kann muss sie definiert werden. Die
Definition von Annotationen variiert zwischen unterschiedlichen Sprachen.
\cite[S.446]{fowler} Die Verarbeitung von Annotationen findet normalerweise
während der Übersetzung, während des Ladens des Programms oder während der
Ausführung des Programms statt. \cite[S.447]{fowler} Verarbeitungen während der
Laufzeit beeinflussen i.d.R. das Verhalten von Objekten. Beim Laden des
Programms werden meist Validierungs-Annotationen verwendet. Solche
Annotationen werden bspw. dazu verwendet das Mapping für die Datenbanken
auszulesen. Somit wird die Definition von Elementen von der Verarbeitung
getrennt, was zu einem übersichtlichen und lesbaren Code beiträgt.
\cite[S.449]{fowler} 
\section{Externe DSL}
Eine externe DSL ist eine separate Sprache, welche die Infrastruktur vorhandener
Sprachen nicht nutzt. \cite[S.18]{ghosh} Das bedeutet, dass eine externe DSL eine eigene Syntax sowie ein eigenes Typsytem
besitzt. In der Regel wird mit einer externen DSL ein Skript geschrieben,
welches von einem Programm gelesen wird. Dieser Vorgang wird auch als
parsen bezeichnet. \cite[S.28]{fowler} Für den Parser sowie den lexikalischen
Analysen werden oft vorhandene Infrastrukturen genutzt.
\cite[S.19]{ghosh}

\subsection{Implementierungstechniken}
Bei den Implementierungstechniken von externen DSL geht es um die Art und Weise,
wie der DSL-Code vom Parser in ein semantisches Model oder einem AST überführt
wird. \cite[S.89]{fowler} Die Allemeine Vorgehensweise bei der Verwendung von
Parsern ist Abbildung \ref{Abb_Parsing} zu entnehmen.
\myBigFigure{parsing.jpg}{Parsen allgemein}{Parsing}

\subsubsection*{Parser Generator}
Bei der Generierung von Parsern muss der Parser nicht manuell implementiert
werden. Diese Aufgabe wird an den Generator delegiert. Damit dies möglich ist,
muss eine Grammatik in der \gloss{EBNF}, sowie bestimmte Aktionen, die bei der
Bestätigung bestimmter Grammatik-Regeln ausgeführt werden sollen
(Validierungs-Regeln), definiert werden. \cite[S.218]{ghosh} Wird der Parser
Generator ausgetauscht führt dies auch häufig dazu, dass die notwendigen
Artefakte (Grammatik und Aktionen bei der Bestätigung von Grammatikregeln) neu
definiert werden müssen. \cite[S.269]{fowler} Weiterhin arbeiten die meisten
Parser Generatoren mit Code-Generierung, wodruch der Build-Process komplexer wird.
\cite[S.272]{fowler} Vorteile dieser Technik im Vergleich dazu, dass der Parser
manuell entwickelt wird, sind die folgenden.
\begin{itemize}
  \item Programmieren auf einem höheren Abstraktionsniveau \cite[S.218]{ghosh}
  \item Weniger Code zum Implementieren des Parsers \cite[S.218]{ghosh}
  \item Möglichkeit des Generieren eines Parser in unterschiedlichen Sprachen
  \cite[S.218]{ghosh}, \cite[S.270]{fowler}
  \item Validierung der Grammatik durch Fehlererkennung und -behandlung
  \cite[S.272]{fowler}
\end{itemize}
\subsubsection*{Recursive Decent Parser (RD-Parser)}
Dieser Parser basiert auf Funktionen, die rekursiv aufgerufen werden. Es handelt
sich dabei um einen \gloss{Top-Down Parser}. \cite[S.226]{ghosh} Die Funktionen implementieren dabei die Parsing-Regeln für
die nonterminalen Symbole der Grammatik. \cite[S.245]{fowler} Die Funktionen
geben dabei einen Boolean-Wert zurück, der Auskunft darüber gibt, ob die Symbole
aus dem DSL-Script mit den Symbolen übereinstimmen, die laut Grammatik erwartet
werden. \cite[S.246]{fowler} Tabelle \ref{tab_RD_Implementierung} zeigt die
Implementierungsmöglichkeiten von einfachen Grammatikregeln auf.
\begin{table}[!htb]
\centering
\small
			\begin{tabular}[c]{|l|l|}
			\hline\hline
				\textbf{Grammatik-Regel} &
				\textbf{Implementierung}\\
				\hline\hline
				A | B & 
\begin{lstlisting}
if(A())
	then true
	else if(B())
		then true
		else false
\end{lstlisting}\\
				\hline
				A B & 
\begin{lstlisting}
if(A())
	then if(B())
		then true
		else false
	else false
\end{lstlisting}\\
				\hline
				A? & 
\begin{lstlisting}
A();
true
\end{lstlisting}\\
				\hline
				A* & 	
\begin{lstlisting}
while(A());
true
\end{lstlisting}\\
				\hline
		A+ & 
\begin{lstlisting}
if(A())
	then while(A());
	else false
\end{lstlisting}\\
				\hline
				\hline
			\end{tabular}
		\caption{Implementierung einfacher Grammatikregeln mit einem RD-Parser
		\cite[S.248]{fowler}}
\label{tab_RD_Implementierung}
	\end{table}\\
Da dieser Parser direkt implementiert werden kann, ist es ebenso möglich diesen
Parser zu Debuggen. Das ist neben der einfachen Implementierung (solange es
sich um eine einfache Grammatik handelt) ein größer Vorteil dieser Technik.
\cite[S.249]{fowler} Ein großer Nachteil ist, dass keine Grammatik definiert
wird. Laut Fowler et. al. wird dadurch einer DSL ein großer Vorteil entzogen.
\cite[S.249]{fowler} 

\subsubsection*{Parser-Kombinator}
Bei der Kombination von Parsern wird die Grammatik mittels einer Strutkur von
Parser Objekten implementiert. \cite[S.256]{fowler} Wenn ein Teil des
Input-Streams von einerm Parser erfolgreich oder fehlerhaft verarbeitet wurde, kann der Rest den
Input-Streams an einen anderen Parser übergeben werden. Somit ist es möglich
Parser beliebig zu verketten. \cite[S.242]{ghosh} Die Elemente, die verkettet
werden können werden \emph{Parser-Kombinatoren} genannt. Abbildung
\ref{Abb_parsercombinator} stellt schematisch diese Funktionsweise dar. 
\myBigFigure{parsercombinator.jpg}{Funktionsweise von Parser-Kombinatoren (in
Anlehnung an \cite[S.243]{ghosh})}{parsercombinator} Bezogen
darauf, dass ein Parser aus Funktionen besteht, sind diese Parser-Kombinatoren Funktionen erster Ordnung, die unterschiedlich kombiniert werden können.
(vgl. \cite[S.243]{ghosh}, \cite[S.256]{fowler}) Durch
diese Kombination wird eine Struktur gebildet, welche das semantische
Model repräsentiert. \cite[S.256]{fowler} Ein großer Vorteil dieser Technik ist,
dass einfache Parser zu komplexeren Parsern zusammengefügt werden können.
Weiterhin wird durch die Kombination mehrerer Grammatik-bestimmender Komponenten
auch die Lesbarkeit der Grammatik gefördert, was bei einem RD-Parser ein großer
Nachteil war. Daher bezeichnen Fowler et. al. Parser-Kombinatoren auch als
Mittelweg zwischen RD-Parsern und Parser Generatoren. \cite[S.261]{fowler}

\section{Nicht-Textuelle DSL}
Bei den in den letzten Kapiteln vorgestellten internen und externen DSLs
handelt es sich um textuelle DSLs. Auch wenn eine DSL eine bestimmte domäne
repräsentiert, bedeutet dies nicht, dass diese Repräsentation 
immer textuell erfolgen muss. \cite[S.19]{ghosh} 
Es gibt einige Gründe, mit einer nicht-textuellen DSL zu arbeiten:
\begin{itemize}
  \item Viele Domänenprobleme können durch die Domänen-Nutzer besser durch
  Tabellen oder grafischen Darstellungen erklärt werden
  \item Domänenlogik ist in textueller Form oft zu komplex und enthält zu viele
  syntaktische strukturen
  \item visuelle Modelle sind einfacher zu durchdringen und zu verändern durch
  Domänenexperten
\end{itemize}\cite[S.19]{ghosh}\\
Für diesen Ansatz muss der Domänen-Nutzer die Repräsentation des Wissens über
eine Domäne in einem Editor (Projection Editor) visualisieren. Mit diesem Editor
kann der Domänen-Nutzer die Sicht auf die Domäne verändern, ohne auch nur eine
Zeile code schreiben zu müssen. Im Hintergrund generiert dieser Editor den Code,
welcher Sicht auf die Domäne modelliert. \cite[S.19f]{ghosh}
