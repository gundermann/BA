\chapter{Domänenspezifische Sprachen}\label{Domänenspezifische Sprachen}
\section{Begriffsbestimmungen}
\subsection*{Sprache/Programmiersprache}
  Formal betrachtet ist eine Sprache eine beliebige Teilmenge aller
  Wörter über einem Alphabet.
  \dcite{Ein Alphabet ist eine endliche, nicht leere Menge von
  Zeichen (auch Symbole oder Buchstaben genannt).}{hedtstueck}{6} Zur Verdeutlichung
  der Definition einer Sprache sei $V$ ein Alphabet und $k \in
  N$ (N ist die Menge der natürlichen Zahlen
  einschließich der Null) \vcite{hedtstueck}{6}. \dcite{Eine endliche Folge
  ($x_1, \ldots, x_k$) mit $x_i \in V (i = 1, \ldots, k)$ heißt Wort über $V$ der Länge
  $k$}{hedtstueck}{6}.\\
  Programmiersprachen werden dazu verwendet, um einem Computer
  Instruktionen zukommen zu lassen (vgl. \cite[S.27]{fowler},
  \cite[S.27]{voelter}).
  In diesem Kontext werden die Bestandteile einer Sprache wie folgt
  abgegrenzt:
  \begin{itemize}
    \item[] \textbf{Konkrete Syntax}\\
   	Die \emph{konkrete Syntax} beschreibt die Notation der Sprache. Demnach
   	bestimmt sie, welche Sprachkonstrukte der Nutzer einsetzen kann, um ein Programm in
    dieser Sprache zu schreiben	\vcite{alfred}{87}.
    \item[] \textbf{Abstrakte Syntax}\\
    Die \emph{abstrakte Syntax} ist eine Datenstruktur, welche die
    Kerninformationen eines Programms beschreibt.
	Sie enthält keinerlei Informationen über Details bzgl. der Notation. Zur
	Darstellung dieser Datenstruktur werden abstrakte Syntaxbäume
	genutzt \vcite{voelter}{179}.
    \item[] \textbf{Statische Semantik}\\
    Die \emph{statische Semantik} beschreibt die Menge an Regeln bzgl. des
    Typsystems, die ein Programm befolgen muss \vcite{voelter}{26}.
    \item[] \textbf{Ausführungssemantik}\\
    Die \emph{Ausführungssemantik} ist abhängig vom Compiler. 
    Sie beschreibt, wie ein Programm zum Zeitpunkt seiner Ausführung
    funktioniert \vcite{voelter}{26}.
  \end{itemize}
 
  
\subsection*{General Purpose Language (GPL)}
  Bei \emph{GPLs} handelt es sich um Programmiersprachen, die
  \emph{Turing-vollständig} sind.
  Das bedeutet, dass mit einer \emph{GPL} alles berechnet werden kann, was auch
  mit einer \gloss{Turing-Maschine} berechenbar ist. Völter et al. behaupten, dass
  alle \emph{GPLs} aufgrund dessen untereinander austauschbar sind. Dennoch 
  sind Abstufungen bzgl. der Ausführung dieser Programmiersprachen zu machen.
  Unterschiedliche \emph{GPLs} sind für spezielle Aufgaben optimiert 
  \vcite{voelter}{27f}.
  
\subsection*{Domain Specific Language (DSL)}
  Eine \emph{DSL} (zu dt. \emph{domänenspezifische Sprache}) ist eine
  Programmiersprache, welche für eine bestimmte \gloss{Domäne} optimiert ist \vcite{voelter}{28}.
  Das Entwickeln einer \emph{DSL} ermöglicht es, die Abstraktion der  Sprache der \gloss{Domäne} anzupassen 
  \vcite{ghosh}{10}. Das bedeutet, dass Aspekte, welche für die \gloss{Domäne}
  unwichtig sind, auch in der Sprache außer Acht gelassen werden können.
  \emph{Semantik} und \emph{Syntax} sollten demnach der jeweiligen Abstraktionsebene
  angepasst sein. Eine \emph{DSL} ist
  demzufolge in ihren Ausdrucksmöglichkeiten eingeschränkt. Je stärker diese
  Einschränkung ist, desto besser sind die Unterstützung der \gloss{Domäne} sowie die
  Ausdruckskraft der \emph{DSL} \vcite{fowler}{27f}.\\ 
  Darüber hinaus sollte ein
  Programm, welches in einer \emph{DSL} geschrieben wurde, alle Qualitätsanforderungen erfüllen, die auch bei einer Umsetzung des
  Programms mit \emph{GPLs} realisiert werden \vcite{ghosh}{10f}.\\
  Es gibt verschiedene Arten von \emph{DSLs}. Neben \emph{internen} und
  \emph{externen DSLs} (siehe Kapitel \ref{interneDSL} und \ref{externeDSL}) findet eine Unterscheidung zwischen
  \emph{technischen DSLs} und \emph{fachlichen DSL} statt. Markus Völter et al.
  unterscheiden diese beiden Kategorien im Allgemeinen dahingehend, dass \emph{technische
  DSLs} von Programmierern genutzt werden und \emph{fachliche DSL} von
  Domänenexperten (z. B. Kunden) \vcite{voelter}{26}.
  
\subsection*{Grammatik}
  Grammatiken und insbesondere Grammatikregeln werden zur Beschreibung von
  Sprachen verwendet \vcite{hedtstueck}{23f}. Für die Definition einer Grammatik
  wird auf den Praxisbericht \cite{gundermann5} verwiesen. Grammatiken
  können in einer Hierarchie dargestellt werden (\emph{Chomsky-Hierarchie})
  \vcite{hedtstueck}{32f}. Bei Programmiersprachen handelt es sich
  um \emph{kontextfreie Sprachen}. Diese sind entscheidbar
  und können somit von einem Compiler verarbeitet werden \vcite{hedtstueck}{16f}.
  
\subsection*{Lexikalische Analyse}
  Bevor ein \emph{DSL-Skript} (Text, der in der \emph{Syntax} einer \emph{DSL}
  geschrieben wurde) verarbeitet werden kann, muss das Skript vom sogenannten \emph{Lexer} oder
  \emph{Scanner} gelesen werden \vcite{fowler}{221}. Dabei wird ein Text aus
  diesem Skript als Input-Stream betrachtet. Der Lexer wandelt diesen
  Input-Stream in einzelne Tokens um \vcite{ghosh}{220}. Im Allgemeinen ist
  der \emph{Lexer} die Instanz innerhalb der \gloss{DSL-Umgebung}, die für das
  Auslesen des \emph{DSL-Skriptes} verantwortlich ist.

\subsection*{Parser}
  Ein \emph{Parser} ist ebenfalls ein Teil der \gloss{DSL-Umgebung} 
  \vcite{ghosh}{211}. Er ist dafür verantwortlich, aus dem Ergebnis der
  \emph{lexikalischen Analyse} ein Output zu generieren, mit dem weitere
  Aktionen durchgeführt werden können \vcite{ghosh}{212}. Der Output wird in
  Form eines \emph{Syntaxbaums (AST)} generiert \vcite{fowler}{47}. Ein solcher
  Baum ist laut Martin Fowler et al. eine weitaus nutzbarere Darstellung dessen, was
  mit dem \emph{DSL-Skript} beschrieben werden soll.
  Daraus lässt sich auch das \emph{semantische Modell} generieren
  \vcite{fowler}{48}.
  
\subsection*{Semantisches Modell}
  Das \emph{semantische Modell} ist ebenfalls eine Repräsentation dessen, was
  mit der \emph{DSL} beschrieben wurde. Es wird laut Martin Fowler et al. auch als die
  Bibliothek betrachtet, welche von der \emph{DSL} nach außen hin sichtbar ist 
  \vcite{fowler}{159}. In Anlehnung an Ghosh sowie Martin Fowler et al. wird das
  \emph{semantische Modell} als Datenstruktur betrachtet, deren Aufbau von der
  \emph{Syntax} der \emph{DSL} unabhängig ist (vgl. \cite[S.214]{ghosh}, \cite[S.48]{fowler}).
  
\subsection*{Generator}
  Laut Martin Fowler et al. ist ein \emph{Generator} der Teil der
  \gloss{DSL-Umgebung}, welcher für das Erzeugen eines Quellcodes für die
  \gloss{Zielumgebung} zuständig ist \vcite{fowler}{121}. Bei der
  Generierung von Quellcodes wird zwischen zwei Verfahren unterschieden.
  \begin{enumerate}
  	\item \textbf{Transformer Generation}\\
  	Bei der \emph{Transformer Generation} wird das \emph{semantische Modell} als
  	Input verwendet. Aus diesem Input wird der Quellcode für die
  	\gloss{Zielumgebung} generiert 
  	\vcite{fowler}{533f}. Ein solches Verfahren wird oft verwendet,
  	wenn ein Großteil des Outputs generiert wird und die Inhalte des
  	\emph{semantischen Modells} einfach in den Quellcode der \gloss{Zielumgebung}
  	überführt werden können \vcite{fowler}{535}\label{TransG}.
  	\item \textbf{Templated Generation} \\
  	Bei der \emph{Templated Generation} wird eine Vorlage benötigt. In dieser
  	Vorlage befinden sich Platzhalter. Diese dienen dazu, dass der vom Generator
  	erzeugte Quellcode an diesen Stellen eingesetzt werden kann 
  	\vcite{fowler}{539f}. Dieses Codegenerierungsverfahren wird oft verwendet,
  	wenn sich im zu generierenden Quellcode für die \gloss{Zielumgebung} viele
  	statische Inhalte befinden und der Anteil dynamischer Inhalte sehr einfach gehalten ist 
  	\vcite{fowler}{541}\label{TempG}.
  \end{enumerate}

\section{Anwendungsbeispiele}
Die Anwendungsbereiche für \emph{DSLs} sind breit gefächert. Die bekanntesten
\emph{DSLs} sind Sprachen wie \emph{SQL} (zur Abfrage und Manipulation von Daten in einer
relationalen Datenbank), \emph{HTML} (als Markup-Sprache für das Web) oder
\emph{CSS} (als Layoutbeschreibung) \vcite{ghosh}{12}. Alle Sprachen sind in
ihren Ausdrucksmöglichkeiten eingeschränkt und von der
Abstraktion her direkt auf eine \gloss{Domäne} (jeweils dahinter in Klammern genannt)
zugeschnitten \vcite{ghosh}{12f}.\\
Weitere Beispiele für \emph{DSLs} befinden sich im Bereich der
Sprachen für \emph{Parser-Generatoren} (z. B. \emph{YACC}, \emph{ANTLR}) oder im
Bereich der Sprachen für das Zusammenbauen von Softwaresystemen (z.
B. \emph{Ant}, \emph{Make}) \vcite{ghosh}{12}.

\section{Model-Driven Software Development (MDSD)}\label{mdsd}
In der Einleitung wurde schon der \emph{Model-Driven Ansatz} in Verbindung mit
\emph{GUI-Entwicklung} erwähnt. Dieser Ansatz versucht den technischen Lösungen
der IT-Industrie einen gewissen Grad an Agilität zu verleihen \simplevcite{3}. Dies
hängt damit zusammen, dass die Entwicklung von Softwareprodukten schneller und
besser vonstatten geht und mit weniger Kosten realisierbar ist \vcite{mdsd}{71}.\\
Erreicht wird dies, indem die Modelle formaler, strenger, vollständiger und
konsistenter beschrieben werden \vcite{voelter}{31}. Die Grundidee ist, dass die
Modelle Quellcodes oder Funktionalitäten beschreiben und diese in der Evolution
der Software immer wiederverwendet werden können \vcite{mdsd}{72}. Somit wird
ein redundanter oder schematischer Quellcode vermieden und es ist möglich diese Modelle auch in
anderen Anwendungen zu verwenden \vcite{mdsd}{72}.\\
Daraus lassen sich folgende Ziele des \emph{MDSD} ableiten:
\begin{itemize}
  \item Schnelleres Entwickeln durch Automatisierungen
  \item Bessere Softwarequalität durch automatisierte Transformationen und formalen Modell-Definitionen
  \item Verhinderung von Wiederholungen und besseres Management von
  veränderbaren Technologien durch die Trennung der Funktionsbereiche
  (\emph{Separation of Concers})
  \item Architekturen,
  Modellierungssprachen (bspw. eine \emph{DSL}) und Generatoren/Transformatoren
  können besser wiederverwendet werden
  \item Verringerte Komplexität durch höhere Abstraktion
\end{itemize}
\vcite{mdsdvoelter}{13f}\\\\
Die Modelle sind somit nicht länger nur zur Dokumentation geeignet, sondern sind
ein Teil der Software \vcite{mdsdvoelter}{14f}. Dabei sind sie auf
ein bestimmtes Domänenproblem angepasst. Die Beschreibung dieser Modelle kann
bspw. über eine \emph{DSL} erfolgen \vcite{mdsdvoelter}{15}. In
Abbildung \ref{mdsd} ist die Idee des \emph{MDSD} schematisch dargestellt.
\myBigFigureCited{mdsd.jpg}{Die grundlegende Idee hinter dem MDSD}{
\vcite{mdsdvoelter}{15}}{mdsd}

\section{Abgrenzung zu GPL}
Wie vorhergehend bereits erwähnt, sind \emph{GPLs} Sprachen mit denen
alles berechnet werden kann, was auch mit einer \gloss{Turing-Maschine}
berechenbar ist.
Folglich kann mit einer \emph{GPL} jedes berechenbare Problem
gelöst werden. Eine \emph{DSL} hat diese Eigenschaft nicht. Da sie auf eine bestimmte
\gloss{Domäne} zugeschnitten ist, können auch nur Probleme innerhalb dieser \gloss{Domäne} mit
ihr gelöst werden \vcite{voelter}{28}. Martin Fowler et al. bezeichnen diese
Eigenschaft des Domänenfokus als ein Schlüsselelement der Definition einer \emph{DSL} 
\vcite{fowler}{27f}.

\section{Vor- und Nachteile von DSLs gegenüber GPLs}
\subsection*{Vorteile:}

\begin{itemize}
  \item []
\textbf{Ausdruckskraft}\\
 Laut Ghosh sollten \emph{DSLs} so umgesetzt werden, dass sie präzise sind. Diese
 Präzision bedingt, dass eine \emph{DSL} einfach zu verstehen ist. Bei der Verwendung
 einer \emph{DSL} sollte demnach der von  Dan Roam beschriebenen Prozess des visuellen
 Denkens (sehen - betrachten - verstehen - zeigen) \simplevcite{Roam2009} so schnell wie
 möglich abzuarbeiten sein.\\
 Weiterhin ist es wichtig bei der Entwicklung einer \emph{DSL} darauf zu achten, dass
 sich die Abstraktion der Sprache an der \emph{Semantik} der \gloss{Domäne} orientiert
 \vcite{ghosh}{20}. Sind diese Empfehlungen umgesetzt, wächst das
 Verständnis für das, was entwickelt werden soll, da die semantische Lücke zwischen Programm und Problem
 kleiner wird (vgl. \cite[S.20]{ghosh}, \cite{journals/insk/BrauerCK08}).
 Zudem bleibt die Komplexität durch eine höhere Abstraktionsebene
 beherrschbar \simplevcite{journals/insk/BrauerCK08}.
  \item []
\textbf{Höhere Qualität}\\
  Bei der Entwicklung einer \emph{DSL} werden die Sprachkonstrukte und
  Freiheitsgrade der Sprache festgelegt. Richtig konzipiert, schränken sie den Entwickler im
  Umgang mit dieser \emph{DSL} so ein, dass die Möglichkeit redundanten Quellcode zu
  schreiben oder mehrfache Arbeit durchzuführen, kaum noch besteht. Zusätzlich
  wird die Anzahl von Syntaxfehlern verringert \vcite{voelter}{40f}. Ferner
  wird durch die starke Abstraktion einer \emph{DSL} die Wiederverwendung gefördert,
  was ebenfalls zu einem qualitativ höherwertigem Quellcode führt
  \vcite{ghosh}{21}.
  \item []
\textbf{Verbesserte Produktivität bei der Entwicklung der
  Software}\\
  Durch die Ausdruckskraft und die Abstraktion einer \emph{DSL} muss i. d. R. 
  weniger Quellcode für die Implementierung eines Programms geschrieben werden,
  als bei der Verwendung einer \emph{GPL} benötigt wird.
  Mit einem entsprechenden Framework für \emph{GPLs} könnte ähnliches erreicht
  werden \vcite{voelter}{40}.\\
  Ebenso führt die stärkere Ausdruckskraft zu einer
  besseren Lesbarkeit von \emph{DSL-Code} im
  Vergleich zu \emph{GPL-Code}, wodurch jener einfacher
  zu verstehen ist. Dies erleichtern das Finden von Fehlern in diesem Quellcode
  sowie Veränderungen an dem System vorzunehmen. Bei einer \emph{GPL} werden
  diese Vorteile durch Dokumentationen, ausdrucksvolle Variablenbezeichnungen und festgelegten Konventionen
  angestrebt \vcite{fowler}{33}. Allerdings ist der Entwickler zur Einhaltung dieser
  Vorschriften nicht gezwungen. Bei der Verwendung
  einer \emph{DSL} hingegen kann dem Entwickler dieser Freiheitsgrad entzogen
  werden. Damit ist er gezwungen, lesbaren Quellcode zu schreiben, da die
  Sprache es nicht anders zulässt.
  \item []
\textbf{Bessere Kommunikation mit
  Domänenexperten und Kunden}\\
  Aufgrund domänenspezifischer und präziser Ausdrücke,
  die in der Sprache verwendet
  werden, sind die Domänenexperten bzw.
  die Kunden vertrauter mit der Implementierung,
  als würde für die Umsetzung eine \emph{GPL}
  verwendet werden \vcite{voelter}{42}. Die hohe Ausdruckskraft
  fördert das Verständnis dieser \emph{DSL}. Damit ist es einfacher die Kunden in die
  Entwicklung mit einzubeziehen. Dabei sollten jedoch zusätzliche Hilfsmittel,
  wie Visualisierungen oder Simulationen verwendet
  werden (vgl. \cite[S.34]{fowler}, \cite[S.42]{voelter}). Somit kann die oft
  vernachlässigte Kommunikation zwischen Kunden und
  Auftragnehmern verbessert werden. Martin Fowler et al. bezeichnen die
  Verwendung einer \emph{DSL} als reine Kommunikationplattform als vorteilhaft 
  \vcite{fowler}{34f}. Grund dafür ist, dass bereits bei der Entwicklung einer
  \emph{DSL} das Verständnis des Auftragnehmers über die \gloss{Domäne} gesteigert wird 
  \vcite{voelter}{41}.
  
  \item []
\textbf{Plattformunabhängigkeit}\\
  Durch die Nutzung einer \emph{DSL} kann bspw. ein Teil der Logik von der Kompilierung
  in den Ausführungskontext überführt werden. Die Definition der Logik findet dabei
  in der \emph{DSL} statt, welche erst bei der Ausführung evaluiert wird. Ein solches
  Verfahren wird oft unter der Verwendung von \emph{XML} genutzt
  \vcite{fowler}{35}. Dadurch ist es möglich die Logik auf unterschiedlichen
  Plattformen auszuführen \vcite{voelter}{43}. Dieser Vorteil ist besonders für
  den praktischen Teil dieser Arbeit interessant, allerdings weniger in Bezug
  auf Logik, denn in Bezug auf Benutzerschnittstellen.
  \item []
\textbf{Einfachere Validierung und Verifizierung}\\
  Da \emph{DSLs} bestimmte Details der Implementierung ausblenden, sind sie auf
  semantischer Ebene reichhaltiger als \emph{GPLs}. Das führt dazu, dass
  Analysen einfacher umzusetzen sind und Fehlermeldungen verständlicher gestaltet werden können, indem die
  Terminologie der \gloss{Domäne} verwendet wird. Dadurch und durch die vereinfachte
  Kommunikation mit den Domänenexperten, werden Reviews und Validierungen des
  \emph{DSL-Codes} weitaus effizienter \vcite{voelter}{41}.
  \item []
\textbf{Unabhängigkeit von Technologien}\\
  Die Modelle, welche zur Beschreibung von Systemen verwendet werden, können so
  gestaltet werden, dass sie von Implementierungstechniken unabhängig sind. Dies
  wird durch ein hohes Abstraktionsniveau erreicht, welches an die \gloss{Domäne}
  angepasst ist. Dadurch kann die Beschreibung der Modelle von den genutzten
  Technologien weitestgehend entkoppelt werden \vcite{voelter}{41}.
  \item []
\textbf{Skalierung des Entwicklungsprozesses}\\
  Die Integration von neuen Mitarbeitern in ein Entwicklerteam fordert immer
  eine gewisse Einarbeitungszeit. Dieser Zeitraum kann durch die
  Nutzung einer \emph{DSL} verkürzt werden, wenn die \emph{DSL} einen hohen Abstraktionsgrad
  hat und dadurch leichter zu verstehen und zu erlernen
  ist \vcite{ghosh}{21}.\\
  Innerhalb eines Entwicklerteams haben die
  Mitarbeiter oft einen unterschiedlichen Erfahrungsstand bzgl. einer speziellen
  Programmiersprache, die zur Entwicklung genutzt werden soll. Erfahrene Teammitglieder könnten sich
  mit der Implementierung der \emph{DSL} befassen und die Grundlage für die anderen 
  Teammitglieder schaffen. Diese wiederum nutzen die \emph{DSL}, um die fachlichen
  Anforderungen der Kunden zu implementieren \vcite{ghosh}{21}. Das zu einer effizienteren Arbeitsweise, da sich nicht jeder
  Entwickler mit allem auskennen musss. Markus Völter et al. hingegen sehen die
  Teilung der Programmieraufgaben als Gefahr bzw. Nachteil 
  \vcite{voelter}{44}.
\end{itemize}

\subsection*{Nachteile:}

\begin{itemize}
  \item []
\textbf{Großes Know-How gefordert}\\
  Bevor die eine \emph{DSL} genutzt werden kann, muss sie entwickelt
  werden \vcite{voelter}{43}. Das Designen einer Sprache ist eine komplexe
  Aufgabe, die nur schwer skalierbar ist \vcite{ghosh}{21}. Die Vorteile, die
  eine \emph{DSL} bietet, können nur genutzt werden, wenn die \emph{DSL} ausreichend gut
  konzipiert ist. Dazu muss einerseits der richtige Abstraktionsgrad
  gefunden und andererseits die Sprache so einfach wie möglich gehalten
  werden.
  Für beide Aufgaben werden Entwickler benötigt, die viel Erfahrung mit
  Sprachdesign haben \vcite{voelter}{44}.
\item []
\textbf{Kosten für die Entwicklung der
  DSL}\\
  Bei wirtschaftlichen Entscheidungen wird der monetäre Input mit dem
  monetären Output verglichen.
  Investitionen führen dazu, dass der Input größer wird. Da eine \emph{DSL} vor dem
  Einsatz zuerst entwickelt werden muss, ist es notwendig Investitionen für die
  Entwickler der \emph{DSL} zu tätigen. Ob sich eine Investition lohnt, muss vorher
  durch entsprechende Analysen überprüft werden. Dabei muss festgestellt werden,
  ob die Entwicklung der \emph{DSL} gerechtfertigt ist. Im Bereich der
  \emph{technischen DSLs} fällt die Rechtfertigung einfach, da diese \emph{DSLs} oft wiederverwendet werden
  können. \emph{Fachliche DSLs} hingegen haben oft eine weitaus kompaktere
  \gloss{Domäne}, als eine \emph{technische DSL}. Daher ergeben sich die Möglichkeiten zur
  Wiederverwendung erst zu einem späteren Zeitpunkt und
  können nur schwer von der im Vorfeld durchgeführten
  Analyse wahrgenommen werden \vcite{voelter}{43}.\\
  Weiterhin sind in der Phase, in der die \emph{DSL} entwickelt wird, keine erhebliche
  Senkung der Kosten zu erwarten. Die Kosten
  reduzieren sich i. d. R. erst, wenn die \emph{DSL} eingesetzt wird \vcite{ghosh}{21}.\\
  Bevor eine \emph{DSL} entwickelt werden kann, sollte ein entsprechendes Know-How
  aufgebaut werden. Der Aufbau dieses Wissens verursacht weitere Kosten 
  \vcite{fowler}{37}.
\item []
\textbf{Investitionsgefängnis}\\
  Der Begriff stammt von Markus Völter et al. Er beruht auf der Annahme, dass
  sich ein Unternehmen dessen bewusst ist, dass höhere Investitionen in
  wiederverwendbare Artefakte zu einer besseren Produktivität führen. 
  Artefakte, die wiederverwendet werden können, führen dennoch zu Einschränkungen. Die
  Flexibilität geht dabei verloren. Weiterhin besteht dabei die Gefahr, dass
  bestimmte Artefakte aufgrund geänderter Anforderungen unbrauchbar
  werden.
  Darüber hinaus ist es gefährlich, Artefakte zu verändern die häufig
  wiederverwendet werden, weil dadurch unerwünschte Nebeneffekte
  auftreten können.
  Somit wäre das Unternehmen wiederum zu Investitionen gezwungen, um die
  Anforderungen umzusetzen. Von daher der verwendete Begriff
  \emph{Investitionsgefängnis} \vcite{voelter}{45}.
\item []
\textbf{Kakophonie}\\
  Eine \emph{DSL} abstrahiert von einem Domänenmodell \vcite{ghosh}{22}. Je besser
  diese Abstraktion ist, desto euphonischer und ausdrucksstärker ist die
  Sprache.\\
  Normalerweise werden für eine Applikation mehrere \emph{DSLs} benötigt. Diese
  unterschiedlichen \emph{DSLs} haben i. d. R. unterschiedliche syntaktische
  Strukturen.
  Das führt dazu, dass Mitarbeiter unterschiedliche Sprachen beherrschen müssen.
  Das wiederum erfordert, dass die Entwickler öfter umdenken müssen, als würden
  sie fortwährend mit einer Sprache arbeiten. Dies macht den
  Entwicklungsprozess weitaus komplizierter \vcite{fowler}{37}.
\item []
\textbf{Ghetto-Sprache}\\
  Wenn ein Unternehmen nur mit eigenen \emph{DSLs} arbeitet, gleichen diese Sprachen einer
  \emph{Ghetto-Sprache}, die von keinem anderen Unternehmen verstanden wird.
  Dadurch ist es schwer, neue Technologien von anderen Unternehmen in den Bereichen, in
  denen vermehrt \emph{DSLs} eingesetzt werden, zu integrieren. Denn diese
  Technologien werden nicht mit den eigenen \emph{DSLs} kompatibel sein. Außerdem ist
  es schwer in diesem Bereich von neuen Mitarbeitern zu
  profitieren, da anzunehmen ist, dass sie diese \emph{DSLs} und ihren Zweck
  nicht kennen \vcite{fowler}{38}.\\
  Dieser Punkt ist auch in Verbindung mit dem \emph{Investitionsgefängnis} zu
  betrachten. Durch die Verwendung übermäßig vieler \emph{DSLs} ist das Unternehmen
  gezwungen, diese durch eine große Investition abzusetzen und allgemein
  bekannte Technologien einzuführen, um von diesen zu profitieren. Eine andere
  Möglichkeit ist, weiter in die Entwicklung
  eigener \emph{DSLs} zu investieren, um seine Systeme aufrecht zu erhalten.
\item []
\textbf{Borniertheit durch Abstraktion}\\
  Abstraktion ist von großer Wichtigkeit für eine \emph{DSL}. Wenn ein Entwickler mit
  der Arbeit an einer \emph{DSL} begonnen hat, hat dieser die Abstraktion
  in einem bestimmen Maß bereits festgelegt. Ein Problem tritt auf,
  wenn im Nachhinein etwas mit der Sprache beschrieben werden soll,
  dass nicht zu dieser Abstraktionsebene passt.\\
  Dabei besteht
  die Gefahr, dass der Entwickler sich von der Abstraktion der
  Sprache gefangen nehmen lässt. Das bedeutet, dass er
  versucht, das Problem aus der realen Welt auf seine Abstraktion
  anzupassen. Der richtige Weg hingegen ist, die Sprache und
  deren Abstraktionsebene so anzupassen, dass das Problem
  beschrieben werden kann \vcite{fowler}{39}.
\item []
\textbf{Kulturelle Herausforderungen}\\
  Die genannten Nachteile des Einsatzes von \emph{DSLs}, führen zu Äußerungen
  wie der, dass die Entwicklung von Sprachen kompliziert ist, Domänenexperten keine
  Programmieren sind oder auch, dass nicht schon wieder eine neue Sprache
  gelernt werden will, was auch als \emph{Yet-Another-Language-To-Learn
  Syndrom} bezeichnet wird \vcite{ghosh}{22}.\\
  Solche kulturellen Probleme entstehen i. d. R. dann, wenn etwas Neues
  eingeführt werden soll \vcite{voelter}{45}. Die Mitarbeiter müssen demnach
  entsprechend geschult und motiviert werden.
\item []
\textbf{Unvollständige DSLs}\\
  Wenn ein Unternehmen viel Erfahrung bei der
  Entwicklung von \emph{DSLs} aufgebaut hat und die Entwicklung
  durch die Einführung entsprechender Tools vereinfacht wurde, besteht
  die Gefahr der voreiligen Entwicklung einer neuen \emph{DSLs}.
  Das heißt, dass die Notwendigkeit einer neuen \emph{DSL} nicht
  ausreichend evaluiert wurde. Durch
  die einfachere Entwicklung scheint es weniger aufwendig eine neue \emph{DSL}
  zu konstruieren, als nach bestehenden Ansätzen zur Lösung für das gleiche
  Problem zu suchen \vcite{voelter}{44f}. Die Aussicht auf die Amortisierung
  einer Investition in neue \emph{DSLs}, unterstützt diese
  Vorgehensweise \vcite{fowler}{38}.
  Somit entstehen immer mehr \emph{DSLs}, die auf gleichen Problemen basieren,
  aber untereinander nicht kompatibel sind. Außerdem fördert die
  Entwicklung einer \emph{DSL} das Verstehen der \gloss{Domäne}, weshalb die Möglichkeit
  besteht, dass dies der einzige Grund für eben diese Entwicklung ist
  \vcite{fowler}{38}.
  Das wiederum hat zur Folge, dass mehrere unvollständige \emph{DSLs}
  existieren. Markus Völter et al. nennen dieses Phänomen die \emph{\glqq DSL
  Hell\grqq} \vcite{voelter}{44f}.
\end{itemize}
 \\\\
Zusammenfassend ist zu sagen, dass der Aufwand für die Vorbereitung des
Einsatzes einer \emph{DSL} sehr hoch ist. Wurde eine \emph{DSL} jedoch eingeführt, wird sich
der Arbeitsaufwand um ein Vielfaches verringern und der Gewinn schließlich höher
ausfallen \vcite{ghosh}{21}.


\section{Interne DSLs}\label{interneDSL}
Bei einer \emph{internen DSL} handelt es sich um eine \emph{DSL}, die in eine
\emph{GPL} integriert ist. Sie übernimmt dabei das Typsystem der \emph{GPL}
\vcite{voelter}{50}. In Bezug auf die Ziele aus Kapitel \ref{mdsd} können einige dieser Absichten mit
\emph{Application Programming Interfaces (API)} erreicht werden.
In vielen Fällen ist eine \emph{DSL} nicht mehr als ein \emph{API}.
Martin Fowler et al. sehen den größten Unterschied zwischen \emph{API} und \emph{DSL}
darin, dass eine \emph{DSL} neben einem abstrahierten Vokabular auch eine spezifische Grammatik
nutzt \vcite{fowler}{29}. Ein \emph{API}
hingegen besitzt die gleichen syntaktischen Strukturen wie die \emph{GPL}, in
der das \emph{API} bereitgestellt wurde. Somit werden überflüssige Notationsformen in das \emph{API}
übernommen, was bei einer \emph{DSL} nicht der Fall ist \vcite{voelter}{30}. Weiterhin
können \emph{DSLs} so konstruiert werden, dass durch Restriktionen und Limitierungen
nur korrekte Programme geschrieben werden können. Markus Völter et al.
bezeichnen diese Eigenschaft als \emph{\glqq correct-by-construction\grqq}
\vcite{voelter}{30}.
\subsection{Implementierungstechniken}
\subsubsection*{Parse Tree Manipulation}
Allgemein betrachtet funktioniert diese Technik wie folgt: \\
Ein Codefragment,
welches erst gelesen und zu einem späteren Zeitpunkt ausgewertet werden soll,
wird in einem \emph{Parse Tree} hinterlegt. Dieser \emph{Parse Tree} wird noch vor der
Ausführung modifiziert. Um diese Implementierungstechnik nutzen zu können, muss
eine Umgebung vorliegen, in der es möglich ist, ein Codefragment in einen
\emph{Parse Tree} umzuformen und diesen zu bearbeiten. Diese Möglichkeit
existiert nur in wenigen Sprachen.
Martin Fowler et al. nennen hierzu nur die Beispiele \emph{C\#},
\emph{ParseTree} (Ruby) und \emph{Lisp} \vcite{fowler}{45f}.\\
Anders als Lisp bieten die anderen Beispiele die
Möglichkeit über den \emph{Parse Tree} zu iterieren. Bei einem \emph{Lisp-Code}
handelt es sich bereits um einen \emph{Parse Tree} von verschachtelten Listen. Bei der Iteration über
den \emph{Parse Tree} ist aufgrund der Performance darauf zu achten, dass möglichst nur die
notwendigen Teile des \emph{Parse Trees} einbezogen werden \vcite{fowler}{46}.\\
Konstrukte, die in der Wirtsprache geschrieben
wurden und nicht verändert werden sollen, spielen
bei der \emph{Parse Tree Manipulation} für die Erzeugung der \emph{semantischen
Modelle} keine Rolle \vcite{fowler}{46}.

\subsubsection*{Fluent Interfaces}
In einem klassischen \emph{API} hat jede Methode eine eigene
Aufgabe und ist nicht von anderen Methoden in diesem \emph{API} abhängig 
\vcite{fowler}{28}. In einer \emph{internen DSL} hingegen ist es möglich,
Methoden bereitzustellen, die verkettet werden können und somit komplette
Sätze darstellen. Dadurch wird der Output einer Methode zum Input der folgenden
Methode. Demzufolge wird die Lesbarkeit der \emph{DSL} wesentlich
verbessert, da es einer Sequenz von Aktionen gleicht, die in der \gloss{Domäne}
ausgeführt werden \vcite{ghosh}{94} und ohne eine Vielzahl von Variablen aufgerufen
werden müssen \vcite{fowler}{68}. Eine solche Verkettung von Methoden wird
als \emph{Fluent Interface} bezeichnet. Das \emph{Fluent Interface} steht laut
Markus  Völter et al. zwischen dem \emph{API} und einer \emph{internen DSL}
\vcite{voelter}{50}. Ein einfaches Beispiel für ein \emph{Fluent Interface} wird von Martin Fowler et al.
beschrieben. 
\begin{lstlisting}[caption = Beispiel: Fluent Interface]
computer()
	.processor()
		.cores(2)
		.speed(2500)
		.i386()
	.disk()
		.size(150)
	.disk()
		.size(75)
		.speed(7200)
		.sata()
	.end()
\end{lstlisting}
\vcite{fowler}{68}

\subsubsection*{Annotationen}
\emph{Annotationen} sind Teile der Informationen über ein Programmelement, wie 
Methoden oder Variablen. Diese Informationen können während der
Laufzeit oder der Übersetzungszeit - wenn die Umgebung die
Möglichkeit dazu bietet - manipuliert werden \vcite{fowler}{445}.\\
Bevor eine \emph{Annotation} verarbeitet werden kann, muss sie definiert werden.
Die Definitionen von \emph{Annotationen} variieren bei Verwendung unterschiedlicher
Sprachen \vcite{fowler}{446}. Die Verarbeitung von \emph{Annotationen} kann
zu drei bestimmten Zeitpunkten, nämlich zum Zeitpunkt der Übersetzung, des
Ladens oder der Ausführung des Programms, stattfinden \vcite{fowler}{447}.
Die Interpretation und Ausführung von Annotiationen während der Laufzeit
beeinflussen i. d. R. das Verhalten von Objekten.
Beim Laden des Programms werden meist Validierungsannotationen verwendet. Solche
\emph{Annotationen} finden bspw. beim Auslesen des Mappings für Datenbanken Anwendung.
Somit wird die Definition der Elemente von der Verarbeitung getrennt, was zu
einem übersichtlichen und lesbaren Quellcode beiträgt \vcite{fowler}{449}. 


\section{Externe DSLs}\label{externeDSL}
Eine externe \emph{DSL} ist eine separate Sprache, welche die Infrastruktur vorhandener
Sprachen nicht nutzt \vcite{ghosh}{18}. Das bedeutet, dass eine \emph{externe
DSL} eine eigene \emph{Syntax} sowie ein eigenes Typsystem besitzt. In der Regel wird
mit einer \emph{externen DSL} ein Skript geschrieben, welches von einem Programm
gelesen wird. Dieser Vorgang wird auch als \emph{Parsen} bezeichnet \vcite{fowler}{28}. Für den \emph{Parser} und die
\emph{lexikalische Analyse} werden oft vorhandene Infrastrukturen genutzt \vcite{ghosh}{19}.

\subsection{Implementierungstechniken}
Bei den Implementierungstechniken von \emph{externen DSLs} geht es um die Art
und Weise, wie der \emph{DSL-Code} vom \emph{Parser} in ein \emph{semantisches
Modell} oder einen \emph{AST} überführt wird \vcite{fowler}{89}. Die allgemeine
Vorgehensweise bei der Verwendung von \emph{Parsern} ist der Abbildung \ref{Abb_Parsing} zu
entnehmen.
\myBigFigure{parsing.jpg}{Parsen allgemein}{Parsing}

\subsubsection*{Parsergenerator}
Bei der Generierung von \emph{Parsern} muss dieser nicht manuell implementiert
werden. Diese Aufgabe wird an den \emph{Generator} delegiert. Damit dies möglich
ist, müssen zwei Artefakte definiert werden. Zuerst muss eine Grammatik in der
erweiterten \emph{Backus-Naur Form (EBNF)} beschrieben werden. Anschließend
werden bestimmte Aktionen benötigt, die bei der Bestätigung bestimmter Grammatikregeln ausgeführt werden sollen
(Validierungsre\-geln) \vcite{ghosh}{218}. Wird der \emph{Parsergenerator}
ausgetauscht, führt dies auch häufig dazu, dass die notwendigen Artefakte
(Grammatik und Aktionen) neu definiert werden müssen \vcite{fowler}{269}. Weiterhin arbeiten die
meisten \emph{Parsergeneratoren} mit Code-Generierung, wodurch der
Erstellungsprozess komplexer wird \vcite{fowler}{272}. Vorteile dieser Technik im Vergleich zur
manuellen Implementierung des \emph{Parsers}, sind die Folgenden:
\begin{itemize}
  \item Möglichkeit des Programmierens auf einem höheren Abstraktionsniveau
  \vcite{ghosh}{218}
  \item Gebrauch von weniger Quellcode zur Implementierung des \emph{Parsers}
  \vcite{ghosh}{218}
  \item Möglichkeit des Generierens eines Parsers in unterschiedlichen Sprachen
  (vgl. \cite[S.218]{ghosh}, \cite[S.270]{fowler})
  \item Validierung der Grammatik durch Fehlererkennung und -behandlung
  \vcite{fowler}{272}
\end{itemize}

\subsubsection*{Recursive Decent Parser (RD-Parser)}
Dieser \emph{Parser} basiert auf Funktionen, die rekursiv aufgerufen werden. Es handelt
sich dabei um einen \gloss{Top-Down Parser} \vcite{ghosh}{226}. Die
Funktionen implementieren dabei die Regeln des \emph{Parsens} für die
nonterminalen Symbole der Grammatik \vcite{fowler}{245}. Die Funktionen geben dabei einen
Boolean-Wert zurück, der Auskunft darüber gibt, ob die Symbole aus dem
\emph{DSL-Skript} mit den laut Grammatik zu erwartenden Symbolen übereinstimmen
\vcite{fowler}{246}. Tabelle \ref{tab_RD_Implementierung} enthält die Implementierungsmöglichkeiten von einfachen Grammatikregeln.
\lstset{numbers=none}
\begin{table}[!htb]
\centering
\small
			\begin{tabular}[c]{|l|l|}
			\hline\hline
				\textbf{Grammatikregel} &
				\textbf{Implementierung}\\
				\hline\hline
				A | B & 
\begin{lstlisting}
if(A())
	then true
	else if(B())
		then true
		else false
\end{lstlisting}\\
				\hline
				A B & 
\begin{lstlisting}
if(A())
	then if(B())
		then true
		else false
	else false
\end{lstlisting}\\
				\hline
				A? & 
\begin{lstlisting}
A();
true
\end{lstlisting}\\
				\hline
				A* & 	
\begin{lstlisting}
while(A());
true
\end{lstlisting}\\
				\hline
		A+ & 
\begin{lstlisting}
if(A())
	then while(A());
	else false
\end{lstlisting}\\
				\hline
				\hline
			\end{tabular}
		\caption[Einfache Grammatikregeln mit einem
		RD-Parser]{Einfache Grammatikregeln mit einem
		\emph{RD-Parser}
		\vcite{fowler}{248}}
\label{tab_RD_Implementierung}
	\end{table}\\
\lstset{numbers=left}	
\noindent	
Da dieser \emph{Parser} direkt implementiert werden kann, ist es ebenso möglich diesen
\emph{Parser} zu debuggen. Dies ist neben der einfachen Implementierung - solange es
sich um eine einfache Grammatik handelt - ein großer Vorteil dieser Technik
\vcite{fowler}{249}. Ein Nachteil ist, dass keine Grammatik definiert wird.
Laut Martin Fowler et. al. wird dadurch einer \emph{DSL} ein gravierender
Vorteil entzogen \vcite{fowler}{249}.

\subsubsection*{Parserkombinator}
Bei der Kombination von \emph{Parsern} wird die Grammatik mittels einer Struktur
von \emph{Parser-Objekten} implementiert \vcite{fowler}{256}. Wenn ein Teil des
Input-Streams von einem \emph{Parser} erfolgreich oder auch fehlerhaft verarbeitet
wurde, kann der Rest des Input-Streams an einen anderen \emph{Parser} übergeben werden.
Somit ist es möglich, \emph{Parser-Objekte} beliebig zu verketten
\vcite{ghosh}{242}.
Die Elemente, die verkettet werden können, werden \emph{Parserkombinatoren}
genannt. Abbildung \ref{Abb_parsercombinator} stellt schematisch diese Funktionsweise dar. 
\myBigFigureCited{parsercombinator.jpg}{Funktionsweise von
Parserkombinatoren}{ (in Anlehnung an \cite[S.243]{ghosh})
}{parsercombinator}
\noindent
Bezogen darauf, dass ein \emph{Parser} aus Funktionen besteht, sind diese
\emph{Parserkombinatoren} Funktionen erster Ordnung, die unterschiedlich
kombiniert werden können  (vgl. \cite[S.243]{ghosh}, \cite[S.256]{fowler}). Durch
diese Kombination wird eine Struktur gebildet, welche das \emph{semantische
Modell} repräsentiert \vcite{fowler}{256}. Ein großer Vorteil dieser
Technik ist, dass einfache \emph{Parser} zu komplexeren \emph{Parsern}
zusammengefügt werden können.\\
Weiterhin wird durch die Kombination mehrerer grammatikbestimmender Komponenten
auch die Lesbarkeit der Grammatik gefördert, was bei einem \emph{RD-Parser} ein großer
Nachteil ist. Daher bezeichnen Martin Fowler et al. \emph{Parserkombinatoren}
auch als Mittelweg zwischen \emph{RD-Parsern} und \emph{Parsergeneratoren}
\vcite{fowler}{261}.

\section{Nicht-textuelle DSLs}
Die Kapitel \ref{interneDSL} und \ref{externeDSL} bezogen sich auf
\emph{textuelle DSLs}. Auch wenn eine \emph{DSL} eine bestimmte \gloss{Domäne}
repräsentiert, bedeutet dies nicht, dass diese Repräsentation immer
\emph{textuell} erfolgen muss
\vcite{ghosh}{19}. Es gibt einige Gründe, mit einer \emph{nicht-textuellen DSL}
zu arbeiten:
\newline
\begin{itemize}
  \item Viele Domänenprobleme können von den Domänennutzern besser durch
  Tabellen oder grafische Darstellungen erklärt werden
  \item Domänenlogik ist in \emph{textueller} Form oft zu komplex und enthält zu
  viele syntaktische Strukturen
  \item Visuelle Modelle sind von Domänenexperten einfacher zu durchdringen und
  zu verändern
\end{itemize}
\vcite{ghosh}{19}\\
Für diesen Ansatz muss der Domänennutzer die Repräsentation des Wissens über
eine \gloss{Domäne} innerhalb eines auf Projektionen basierenden Editors visualisieren.
Mit diesem Editor kann der Domänennutzer die Sicht auf die \gloss{Domäne} verändern,
ohne Quellcode schreiben zu müssen. Im Hintergrund generiert dieser Editor
den Quellcode, welcher die Sicht auf die \gloss{Domäne} modelliert \vcite{ghosh}{19f}.
